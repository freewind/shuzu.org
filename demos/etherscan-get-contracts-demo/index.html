<html>
<head>
    <title>etherscan-get-contracts-demo - 数组网</title>
    <link rel="stylesheet" href="../../css/site.css">
    <link rel="stylesheet" href="../../css/github-markdown-2.10.0.css">
    <script src="../../js/showdown-1.8.6.min.js"></script>
</head>
<body>

<div id="demo-header">
    <div class="site-slogan">etherscan-get-contracts-demo</div>
</div>

<div id="readme" class="center-in-page">
    <div class="markdown markdown-body">
        Python3 Hello World Demo
=========================

Install `python3`:

```
brew install python
```

`python3` and `pip3` will be available.

Run:

```
make init
make test
```

Note:

Install current package:

```
python3 setup.py install
```

or for development:

```
python3 setup.py develop
```

Resources
---------

- &lt;https://www.kennethreitz.org/essays/repository-structure-and-python&gt;
- &lt;https://github.com/kennethreitz/samplemod&gt;
- &lt;https://stackoverflow.com/questions/1471994/what-is-setup-py&gt;
- pypi packages: &lt;https://pypi.python.org/pypi&gt;    </div>
</div>

<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x89df528d2c6db352cd326e6d637f6dd8fa4f4da1.sol" target="_blank" title="show github file">0x89df528d2c6db352cd326e6d637f6dd8fa4f4da1.sol</a>
        </div>
        <div class="path">solidity-files/0x89df528d2c6db352cd326e6d637f6dd8fa4f4da1.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
/*
The Secure Egg

ERC-20 Token Standard Compliant
EIP-621 Compliant

Contract developer: Oyewole Samuel &lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;6e0c071a0d0b1c1a2e09030f0702400d0103&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;
*/
/**
 * @title SafeMath by OpenZeppelin
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c &amp;gt;= a);
        return c;
    }
    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b &amp;lt;= a);
        return a - b;
    }    
}

/**
 * This contract is administered
 */

contract admined {
    address public admin; //Admin address is public
    address public allowed;//Allowed addres is public

    bool public locked = true; //initially locked
    /**
    * @dev This constructor set the initial admin of the contract
    */
    function admined() internal {
        admin = msg.sender; //Set initial admin to contract creator
        Admined(admin);
    }

    modifier onlyAdmin() { //A modifier to define admin-allowed functions
        require(msg.sender == admin || msg.sender == allowed);
        _;
    }

    modifier lock() { //A modifier to lock specific supply functions
        require(locked == false);
        _;
    }


    function allowedAddress(address _allowed) onlyAdmin public {
        allowed = _allowed;
        Allowed(_allowed);
    }
    /**
    * @dev Transfer the adminship of the contract
    * @param _newAdmin The address of the new admin.
    */
    function transferAdminship(address _newAdmin) onlyAdmin public { //Admin can be transfered
        require(_newAdmin != address(0));
        admin = _newAdmin;
        TransferAdminship(admin);
    }
    /**
    * @dev Enable or disable lock
    * @param _locked Status.
    */
    function lockSupply(bool _locked) onlyAdmin public {
        locked = _locked;
        LockedSupply(locked);
    }

    //All admin actions have a log for public review
    event TransferAdminship(address newAdmin);
    event Admined(address administrador);
    event LockedSupply(bool status);
    event Allowed(address allow);
}


/**
 * Token contract interface for external use
 */
contract ERC20TokenInterface {

    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
}

contract ERC20Token is admined, ERC20TokenInterface { //Standar definition of an ERC20Token
    using SafeMath for uint256;
    
    uint256 totalSupply_;
    mapping (address =&amp;gt; uint256) balances; //A mapping of all balances per address
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed; //A mapping of all allowances

    /**
    * @dev Get the balance of an specified address.
    * @param _owner The address to be query.
    */
    function balanceOf(address _owner) public constant returns (uint256 balance) {
      return balances[_owner];
    }

    /**
    * @dev total number of tokens in existence
    */
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }    

    /**
    * @dev transfer token to a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0)); //If you dont want that people destroy token
        require(balances[msg.sender] &amp;gt;= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
    * @dev transfer token from an address to another specified address using allowance
    * @param _from The address where token comes.
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0)); //If you dont want that people destroy token
        require(balances[_from] &amp;gt;= _value &amp;amp;&amp;amp; allowed[_from][msg.sender] &amp;gt;= _value);
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }

    /**
    * @dev Assign allowance to an specified address to use the owner balance
    * @param _spender The address to be allowed to spend.
    * @param _value The amount to be allowed.
    */
    function approve(address _spender, uint256 _value) public returns (bool success) {
      allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
    * @dev Get the allowance of an specified address to use another address balance.
    * @param _owner The address of the owner of the tokens.
    * @param _spender The address of the allowed spender.
    */
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /**
    *Log Events
    */
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract SecureEgg is admined, ERC20Token {
    string public name = &amp;quot;Secure Egg&amp;quot;;
    string public symbol = &amp;quot;SEG&amp;quot;;
    string public version = &amp;quot;1.0&amp;quot;;
    uint8 public decimals = 18;
    address public owner = 0xC365aa1d5C71A61c5b05Dc953a79a125D40ce472;

    function SecureEgg() public {
        totalSupply_ = 1000000000000 * (10**uint256(decimals)); //100 Million total supply.
        balances[this] = totalSupply_;
        allowed[this][owner] = balances[this]; //Contract balance is allowed to creator
        
        _transferTokenToOwner();

        /**
        *Log Events
        */
        Transfer(0, this, totalSupply_);
        Approval(this, msg.sender, balances[this]);

    }
    
    function _transferTokenToOwner() internal {
        balances[this] = balances[this].sub(totalSupply_);
        balances[owner] = balances[owner].add(totalSupply_);
        Transfer(this, owner, totalSupply_);
    }
    /**
    *@dev Function to handle callback calls
    */
    function() public {
        revert();
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x3c057713204f787218764bb8e657e5d886846390.sol" target="_blank" title="show github file">0x3c057713204f787218764bb8e657e5d886846390.sol</a>
        </div>
        <div class="path">solidity-files/0x3c057713204f787218764bb8e657e5d886846390.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT348745&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT348745
    // Name        : ADZbuzz Worldsoccer.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT348745&amp;quot;;
            name = &amp;quot;ADZbuzz Worldsoccer.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x7981953c5b40d664af2febcab8da535aa238d916.sol" target="_blank" title="show github file">0x7981953c5b40d664af2febcab8da535aa238d916.sol</a>
        </div>
        <div class="path">solidity-files/0x7981953c5b40d664af2febcab8da535aa238d916.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT364957&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT364957
    // Name        : ADZbuzz Iflscience.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT364957&amp;quot;;
            name = &amp;quot;ADZbuzz Iflscience.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xe6747e422b58691639fc4fab45486ebc7d4a6a35.sol" target="_blank" title="show github file">0xe6747e422b58691639fc4fab45486ebc7d4a6a35.sol</a>
        </div>
        <div class="path">solidity-files/0xe6747e422b58691639fc4fab45486ebc7d4a6a35.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;ACT453108&amp;#39; token contract
//
// Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
// Symbol      : ACT453108
// Name        : ADZbuzz Mysteriousuniverse.org Community Token
// Total supply: 2000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function ADZbuzzCommunityToken() public {
        symbol = &amp;quot;ACT453108&amp;quot;;
        name = &amp;quot;ADZbuzz Mysteriousuniverse.org Community Token&amp;quot;;
        decimals = 8;
        _totalSupply = 200000000000000;
        balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
        emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x8b4f27b50d622b74716944475bfce0a6b79de573.sol" target="_blank" title="show github file">0x8b4f27b50d622b74716944475bfce0a6b79de573.sol</a>
        </div>
        <div class="path">solidity-files/0x8b4f27b50d622b74716944475bfce0a6b79de573.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity 0.4.19;

// File: contracts/NokuPricingPlan.sol

/**
* @dev The NokuPricingPlan contract defines the responsibilities of a Noku pricing plan.
*/
interface NokuPricingPlan {
    /**
    * @dev Pay the fee for the service identified by the specified name.
    * The fee amount shall already be approved by the client.
    * @param serviceName The name of the target service.
    * @param multiplier The multiplier of the base service fee to apply.
    * @param client The client of the target service.
    * @return true if fee has been paid.
    */
    function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);

    /**
    * @dev Get the usage fee for the service identified by the specified name.
    * The returned fee amount shall be approved before using #payFee method.
    * @param serviceName The name of the target service.
    * @param multiplier The multiplier of the base service fee to apply.
    * @return The amount to approve before really paying such fee.
    */
    function usageFee(bytes32 serviceName, uint256 multiplier) public constant returns(uint fee);
}

// File: zeppelin-solidity/contracts/ownership/Ownable.sol

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol

/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  /**
   * @dev Modifier to make a function callable only when the contract is paused.
   */
  modifier whenPaused() {
    require(paused);
    _;
  }

  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
    paused = false;
    Unpause();
  }
}

// File: zeppelin-solidity/contracts/math/SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol

/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: contracts/NokuTokenBurner.sol

contract BurnableERC20 is ERC20 {
    function burn(uint256 amount) public returns (bool burned);
}

/**
* @dev The NokuTokenBurner contract has the responsibility to burn the configured fraction of received
* ERC20-compliant tokens and distribute the remainder to the configured wallet.
*/
contract NokuTokenBurner is Pausable {
    using SafeMath for uint256;

    event LogNokuTokenBurnerCreated(address indexed caller, address indexed wallet);
    event LogBurningPercentageChanged(address indexed caller, uint256 indexed burningPercentage);

    // The wallet receiving the unburnt tokens.
    address public wallet;

    // The percentage of tokens to burn after being received (range [0, 100])
    uint256 public burningPercentage;

    // The cumulative amount of burnt tokens.
    uint256 public burnedTokens;

    // The cumulative amount of tokens transferred back to the wallet.
    uint256 public transferredTokens;

    /**
    * @dev Create a new NokuTokenBurner with predefined burning fraction.
    * @param _wallet The wallet receiving the unburnt tokens.
    */
    function NokuTokenBurner(address _wallet) public {
        require(_wallet != address(0));
        
        wallet = _wallet;
        burningPercentage = 100;

        LogNokuTokenBurnerCreated(msg.sender, _wallet);
    }

    /**
    * @dev Change the percentage of tokens to burn after being received.
    * @param _burningPercentage The percentage of tokens to be burnt.
    */
    function setBurningPercentage(uint256 _burningPercentage) public onlyOwner {
        require(0 &amp;lt;= _burningPercentage &amp;amp;&amp;amp; _burningPercentage &amp;lt;= 100);
        require(_burningPercentage != burningPercentage);
        
        burningPercentage = _burningPercentage;

        LogBurningPercentageChanged(msg.sender, _burningPercentage);
    }

    /**
    * @dev Called after burnable tokens has been transferred for burning.
    * @param _token THe extended ERC20 interface supported by the sent tokens.
    * @param _amount The amount of burnable tokens just arrived ready for burning.
    */
    function tokenReceived(address _token, uint256 _amount) public whenNotPaused {
        require(_token != address(0));
        require(_amount &amp;gt; 0);

        uint256 amountToBurn = _amount.mul(burningPercentage).div(100);
        if (amountToBurn &amp;gt; 0) {
            assert(BurnableERC20(_token).burn(amountToBurn));
            
            burnedTokens = burnedTokens.add(amountToBurn);
        }

        uint256 amountToTransfer = _amount.sub(amountToBurn);
        if (amountToTransfer &amp;gt; 0) {
            assert(BurnableERC20(_token).transfer(wallet, amountToTransfer));

            transferredTokens = transferredTokens.add(amountToTransfer);
        }
    }
}

// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address =&amp;gt; uint256) balances;

  uint256 totalSupply_;

  /**
  * @dev total number of tokens in existence
  */
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}

// File: zeppelin-solidity/contracts/token/ERC20/BurnableToken.sol

/**
 * @title Burnable Token
 * @dev Token that can be irreversibly burned (destroyed).
 */
contract BurnableToken is BasicToken {

  event Burn(address indexed burner, uint256 value);

  /**
   * @dev Burns a specific amount of tokens.
   * @param _value The amount of token to be burned.
   */
  function burn(uint256 _value) public {
    require(_value &amp;lt;= balances[msg.sender]);
    // no need to require value &amp;lt;= totalSupply, since that would imply the
    // sender&amp;#39;s balance is greater than the totalSupply, which *should* be an assertion failure

    address burner = msg.sender;
    balances[burner] = balances[burner].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    Burn(burner, _value);
  }
}

// File: zeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol

contract DetailedERC20 is ERC20 {
  string public name;
  string public symbol;
  uint8 public decimals;

  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
  }
}

// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol

/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

  mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[_from]);
    require(_value &amp;lt;= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue &amp;gt; oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}

// File: zeppelin-solidity/contracts/token/ERC20/MintableToken.sol

/**
 * @title Mintable token
 * @dev Simple ERC20 Token example, with mintable token creation
 * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
 */
contract MintableToken is StandardToken, Ownable {
  event Mint(address indexed to, uint256 amount);
  event MintFinished();

  bool public mintingFinished = false;


  modifier canMint() {
    require(!mintingFinished);
    _;
  }

  /**
   * @dev Function to mint tokens
   * @param _to The address that will receive the minted tokens.
   * @param _amount The amount of tokens to mint.
   * @return A boolean that indicates if the operation was successful.
   */
  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    Transfer(address(0), _to, _amount);
    return true;
  }

  /**
   * @dev Function to stop minting new tokens.
   * @return True if the operation was successful.
   */
  function finishMinting() onlyOwner canMint public returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
}

// File: contracts/NokuCustomERC20.sol

/**
* @dev The NokuCustomERC20Token contract is a custom ERC20-compliant token available in the Noku Service Platform (NSP).
* The Noku customer is able to choose the token name, symbol, decimals, initial supply and to administer its lifecycle
* by minting or burning tokens in order to increase or decrease the token supply.
*/
contract NokuCustomERC20 is Ownable, DetailedERC20, MintableToken, BurnableToken {
    using SafeMath for uint256;

    event LogNokuCustomERC20Created(
        address indexed caller,
        string indexed name,
        string indexed symbol,
        uint8 decimals,
        address pricingPlan,
        address serviceProvider
    );
    event LogTransferFeePercentageChanged(address indexed caller, uint256 indexed transferFeePercentage);
    event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);

    // The entity acting as Custom token service provider i.e. Noku
    address public serviceProvider;

    // The pricing plan determining the fee to be paid in NOKU tokens by customers for using Noku services
    address public pricingPlan;

    // The fee percentage for Custom token transfer or zero if transfer is free of charge
    uint256 public transferFeePercentage;

    bytes32 public constant CUSTOM_ERC20_BURN_SERVICE_NAME = &amp;quot;NokuCustomERC20.burn&amp;quot;;
    bytes32 public constant CUSTOM_ERC20_MINT_SERVICE_NAME = &amp;quot;NokuCustomERC20.mint&amp;quot;;

    /**
    * @dev Modifier to make a function callable only by service provider i.e. Noku.
    */
    modifier onlyServiceProvider() {
        require(msg.sender == serviceProvider);
        _;
    }

    function NokuCustomERC20(
        string _name,
        string _symbol,
        uint8 _decimals,
        address _pricingPlan,
        address _serviceProvider
    )
    DetailedERC20 (_name, _symbol, _decimals) public
    {
        require(bytes(_name).length &amp;gt; 0);
        require(bytes(_symbol).length &amp;gt; 0);
        require(_pricingPlan != 0);
        require(_serviceProvider != 0);

        pricingPlan = _pricingPlan;
        serviceProvider = _serviceProvider;

        LogNokuCustomERC20Created(
            msg.sender,
            _name,
            _symbol,
            _decimals,
            _pricingPlan,
            _serviceProvider
        );
    }

    function isCustomToken() public pure returns(bool isCustom) {
        return true;
    }

    /**
    * @dev Change the transfer fee percentage to be paid in Custom tokens.
    * @param _transferFeePercentage The fee percentage to be paid for transfer in range [0, 100].
    */
    function setTransferFeePercentage(uint256 _transferFeePercentage) public onlyOwner {
        require(0 &amp;lt;= _transferFeePercentage &amp;amp;&amp;amp; _transferFeePercentage &amp;lt;= 100);
        require(_transferFeePercentage != transferFeePercentage);

        transferFeePercentage = _transferFeePercentage;

        LogTransferFeePercentageChanged(msg.sender, _transferFeePercentage);
    }

    /**
    * @dev Change the pricing plan of service fee to be paid in NOKU tokens.
    * @param _pricingPlan The pricing plan of NOKU token to be paid, zero means flat subscription.
    */
    function setPricingPlan(address _pricingPlan) public onlyServiceProvider {
        require(_pricingPlan != 0);
        require(_pricingPlan != pricingPlan);

        pricingPlan = _pricingPlan;

        LogPricingPlanChanged(msg.sender, _pricingPlan);
    }

    /**
    * @dev Get the fee to be paid for the transfer of NOKU tokens.
    * @param _value The amount of NOKU tokens to be transferred.
    */
    function transferFee(uint256 _value) public view returns (uint256 usageFee) {
        return _value.mul(transferFeePercentage).div(100);
    }

    /**
    * @dev Override #transfer for optionally paying fee to Custom token owner.
    */
    function transfer(address _to, uint256 _value) public returns (bool transferred) {
        if (transferFeePercentage == 0) {
            return super.transfer(_to, _value);
        }
        else {
            uint256 usageFee = transferFee(_value);
            uint256 netValue = _value.sub(usageFee);

            bool feeTransferred = super.transfer(owner, usageFee);
            bool netValueTransferred = super.transfer(_to, netValue);

            return feeTransferred &amp;amp;&amp;amp; netValueTransferred;
        }
    }

    /**
    * @dev Override #transferFrom for optionally paying fee to Custom token owner.
    */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool transferred) {
        if (transferFeePercentage == 0) {
            return super.transferFrom(_from, _to, _value);
        }
        else {
            uint256 usageFee = transferFee(_value);
            uint256 netValue = _value.sub(usageFee);

            bool feeTransferred = super.transferFrom(_from, owner, usageFee);
            bool netValueTransferred = super.transferFrom(_from, _to, netValue);

            return feeTransferred &amp;amp;&amp;amp; netValueTransferred;
        }
    }

    /**
    * @dev Burn a specific amount of tokens, paying the service fee.
    * @param _amount The amount of token to be burned.
    */
    function burn(uint256 _amount) public {
        require(_amount &amp;gt; 0);

        super.burn(_amount);

        require(NokuPricingPlan(pricingPlan).payFee(CUSTOM_ERC20_BURN_SERVICE_NAME, _amount, msg.sender));
    }

    /**
    * @dev Mint a specific amount of tokens, paying the service fee.
    * @param _to The address that will receive the minted tokens.
    * @param _amount The amount of tokens to mint.
    * @return A boolean that indicates if the operation was successful.
    */
    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool minted) {
        require(_to != 0);
        require(_amount &amp;gt; 0);

        super.mint(_to, _amount);

        require(NokuPricingPlan(pricingPlan).payFee(CUSTOM_ERC20_MINT_SERVICE_NAME, _amount, msg.sender));

        return true;
    }
}

// File: contracts/NokuCustomERC20Service.sol

/**
* @dev The NokuCustomERC2Service contract .
*/
contract NokuCustomERC20Service is Pausable {
    event LogNokuCustomERC20ServiceCreated(address caller, address indexed pricingPlan);
    event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);

    uint256 public constant CREATE_AMOUNT = 1 * 10**18;

    uint8 public constant DECIMALS = 18;

    // The pricing plan determining the fee to be paid in NOKU tokens by customers for using Noku services
    address public pricingPlan;

    bytes32 public constant CUSTOM_ERC20_CREATE_SERVICE_NAME = &amp;quot;NokuCustomERC20.create&amp;quot;;

    function NokuCustomERC20Service(address _pricingPlan) public {
        require(_pricingPlan != 0);

        pricingPlan = _pricingPlan;

        LogNokuCustomERC20ServiceCreated(msg.sender, _pricingPlan);
    }

    function setPricingPlan(address _pricingPlan) public onlyOwner {
        require(_pricingPlan != 0);
        require(_pricingPlan != pricingPlan);
        
        pricingPlan = _pricingPlan;

        LogPricingPlanChanged(msg.sender, _pricingPlan);
    }

    function createCustomToken(string _name, string _symbol, uint8 _decimals) public returns(address customTokenAddress) {
        NokuCustomERC20 customToken = new NokuCustomERC20(_name, _symbol, DECIMALS, pricingPlan, owner);

        // Transfer NokuCustomERC20 ownership to the client
        customToken.transferOwnership(msg.sender);

        require(NokuPricingPlan(pricingPlan).payFee(CUSTOM_ERC20_CREATE_SERVICE_NAME, CREATE_AMOUNT, msg.sender));

        return address(customToken);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x9312fc3ea7cf7f317fd09f433aacbe20ad700682.sol" target="_blank" title="show github file">0x9312fc3ea7cf7f317fd09f433aacbe20ad700682.sol</a>
        </div>
        <div class="path">solidity-files/0x9312fc3ea7cf7f317fd09f433aacbe20ad700682.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.13;


contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

contract BACA is ERC20,Ownable{
	using SafeMath for uint256;

	string public constant name=&amp;quot;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;284a4d4d684b474146&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;quot;;
	string public symbol=&amp;quot;BACA&amp;quot;;
	string public constant version = &amp;quot;1.0&amp;quot;;
	uint256 public constant decimals = 18;
	uint256 public totalSupply;

	uint256 public constant MAX_SUPPLY=410000000000*10**decimals;

	
    mapping(address =&amp;gt; uint256) balances;
	mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;
	event GetETH(address indexed _from, uint256 _value);

	function BACA(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}

	function () payable external
	{
		GetETH(msg.sender,msg.value);
	}

	function etherProceeds() external
		onlyOwner
	{
		if(!msg.sender.send(this.balance)) revert();
	}

  	function transfer(address _to, uint256 _value) public  returns (bool)
 	{
		require(_to != address(0));
		// SafeMath.sub will throw if there is not enough balance.
		balances[msg.sender] = balances[msg.sender].sub(_value);
		balances[_to] = balances[_to].add(_value);
		Transfer(msg.sender, _to, _value);
		return true;
  	}

  	function balanceOf(address _owner) public constant returns (uint256 balance) 
  	{
		return balances[_owner];
  	}

  	function transferFrom(address _from, address _to, uint256 _value) public returns (bool) 
  	{
		require(_to != address(0));
		uint256 _allowance = allowed[_from][msg.sender];

		balances[_from] = balances[_from].sub(_value);
		balances[_to] = balances[_to].add(_value);
		allowed[_from][msg.sender] = _allowance.sub(_value);
		Transfer(_from, _to, _value);
		return true;
  	}

  	function approve(address _spender, uint256 _value) public returns (bool) 
  	{
		allowed[msg.sender][_spender] = _value;
		Approval(msg.sender, _spender, _value);
		return true;
  	}

  	function allowance(address _owner, address _spender) public constant returns (uint256 remaining) 
  	{
		return allowed[_owner][_spender];
  	}

	  
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x9b1a4fe6fc8ccd291b65213062f53a1fff903bbd.sol" target="_blank" title="show github file">0x9b1a4fe6fc8ccd291b65213062f53a1fff903bbd.sol</a>
        </div>
        <div class="path">solidity-files/0x9b1a4fe6fc8ccd291b65213062f53a1fff903bbd.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

contract IGold {
    function balanceOf(address _owner) constant returns (uint256);
    function issueTokens(address _who, uint _tokens);
    function burnTokens(address _who, uint _tokens);
}

// StdToken inheritance is commented, because no &amp;#39;totalSupply&amp;#39; needed
contract IMNTP { /*is StdToken */
    function balanceOf(address _owner) constant returns (uint256);

    // Additional methods that MNTP contract provides
    function lockTransfer(bool _lock);
    function issueTokens(address _who, uint _tokens);
    function burnTokens(address _who, uint _tokens);
}

contract SafeMath {
    function safeAdd(uint a, uint b) internal returns (uint) {
        uint c = a + b;
        assert(c&amp;gt;=a &amp;amp;&amp;amp; c&amp;gt;=b);
        return c;
     }

    function safeSub(uint a, uint b) internal returns (uint) {
        assert(b &amp;lt;= a);
        return a - b;
    }
}

contract CreatorEnabled {
    address public creator = 0x0;

    modifier onlyCreator() { require(msg.sender == creator); _; }

    function changeCreator(address _to) public onlyCreator {
        creator = _to;
    }
}

contract StringMover {
    function stringToBytes32(string s) constant returns(bytes32){
        bytes32 out;
        assembly {
             out := mload(add(s, 32))
        }
        return out;
    }

    function stringToBytes64(string s) constant returns(bytes32,bytes32){
        bytes32 out;
        bytes32 out2;

        assembly {
             out := mload(add(s, 32))
             out2 := mload(add(s, 64))
        }
        return (out,out2);
    }

    function bytes32ToString(bytes32 x) constant returns (string) {
        bytes memory bytesString = new bytes(32);
        uint charCount = 0;
        for (uint j = 0; j &amp;lt; 32; j++) {
             byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
             if (char != 0) {
                  bytesString[charCount] = char;
                  charCount++;
             }
        }
        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (j = 0; j &amp;lt; charCount; j++) {
             bytesStringTrimmed[j] = bytesString[j];
        }
        return string(bytesStringTrimmed);
    }

    function bytes64ToString(bytes32 x, bytes32 y) constant returns (string) {
        bytes memory bytesString = new bytes(64);
        uint charCount = 0;

        for (uint j = 0; j &amp;lt; 32; j++) {
             byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
             if (char != 0) {
                  bytesString[charCount] = char;
                  charCount++;
             }
        }
        for (j = 0; j &amp;lt; 32; j++) {
             char = byte(bytes32(uint(y) * 2 ** (8 * j)));
             if (char != 0) {
                  bytesString[charCount] = char;
                  charCount++;
             }
        }

        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (j = 0; j &amp;lt; charCount; j++) {
             bytesStringTrimmed[j] = bytesString[j];
        }
        return string(bytesStringTrimmed);
    }
}


contract Storage is SafeMath, StringMover {
    function Storage() public {
        controllerAddress = msg.sender;
    }

    address public controllerAddress = 0x0;
    modifier onlyController() { require(msg.sender==controllerAddress); _; }

    function setControllerAddress(address _newController) onlyController {
        controllerAddress = _newController;
    }

    address public hotWalletAddress = 0x0;

    function setHotWalletAddress(address _address) onlyController {
       hotWalletAddress = _address;
    }


    // Fields - 1
    mapping(uint =&amp;gt; string) docs;
    uint public docCount = 0;

    // Fields - 2
    mapping(string =&amp;gt; mapping(uint =&amp;gt; int)) fiatTxs;
    mapping(string =&amp;gt; uint) fiatBalancesCents;
    mapping(string =&amp;gt; uint) fiatTxCounts;
    uint fiatTxTotal = 0;

    // Fields - 3
    mapping(string =&amp;gt; mapping(uint =&amp;gt; int)) goldTxs;
    mapping(string =&amp;gt; uint) goldHotBalances;
    mapping(string =&amp;gt; uint) goldTxCounts;
    uint goldTxTotal = 0;

    // Fields - 4
    struct Request {
        address sender;
        string userId;
        string requestHash;
        bool buyRequest;         // otherwise - sell

        // 0 - init
        // 1 - processed
        // 2 - cancelled
        uint8 state;
    }

    mapping (uint=&amp;gt;Request) requests;
    uint public requestsCount = 0;

    ///////
    function addDoc(string _ipfsDocLink) public onlyController returns(uint) {
        docs[docCount] = _ipfsDocLink;
        uint out = docCount;
        docCount++;

        return out;
    }

    function getDocCount() public constant returns (uint) {
        return docCount;
    }

    function getDocAsBytes64(uint _index) public constant returns (bytes32,bytes32) {
        require(_index &amp;lt; docCount);
        return stringToBytes64(docs[_index]);
    }

    function addFiatTransaction(string _userId, int _amountCents) public onlyController returns(uint) {
        require(0 != _amountCents);

        uint c = fiatTxCounts[_userId];

        fiatTxs[_userId][c] = _amountCents;

        if (_amountCents &amp;gt; 0) {
            fiatBalancesCents[_userId] = safeAdd(fiatBalancesCents[_userId], uint(_amountCents));
        } else {
            fiatBalancesCents[_userId] = safeSub(fiatBalancesCents[_userId], uint(-_amountCents));
        }

        fiatTxCounts[_userId] = safeAdd(fiatTxCounts[_userId], 1);

        fiatTxTotal++;
        return c;
    }

    function getFiatTransactionsCount(string _userId) public constant returns (uint) {
        return fiatTxCounts[_userId];
    }

    function getAllFiatTransactionsCount() public constant returns (uint) {
        return fiatTxTotal;
    }

    function getFiatTransaction(string _userId, uint _index) public constant returns(int) {
        require(_index &amp;lt; fiatTxCounts[_userId]);
        return fiatTxs[_userId][_index];
    }

    function getUserFiatBalance(string _userId) public constant returns(uint) {
        return fiatBalancesCents[_userId];
    }

    function addGoldTransaction(string _userId, int _amount) public onlyController returns(uint) {
        require(0 != _amount);

        uint c = goldTxCounts[_userId];

        goldTxs[_userId][c] = _amount;

        if (_amount &amp;gt; 0) {
            goldHotBalances[_userId] = safeAdd(goldHotBalances[_userId], uint(_amount));
        } else {
            goldHotBalances[_userId] = safeSub(goldHotBalances[_userId], uint(-_amount));
        }

        goldTxCounts[_userId] = safeAdd(goldTxCounts[_userId], 1);

        goldTxTotal++;
        return c;
    }

    function getGoldTransactionsCount(string _userId) public constant returns (uint) {
        return goldTxCounts[_userId];
    }

    function getAllGoldTransactionsCount() public constant returns (uint) {
        return goldTxTotal;
    }

    function getGoldTransaction(string _userId, uint _index) public constant returns(int) {
        require(_index &amp;lt; goldTxCounts[_userId]);
        return goldTxs[_userId][_index];
    }

    function getUserHotGoldBalance(string _userId) public constant returns(uint) {
        return goldHotBalances[_userId];
    }

    function addBuyTokensRequest(address _who, string _userId, string _requestHash) public onlyController returns(uint) {
        Request memory r;
        r.sender = _who;
        r.userId = _userId;
        r.requestHash = _requestHash;
        r.buyRequest = true;
        r.state = 0;

        requests[requestsCount] = r;
        uint out = requestsCount;
        requestsCount++;
        return out;
    }

    function addSellTokensRequest(address _who, string _userId, string _requestHash) onlyController returns(uint) {
        Request memory r;
        r.sender = _who;
        r.userId = _userId;
        r.requestHash = _requestHash;
        r.buyRequest = false;
        r.state = 0;

        requests[requestsCount] = r;
        uint out = requestsCount;
        requestsCount++;
        return out;
    }

    function getRequestsCount() public constant returns(uint) {
        return requestsCount;
    }

    function getRequest(uint _index) public constant returns(
        address a,
        bytes32 userId,
        bytes32 hashA, bytes32 hashB,
        bool buy, uint8 state)
    {
        require(_index &amp;lt; requestsCount);

        Request memory r = requests[_index];

        bytes32 userBytes = stringToBytes32(r.userId);
        var (out1, out2) = stringToBytes64(r.requestHash);

        return (r.sender, userBytes, out1, out2, r.buyRequest, r.state);
    }

    function cancelRequest(uint _index) onlyController public {
        require(_index &amp;lt; requestsCount);
        require(0==requests[_index].state);

        requests[_index].state = 2;
    }

    function setRequestProcessed(uint _index) onlyController public {
        requests[_index].state = 1;
    }
}

contract GoldFiatFee is CreatorEnabled, StringMover {
    string gmUserId = &amp;quot;&amp;quot;;

    // Functions:
    function GoldFiatFee(string _gmUserId) {
        creator = msg.sender;
        gmUserId = _gmUserId;
    }

    function getGoldmintFeeAccount() public constant returns(bytes32) {
        bytes32 userBytes = stringToBytes32(gmUserId);
        return userBytes;
    }

    function setGoldmintFeeAccount(string _gmUserId) public onlyCreator {
        gmUserId = _gmUserId;
    }

    function calculateBuyGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint) {
        return 0;
    }

    function calculateSellGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint) {
        // If the sender holds 0 MNTP, then the transaction fee is 3% fiat,
        // If the sender holds at least 10 MNTP, then the transaction fee is 2% fiat,
        // If the sender holds at least 1000 MNTP, then the transaction fee is 1.5% fiat,
        // If the sender holds at least 10000 MNTP, then the transaction fee is 1% fiat,
        if (_mntpBalance &amp;gt;= (10000 * 1 ether)) {
             return (75 * _goldValue / 10000);
        }

        if (_mntpBalance &amp;gt;= (1000 * 1 ether)) {
             return (15 * _goldValue / 1000);
        }

        if (_mntpBalance &amp;gt;= (10 * 1 ether)) {
             return (25 * _goldValue / 1000);
        }

        // 3%
        return (3 * _goldValue / 100);
    }
}

contract IGoldFiatFee {
    function getGoldmintFeeAccount()public constant returns(bytes32);
    function calculateBuyGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint);
    function calculateSellGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint);
}

contract StorageController is SafeMath, CreatorEnabled, StringMover {
    Storage public stor;
    IMNTP public mntpToken;
    IGold public goldToken;
    IGoldFiatFee public fiatFee;

    address public ethDepositAddress = 0x0;
    address public managerAddress = 0x0;

    event NewTokenBuyRequest(address indexed _from, string indexed _userId);
    event NewTokenSellRequest(address indexed _from, string indexed _userId);
    event RequestCancelled(uint indexed _reqId);
    event RequestProcessed(uint indexed _reqId);
    event EthDeposited(uint indexed _requestId, address indexed _address, uint _ethValue);

    modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }

    function StorageController(address _mntpContractAddress, address _goldContractAddress, address _storageAddress, address _fiatFeeContract) {
        creator = msg.sender;

        if (0 != _storageAddress) {
             // use existing storage
             stor = Storage(_storageAddress);
        } else {
             stor = new Storage();
        }

        require(0x0!=_mntpContractAddress);
        require(0x0!=_goldContractAddress);
        require(0x0!=_fiatFeeContract);

        mntpToken = IMNTP(_mntpContractAddress);
        goldToken = IGold(_goldContractAddress);
        fiatFee = IGoldFiatFee(_fiatFeeContract);
    }

    function setEthDepositAddress(address _address) public onlyCreator {
       ethDepositAddress = _address;
    }

    function setManagerAddress(address _address) public onlyCreator {
       managerAddress = _address;
    }

    function getEthDepositAddress() public constant returns (address) {
       return ethDepositAddress;
    }

    // Only old controller can call setControllerAddress
    function changeController(address _newController) public onlyCreator {
        stor.setControllerAddress(_newController);
    }

    function setHotWalletAddress(address _hotWalletAddress) public onlyCreator {
       stor.setHotWalletAddress(_hotWalletAddress);
    }

    function getHotWalletAddress() public constant returns (address) {
        return stor.hotWalletAddress();
    }

    function changeFiatFeeContract(address _newFiatFee) public onlyCreator {
        fiatFee = IGoldFiatFee(_newFiatFee);
    }

    function addDoc(string _ipfsDocLink) public onlyCreator returns(uint) {
        return stor.addDoc(_ipfsDocLink);
    }

    function getDocCount() public constant returns (uint) {
        return stor.docCount();
    }

    function getDoc(uint _index) public constant returns (string) {
        var (x, y) = stor.getDocAsBytes64(_index);
        return bytes64ToString(x,y);
    }


    // _amountCents can be negative
    // returns index in user array
    function addFiatTransaction(string _userId, int _amountCents) public onlyManagerOrCreator returns(uint) {
        return stor.addFiatTransaction(_userId, _amountCents);
    }

    function getFiatTransactionsCount(string _userId) public constant returns (uint) {
        return stor.getFiatTransactionsCount(_userId);
    }

    function getAllFiatTransactionsCount() public constant returns (uint) {
        return stor.getAllFiatTransactionsCount();
    }

    function getFiatTransaction(string _userId, uint _index) public constant returns(int) {
        return stor.getFiatTransaction(_userId, _index);
    }

    function getUserFiatBalance(string _userId) public constant returns(uint) {
        return stor.getUserFiatBalance(_userId);
    }

    function addGoldTransaction(string _userId, int _amount) public onlyManagerOrCreator returns(uint) {
        return stor.addGoldTransaction(_userId, _amount);
    }

    function getGoldTransactionsCount(string _userId) public constant returns (uint) {
        return stor.getGoldTransactionsCount(_userId);
    }

    function getAllGoldTransactionsCount() public constant returns (uint) {
        return stor.getAllGoldTransactionsCount();
    }

    function getGoldTransaction(string _userId, uint _index) public constant returns(int) {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        return stor.getGoldTransaction(_userId, _index);
    }

    function getUserHotGoldBalance(string _userId) public constant returns(uint) {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        return stor.getUserHotGoldBalance(_userId);
    }


    function addBuyTokensRequest(string _userId, string _requestHash) public returns(uint) {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        NewTokenBuyRequest(msg.sender, _userId);
        return stor.addBuyTokensRequest(msg.sender, _userId, _requestHash);
    }

    function addSellTokensRequest(string _userId, string _requestHash) public returns(uint) {
      require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

      NewTokenSellRequest(msg.sender, _userId);

    return stor.addSellTokensRequest(msg.sender, _userId, _requestHash);
    }

    function getRequestsCount() public constant returns(uint) {
        return stor.getRequestsCount();
    }

    function getRequest(uint _index) public constant returns(address, string, string, bool, uint8) {
        var (sender, userIdBytes, hashA, hashB, buy, state) = stor.getRequest(_index);

        string memory userId = bytes32ToString(userIdBytes);
        string memory hash = bytes64ToString(hashA, hashB);

        return (sender, userId, hash, buy, state);
    }

    function cancelRequest(uint _index) onlyManagerOrCreator public {
        RequestCancelled(_index);
        stor.cancelRequest(_index);
    }

    function processRequest(uint _index, uint _amountCents, uint _centsPerGold) onlyManagerOrCreator public {
        require(_index &amp;lt; getRequestsCount());

        var (sender, userId, hash, isBuy, state) = getRequest(_index);
        require(0 == state);

        if (isBuy) {
             processBuyRequest(userId, sender, _amountCents, _centsPerGold);
        } else {
             processSellRequest(userId, sender, _amountCents, _centsPerGold);
        }

        // 3 - update state
        stor.setRequestProcessed(_index);

        // 4 - send event
        RequestProcessed(_index);
    }

    function processBuyRequest(string _userId, address _userAddress, uint _amountCents, uint _centsPerGold) internal {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        uint userFiatBalance = getUserFiatBalance(_userId);
        require(userFiatBalance &amp;gt; 0);

        if (_amountCents &amp;gt; userFiatBalance) {
             _amountCents = userFiatBalance;
        }

        uint userMntpBalance = mntpToken.balanceOf(_userAddress);
        uint fee = fiatFee.calculateBuyGoldFee(userMntpBalance, _amountCents);
        require(_amountCents &amp;gt; fee);

        // 1 - issue tokens minus fee
        uint amountMinusFee = _amountCents;
        if (fee &amp;gt; 0) {
             amountMinusFee = safeSub(_amountCents, fee);
        }

        require(amountMinusFee &amp;gt; 0);

        uint tokens = (uint(amountMinusFee) * 1 ether) / _centsPerGold;
        issueGoldTokens(_userAddress, tokens);

        // request from hot wallet
        if (isHotWallet(_userAddress)) {
          addGoldTransaction(_userId, int(tokens));
        }

        // 2 - add fiat tx
        // negative for buy (total amount including fee!)
        addFiatTransaction(_userId, - int(_amountCents));

        // 3 - send fee to Goldmint
        // positive for sell
        if (fee &amp;gt; 0) {
             string memory gmAccount = bytes32ToString(fiatFee.getGoldmintFeeAccount());
             addFiatTransaction(gmAccount, int(fee));
        }
    }

    function processSellRequest(string _userId, address _userAddress, uint _amountCents, uint _centsPerGold) internal {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        uint tokens = (uint(_amountCents) * 1 ether) / _centsPerGold;
        uint tokenBalance = goldToken.balanceOf(_userAddress);

        if (isHotWallet(_userAddress)) {
            tokenBalance = getUserHotGoldBalance(_userId);
        }

        if (tokenBalance &amp;lt; tokens) {
             tokens = tokenBalance;
             _amountCents = uint((tokens * _centsPerGold) / 1 ether);
        }

        burnGoldTokens(_userAddress, tokens);

        // request from hot wallet
        if (isHotWallet(_userAddress)) {
          addGoldTransaction(_userId, - int(tokens));
        }

        // 2 - add fiat tx
        uint userMntpBalance = mntpToken.balanceOf(_userAddress);
        uint fee = fiatFee.calculateSellGoldFee(userMntpBalance, _amountCents);
        require(_amountCents &amp;gt; fee);

        uint amountMinusFee = _amountCents;

        if (fee &amp;gt; 0) {
             amountMinusFee = safeSub(_amountCents, fee);
        }

        require(amountMinusFee &amp;gt; 0);
        // positive for sell
        addFiatTransaction(_userId, int(amountMinusFee));

        // 3 - send fee to Goldmint
        if (fee &amp;gt; 0) {
             string memory gmAccount = bytes32ToString(fiatFee.getGoldmintFeeAccount());
             addFiatTransaction(gmAccount, int(fee));
        }
    }

    //////// INTERNAL REQUESTS FROM HOT WALLET
    function processInternalRequest(string _userId, bool _isBuy, uint _amountCents, uint _centsPerGold) onlyManagerOrCreator public {
      if (_isBuy) {
          processBuyRequest(_userId, getHotWalletAddress(), _amountCents, _centsPerGold);
      } else {
          processSellRequest(_userId, getHotWalletAddress(), _amountCents, _centsPerGold);
      }
    }

    function transferGoldFromHotWallet(address _to, uint _value, string _userId) onlyManagerOrCreator public {
      require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

      uint balance = getUserHotGoldBalance(_userId);
      require(balance &amp;gt;= _value);

      goldToken.burnTokens(getHotWalletAddress(), _value);
      goldToken.issueTokens(_to, _value);

      addGoldTransaction(_userId, -int(_value));
    }

    ////////
    function issueGoldTokens(address _userAddress, uint _tokenAmount) internal {
        require(0!=_tokenAmount);
        goldToken.issueTokens(_userAddress, _tokenAmount);
    }

    function burnGoldTokens(address _userAddress, uint _tokenAmount) internal {
        require(0!=_tokenAmount);
        goldToken.burnTokens(_userAddress, _tokenAmount);
    }

    function isHotWallet(address _address) internal returns(bool) {
       return _address == getHotWalletAddress();
    }

    ///////
    function depositEth(uint _requestId) public payable {
      require(ethDepositAddress != 0x0);
      //min deposit is 0.01 ETH
      require(msg.value &amp;gt;= 0.01 * 1 ether);

      ethDepositAddress.transfer(msg.value);

      EthDeposited(_requestId, msg.sender, msg.value);
    }

    // do not allow to send money to this contract...
    function() external payable {
      revert();
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x062f2e8a62972c325ed58db3995eae43a8be222f.sol" target="_blank" title="show github file">0x062f2e8a62972c325ed58db3995eae43a8be222f.sol</a>
        </div>
        <div class="path">solidity-files/0x062f2e8a62972c325ed58db3995eae43a8be222f.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;


contract T20Interface {

    uint256 public totalSupply;


    function balanceOf(address _owner) public view returns (uint256 balance);


    function transfer(address _to, uint256 _value) public returns (bool success);

   
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

 
    function approve(address _spender, uint256 _value) public returns (bool success);


    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

     
    event Transfer(address indexed _from, address indexed _to, uint256 _value); 
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}




    contract T20coin is T20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address =&amp;gt; uint256) public balances;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) public allowed;

    string public name;                  
    uint8 public decimals;               
    string public symbol;               

    function T20coin(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;              
        totalSupply = _initialAmount;                        
        name = _tokenName;                                   
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] &amp;gt;= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] &amp;gt;= _value &amp;amp;&amp;amp; allowance &amp;gt;= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance &amp;lt; MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }   
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x42425981257dde45cc96b19c3a0abb4cd68e6650.sol" target="_blank" title="show github file">0x42425981257dde45cc96b19c3a0abb4cd68e6650.sol</a>
        </div>
        <div class="path">solidity-files/0x42425981257dde45cc96b19c3a0abb4cd68e6650.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

/**
 * @title ERC20 Basic smart contract
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;ddb0bcb3a8b8b1bcafbcb2a79dbab0bcb4b1f3beb2b0&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @author modification: Dmitriy Khizhinskiy @McFly.aero
 */
contract ERC20Basic {
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

/**
 * @title LengthValidator smart contract - fix ERC20 short address attack
 * @author Copyright (c) 2018 McFly.aero
 * @author Dmitriy Khizhinskiy
 * @author &amp;quot;MIT&amp;quot;
 */
contract LengthValidator {
    modifier valid_short(uint _cntArgs) {
        assert(msg.data.length == (_cntArgs * 32 + 4));
        _;
    }
}

/**
 * @title Ownable smart contract
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;4d202c233828212c3f2c22370d2a202c2421632e2220&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @author modification: Dmitriy Khizhinskiy @McFly.aero
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
    address public owner;
    address public candidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
    * account.
    */
    function Ownable() public {
        owner = msg.sender;
    }


    /**
    * @dev Throws if called by any account other than the owner.
    */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }


    /**
    * @dev Allows the current owner to _request_ transfer control of the contract to a newOwner.
    * @param newOwner The address to transfer ownership to.
    */
    function requestOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        candidate = newOwner;
    }


    /**
    * @dev Allows the _NEW_ candidate to complete transfer control of the contract to him.
    */
    function confirmOwnership() public {
        require(candidate == msg.sender);
        owner = candidate;
        OwnershipTransferred(owner, candidate);        
    }
}


/**
 * @title MultiOwners smart contract
 * @author Copyright (c) 2018 McFly.aero
 * @author Dmitriy Khizhinskiy
 * @author &amp;quot;MIT&amp;quot;
 */
contract MultiOwners {

    event AccessGrant(address indexed owner);
    event AccessRevoke(address indexed owner);
    
    mapping(address =&amp;gt; bool) owners;
    address public publisher;


    function MultiOwners() public {
        owners[msg.sender] = true;
        publisher = msg.sender;
    }


    modifier onlyOwner() { 
        require(owners[msg.sender] == true);
        _; 
    }


    function isOwner() constant public returns (bool) {
        return owners[msg.sender] ? true : false;
    }


    function checkOwner(address maybe_owner) constant public returns (bool) {
        return owners[maybe_owner] ? true : false;
    }


    function grant(address _owner) onlyOwner public {
        owners[_owner] = true;
        AccessGrant(_owner);
    }


    function revoke(address _owner) onlyOwner public {
        require(_owner != publisher);
        require(msg.sender != _owner);

        owners[_owner] = false;
        AccessRevoke(_owner);
    }
}




/**
 * @title SafeMath
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;5e333f302b3b323f2c3f31241e39333f3732703d3133&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    /**
    * @dev Multiplies two numbers, throws on overflow.
    */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }


    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
        return c;
    }


    /**
    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b &amp;lt;= a);
        return a - b;
    }


    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c &amp;gt;= a);
        return c;
    }
}











/**
 * @title BasicToken smart contract
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;6c010d021909000d1e0d03162c0b010d0500420f0301&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @author modification: Dmitriy Khizhinskiy @McFly.aero
 */






/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic, LengthValidator {
    using SafeMath for uint256;

    mapping(address =&amp;gt; uint256) balances;

    uint256 totalSupply_;

    /**
    * @dev total number of tokens in existence
    */
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }


    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) valid_short(2) public returns (bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }


    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

}


/**
 * @title ERC20 smart contract
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;4c212d223929202d3e2d23360c2b212d2520622f2321&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @author modification: Dmitriy Khizhinskiy @McFly.aero
 */




/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

/**
 * @title Standard ERC20 token
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;177a767962727b766576786d57707a767e7b3974787a&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @author modification: Dmitriy Khizhinskiy @McFly.aero
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;
  
    /** 
    * @dev Transfer tokens from one address to another
    * @param _from address The address which you want to send tokens from
    * @param _to address The address which you want to transfer to
    * @param _value uint256 the amount of tokens to be transferred
    */
    function transferFrom(address _from, address _to, uint256 _value) valid_short(3) public returns (bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[_from]);
        require(_value &amp;lt;= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }


    /**
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    *
    * Beware that changing an allowance with this method brings the risk that someone may use both the old
    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
    * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    * @param _spender The address which will spend the funds.
    * @param _value The amount of tokens to be spent.
    */
    function approve(address _spender, uint256 _value) valid_short(2) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }


    /**
    * @dev Function to check the amount of tokens that an owner allowed to a spender.
    * @param _owner address The address which owns the funds.
    * @param _spender address The address which will spend the funds.
    * @return A uint256 specifying the amount of tokens still available for the spender.
    */
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }


    /**
    * @dev Increase the amount of tokens that an owner allowed to a spender.
    *
    * approve should be called when allowed[_spender] == 0. To increment
    * allowed value is better to use this function to avoid 2 calls (and wait until
    * the first transaction is mined)
    * From MonolithDAO Token.sol
    * @param _spender The address which will spend the funds.
    * @param _addedValue The amount of tokens to increase the allowance by.
    */
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }


    /**
    * @dev Decrease the amount of tokens that an owner allowed to a spender.
    *
    * approve should be called when allowed[_spender] == 0. To decrement
    * allowed value is better to use this function to avoid 2 calls (and wait until
    * the first transaction is mined)
    * From MonolithDAO Token.sol
    * @param _spender The address which will spend the funds.
    * @param _subtractedValue The amount of tokens to decrease the allowance by.
    */
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue &amp;gt; oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}


/**
 * @title Mintable token smart contract
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;fc919d928999909d8e9d9386bc9b919d9590d29f9391&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @author modification: Dmitriy Khizhinskiy @McFly.aero
 * @dev Simple ERC20 Token example, with mintable token creation
 * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
 */
contract MintableToken is StandardToken, Ownable {
    event Mint(address indexed to, uint256 amount);
    event MintFinished();

    bool public mintingFinished = false;

    modifier canMint() {
        require(!mintingFinished);
        _;
    }


    /**
    * @dev Function to mint tokens
    * @param _to The address that will receive the minted tokens.
    * @param _amount The amount of tokens to mint.
    * @return A boolean that indicates if the operation was successful.
    */
    function mint(address _to, uint256 _amount) onlyOwner canMint valid_short(2) public returns (bool) {
        totalSupply_ = totalSupply_.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        Mint(_to, _amount);
        Transfer(address(0), _to, _amount);
        return true;
    }


    /**
    * @dev Function to stop minting new tokens.
    * @return True if the operation was successful.
    */
    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        MintFinished();
        return true;
    }
}


/**
 * @title McFly token smart contract
 * @author Copyright (c) 2018 McFly.aero
 * @author Dmitriy Khizhinskiy
 * @author &amp;quot;MIT&amp;quot;
 */
contract McFlyToken is MintableToken {
    string public constant name = &amp;quot;McFlyToken&amp;quot;;
    string public constant symbol = &amp;quot;McFly&amp;quot;;
    uint8 public constant decimals = 18;

    /// @dev mapping for whitelist
    mapping(address=&amp;gt;bool) whitelist;

    /// @dev event throw when allowed to transfer address added to whitelist
    /// @param from address
    event AllowTransfer(address from);

    /// @dev check for allowence of transfer
    modifier canTransfer() {
        require(mintingFinished || whitelist[msg.sender]);
        _;        
    }

    /// @dev add address to whitelist
    /// @param from address to add
    function allowTransfer(address from) onlyOwner public {
        whitelist[from] = true;
        AllowTransfer(from);
    }

    /// @dev Do the transfer from address to address value
    /// @param from address from
    /// @param to address to
    /// @param value uint256
    function transferFrom(address from, address to, uint256 value) canTransfer public returns (bool) {
        return super.transferFrom(from, to, value);
    }

    /// @dev Do the transfer from token address to &amp;quot;to&amp;quot; address value
    /// @param to address to
    /// @param value uint256 value
    function transfer(address to, uint256 value) canTransfer public returns (bool) {
        return super.transfer(to, value);
    }
}







/**
 * @title Haltable smart contract - controls owner access
 * @author Copyright (c) 2018 McFly.aero
 * @author Dmitriy Khizhinskiy
 * @author &amp;quot;MIT&amp;quot;
 */
contract Haltable is MultiOwners {
    bool public halted;

    modifier stopInEmergency {
        require(!halted);
        _;
    }


    modifier onlyInEmergency {
        require(halted);
        _;
    }


    /// @dev called by the owner on emergency, triggers stopped state
    function halt() external onlyOwner {
        halted = true;
    }


    /// @dev called by the owner on end of emergency, returns to normal state
    function unhalt() external onlyOwner onlyInEmergency {
        halted = false;
    }

}



/**
 * @title McFly crowdsale smart contract
 * @author Copyright (c) 2018 McFly.aero
 * @author Dmitriy Khizhinskiy
 * @author &amp;quot;MIT&amp;quot;
 * @dev inherited from MultiOwners &amp;amp; Haltable
 */
contract McFlyCrowd is MultiOwners, Haltable {
    using SafeMath for uint256;

    /// @dev Total ETH received during WAVES, TLP1.2 &amp;amp; window[1-5]
    uint256 public counter_in; // tlp2
    
    /// @dev minimum ETH to partisipate in window 1-5
    uint256 public minETHin = 1e18; // 1 ETH

    /// @dev Token
    McFlyToken public token;

    /// @dev Withdraw wallet
    address public wallet;

    /// @dev start and end timestamp for TLP 1.2, other values callculated
    uint256 public sT2; // startTimeTLP2
    uint256 constant dTLP2 = 118 days; // days of TLP2
    uint256 constant dBt = 60 days; // days between Windows
    uint256 constant dW = 12 days; // 12 days for 3,4,5,6,7 windows;

    /// @dev Cap maximum possible tokens for minting
    uint256 public constant hardCapInTokens = 1800e24; // 1,800,000,000 MFL

    /// @dev maximum possible tokens for sell 
    uint256 public constant mintCapInTokens = 1260e24; // 1,260,000,000 MFL

    /// @dev tokens crowd within TLP2
    uint256 public crowdTokensTLP2;

    /// @dev tokens crowd before this contract (MFL tokens)
    uint256 preMcFlyTotalSupply;

    /// @dev maximum possible tokens for fund minting
    uint256 constant fundTokens = 270e24; // 270,000,000 MFL
    uint256 public fundTotalSupply;
    address public fundMintingAgent;
                                                          
    /// @dev maximum possible tokens to convert from WAVES
    uint256 wavesTokens = 100e24; // 100,000,000 MFL
    address public wavesAgent;
    address public wavesGW;

    /// @dev Vesting param for team, advisory, reserve.
    uint256 VestingPeriodInSeconds = 30 days; // 24 month
    uint256 VestingPeriodsCount = 24;

    /// @dev Team 10%
    uint256 _teamTokens;
    uint256 public teamTotalSupply;
    address public teamWallet;

    /// @dev Bounty 5% (2% + 3%)
    /// @dev Bounty online 2%
    uint256 _bountyOnlineTokens;
    address public bountyOnlineWallet;
    address public bountyOnlineGW;

    /// @dev Bounty offline 3%
    uint256 _bountyOfflineTokens;
    address public bountyOfflineWallet;

    /// @dev Advisory 5%
    uint256 _advisoryTokens;
    uint256 public advisoryTotalSupply;
    address public advisoryWallet;

    /// @dev Reserved for future 9%
    uint256 _reservedTokens;
    uint256 public reservedTotalSupply;
    address public reservedWallet;

    /// @dev AirDrop 1%
    uint256 _airdropTokens;
    address public airdropWallet;
    address public airdropGW;

    /// @dev PreMcFly wallet (MFL)
    uint256 _preMcFlyTokens;
    address public preMcFlyWallet;

    /// @dev Ppl structure for Win1-5
    struct Ppl {
        address addr;
        uint256 amount;
    }
    mapping (uint32 =&amp;gt; Ppl) public ppls;

    /// @dev Window structure for Win1-5
    struct Window {
        bool active;
        uint256 totalEthInWindow;
        uint32 totalTransCnt;
        uint32 refundIndex;
        uint256 tokenPerWindow;
    } 
    mapping (uint8 =&amp;gt; Window) public ww;


    /// @dev Events
    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
    event TokenPurchaseInWindow(address indexed beneficiary, uint256 value, uint8 winnum, uint32 totalcnt, uint256 totaleth1);
    event TransferOddEther(address indexed beneficiary, uint256 value);
    event FundMinting(address indexed beneficiary, uint256 value);
    event WithdrawVesting(address indexed beneficiary, uint256 period, uint256 value, uint256 valueTotal);
    event TokenWithdrawAtWindow(address indexed beneficiary, uint256 value);
    event SetFundMintingAgent(address newAgent);
    event SetTeamWallet(address newTeamWallet);
    event SetAdvisoryWallet(address newAdvisoryWallet);
    event SetReservedWallet(address newReservedWallet);
    event SetStartTimeTLP2(uint256 newStartTimeTLP2);
    event SetMinETHincome(uint256 newMinETHin);
    event NewWindow(uint8 winNum, uint256 amountTokensPerWin);
    event TokenETH(uint256 totalEth, uint32 totalCnt);


    /// @dev check for Non zero value
    modifier validPurchase() {
        bool nonZeroPurchase = msg.value != 0;
        require(nonZeroPurchase);
        _;        
    }

    // comment this functions after test passed !!
    /*function getPpls(uint32 index) constant public returns (uint256) {
        return (ppls[index].amount);
    }
    function getPplsAddr(uint32 index) constant public returns (address) {
        return (ppls[index].addr);
    }
    function getWtotalEth(uint8 winNum) constant public returns (uint256) {
        return (ww[winNum].totalEthInWindow);
    }
    function getWtoken(uint8 winNum) constant public returns (uint256) {
        return (ww[winNum].tokenPerWindow);
    }
    function getWactive(uint8 winNum) constant public returns (bool) {
        return (ww[winNum].active);
    }
    function getWtotalTransCnt(uint8 winNum) constant public returns (uint32) {
        return (ww[winNum].totalTransCnt);
    }
    function getWrefundIndex(uint8 winNum) constant public returns (uint32) {
        return (ww[winNum].refundIndex);
    }*/
    // END comment this functions after test passed !!


    /**
     * @dev conctructor of contract, set main params, create new token, do minting for some wallets
     * @param _startTimeTLP2 - set date time of starting of TLP2 (main date!)
     * @param _preMcFlyTotalSupply - set amount in wei total supply of previouse contract (MFL)
     * @param _wallet - wallet for transfer ETH to it
     * @param _wavesAgent - wallet for WAVES gw
     * @param _wavesGW    - wallet for WAVES gw
     * @param _fundMintingAgent - wallet who allowed to mint before TLP2
     * @param _teamWallet - wallet for team vesting
     * @param _bountyOnlineWallet - wallet for online bounty
     * @param _bountyOnlineGW - wallet for online bounty GW
     * @param _bountyOfflineWallet - wallet for offline bounty
     * @param _advisoryWallet - wallet for advisory vesting
     * @param _reservedWallet - wallet for reserved vesting
     * @param _airdropWallet - wallet for airdrop
     * @param _airdropGW - wallet for airdrop GW
     * @param _preMcFlyWallet - wallet for transfer old MFL-&amp;gt;McFly (once)
     */
    function McFlyCrowd(
        uint256 _startTimeTLP2,
        uint256 _preMcFlyTotalSupply,
        address _wallet,
        address _wavesAgent,
        address _wavesGW,
        address _fundMintingAgent,
        address _teamWallet,
        address _bountyOnlineWallet,
        address _bountyOnlineGW,
        address _bountyOfflineWallet,
        address _advisoryWallet,
        address _reservedWallet,
        address _airdropWallet,
        address _airdropGW,
        address _preMcFlyWallet
    ) public 
    {   
        require(_startTimeTLP2 &amp;gt;= block.timestamp);
        require(_preMcFlyTotalSupply &amp;gt; 0);
        require(_wallet != 0x0);
        require(_wavesAgent != 0x0);
        require(_wavesGW != 0x0);
        require(_fundMintingAgent != 0x0);
        require(_teamWallet != 0x0);
        require(_bountyOnlineWallet != 0x0);
        require(_bountyOnlineGW != 0x0);
        require(_bountyOfflineWallet != 0x0);
        require(_advisoryWallet != 0x0);
        require(_reservedWallet != 0x0);
        require(_airdropWallet != 0x0);
        require(_airdropGW != 0x0);
        require(_preMcFlyWallet != 0x0);

        token = new McFlyToken();

        wallet = _wallet;

        sT2 = _startTimeTLP2;
        setStartEndTimeTLP(_startTimeTLP2);

        wavesAgent = _wavesAgent;
        wavesGW = _wavesGW;

        fundMintingAgent = _fundMintingAgent;

        teamWallet = _teamWallet;
        bountyOnlineWallet = _bountyOnlineWallet;
        bountyOnlineGW = _bountyOnlineGW;
        bountyOfflineWallet = _bountyOfflineWallet;
        advisoryWallet = _advisoryWallet;
        reservedWallet = _reservedWallet;
        airdropWallet = _airdropWallet;
        airdropGW = _airdropGW;
        preMcFlyWallet = _preMcFlyWallet;

        /// @dev Mint all tokens and than control it by vesting
        _preMcFlyTokens = _preMcFlyTotalSupply; // McFly for thansfer to old MFL owners
        token.mint(preMcFlyWallet, _preMcFlyTokens);
        token.allowTransfer(preMcFlyWallet);
        crowdTokensTLP2 = crowdTokensTLP2.add(_preMcFlyTokens);

        token.mint(wavesAgent, wavesTokens); // 100,000,000 MFL
        token.allowTransfer(wavesAgent);
        token.allowTransfer(wavesGW);
        crowdTokensTLP2 = crowdTokensTLP2.add(wavesTokens);

        _teamTokens = 180e24; // 180,000,000 MFL
        token.mint(this, _teamTokens); // mint to contract address

        _bountyOnlineTokens = 36e24; // 36,000,000 MFL
        token.mint(bountyOnlineWallet, _bountyOnlineTokens);
        token.allowTransfer(bountyOnlineWallet);
        token.allowTransfer(bountyOnlineGW);

        _bountyOfflineTokens = 54e24; // 54,000,000 MFL
        token.mint(bountyOfflineWallet, _bountyOfflineTokens);
        token.allowTransfer(bountyOfflineWallet);

        _advisoryTokens = 90e24; // 90,000,000 MFL
        token.mint(this, _advisoryTokens);

        _reservedTokens = 162e24; // 162,000,000 MFL
        token.mint(this, _reservedTokens);

        _airdropTokens = 18e24; // 18,000,000 MFL
        token.mint(airdropWallet, _airdropTokens);
        token.allowTransfer(airdropWallet);
        token.allowTransfer(airdropGW);
    }


    /**
     * @dev check is TLP2 is active?
     * @return false if crowd TLP2 event was ended
     */
    function withinPeriod() constant public returns (bool) {
        bool withinPeriodTLP2 = (now &amp;gt;= sT2 &amp;amp;&amp;amp; now &amp;lt;= (sT2+dTLP2));
        return withinPeriodTLP2;
    }


    /**
     * @dev check is TLP2 is active and minting Not finished
     * @return false if crowd event was ended
     */
    function running() constant public returns (bool) {
        return withinPeriod() &amp;amp;&amp;amp; !token.mintingFinished();
    }


    /**
     * @dev check current stage name
     * @return uint8 stage number
     */
    function stageName() constant public returns (uint8) {
        uint256 eT2 = sT2+dTLP2;

        if (now &amp;lt; sT2) {return 101;} // not started
        if (now &amp;gt;= sT2 &amp;amp;&amp;amp; now &amp;lt;= eT2) {return (102);} // TLP1.2

        if (now &amp;gt; eT2 &amp;amp;&amp;amp; now &amp;lt; eT2+dBt) {return (103);} // preTLP1.3
        if (now &amp;gt;= (eT2+dBt) &amp;amp;&amp;amp; now &amp;lt;= (eT2+dBt+dW)) {return (0);} // TLP1.3
        if (now &amp;gt; (eT2+dBt+dW) &amp;amp;&amp;amp; now &amp;lt; (eT2+dBt+dW+dBt)) {return (104);} // preTLP1.4
        if (now &amp;gt;= (eT2+dBt+dW+dBt) &amp;amp;&amp;amp; now &amp;lt;= (eT2+dBt+dW+dBt+dW)) {return (1);} // TLP1.4
        if (now &amp;gt; (eT2+dBt+dW+dBt+dW) &amp;amp;&amp;amp; now &amp;lt; (eT2+dBt+dW+dBt+dW+dBt)) {return (105);} // preTLP1.5
        if (now &amp;gt;= (eT2+dBt+dW+dBt+dW+dBt) &amp;amp;&amp;amp; now &amp;lt;= (eT2+dBt+dW+dBt+dW+dBt+dW)) {return (2);} // TLP1.5
        if (now &amp;gt; (eT2+dBt+dW+dBt+dW+dBt+dW) &amp;amp;&amp;amp; now &amp;lt; (eT2+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (106);} // preTLP1.6
        if (now &amp;gt;= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt) &amp;amp;&amp;amp; now &amp;lt;= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (3);} // TLP1.6
        if (now &amp;gt; (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW) &amp;amp;&amp;amp; now &amp;lt; (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (107);} // preTLP1.7
        if (now &amp;gt;= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt) &amp;amp;&amp;amp; now &amp;lt;= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (4);} // TLP1.7&amp;quot;
        if (now &amp;gt; (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (200);} // Finished
        return (201); // unknown
    }


    /** 
     * @dev change agent for minting
     * @param agent - new agent address
     */
    function setFundMintingAgent(address agent) onlyOwner public {
        fundMintingAgent = agent;
        SetFundMintingAgent(agent);
    }


    /** 
     * @dev change wallet for team vesting (this make possible to set smart-contract address later)
     * @param _newTeamWallet - new wallet address
     */
    function setTeamWallet(address _newTeamWallet) onlyOwner public {
        teamWallet = _newTeamWallet;
        SetTeamWallet(_newTeamWallet);
    }


    /** 
     * @dev change wallet for advisory vesting (this make possible to set smart-contract address later)
     * @param _newAdvisoryWallet - new wallet address
     */
    function setAdvisoryWallet(address _newAdvisoryWallet) onlyOwner public {
        advisoryWallet = _newAdvisoryWallet;
        SetAdvisoryWallet(_newAdvisoryWallet);
    }


    /** 
     * @dev change wallet for reserved vesting (this make possible to set smart-contract address later)
     * @param _newReservedWallet - new wallet address
     */
    function setReservedWallet(address _newReservedWallet) onlyOwner public {
        reservedWallet = _newReservedWallet;
        SetReservedWallet(_newReservedWallet);
    }


    /**
     * @dev change min ETH income during Window1-5
     * @param _minETHin - new limit
     */
    function setMinETHin(uint256 _minETHin) onlyOwner public {
        minETHin = _minETHin;
        SetMinETHincome(_minETHin);
    }


    /**
     * @dev set TLP1.X (2-7) start &amp;amp; end dates
     * @param _at - new or old start date
     */
    function setStartEndTimeTLP(uint256 _at) onlyOwner public {
        require(block.timestamp &amp;lt; sT2); // forbid change time when TLP1.2 is active
        require(block.timestamp &amp;lt; _at); // should be great than current block timestamp

        sT2 = _at;
        SetStartTimeTLP2(_at);
    }


    /**
     * @dev Large Token Holder minting 
     * @param to - mint to address
     * @param amount - how much mint
     */
    function fundMinting(address to, uint256 amount) stopInEmergency public {
        require(msg.sender == fundMintingAgent || isOwner());
        require(block.timestamp &amp;lt; sT2);
        require(fundTotalSupply + amount &amp;lt;= fundTokens);
        require(token.totalSupply() + amount &amp;lt;= hardCapInTokens);

        fundTotalSupply = fundTotalSupply.add(amount);
        token.mint(to, amount);
        FundMinting(to, amount);
    }


    /**
     * @dev calculate amount
     * @param  amount - ether to be converted to tokens
     * @param  at - current time
     * @param  _totalSupply - total supplied tokens
     * @return tokens amount that we should send to our dear ppl
     * @return odd ethers amount, which contract should send back
     */
    function calcAmountAt(
        uint256 amount,
        uint256 at,
        uint256 _totalSupply
    ) public constant returns (uint256, uint256) 
    {
        uint256 estimate;
        uint256 price;
        
        if (at &amp;gt;= sT2 &amp;amp;&amp;amp; at &amp;lt;= (sT2+dTLP2)) {
            if (at &amp;lt;= sT2 + 15 days) {price = 12e13;} else if (at &amp;lt;= sT2 + 30 days) {
                price = 14e13;} else if (at &amp;lt;= sT2 + 45 days) {
                    price = 16e13;} else if (at &amp;lt;= sT2 + 60 days) {
                        price = 18e13;} else if (at &amp;lt;= sT2 + 75 days) {
                            price = 20e13;} else if (at &amp;lt;= sT2 + 90 days) {
                                price = 22e13;} else if (at &amp;lt;= sT2 + 105 days) {
                                    price = 24e13;} else if (at &amp;lt;= sT2 + 118 days) {
                                        price = 26e13;} else {revert();}
        } else {revert();}

        estimate = _totalSupply.add(amount.mul(1e18).div(price));

        if (estimate &amp;gt; hardCapInTokens) {
            return (
                hardCapInTokens.sub(_totalSupply),
                estimate.sub(hardCapInTokens).mul(price).div(1e18)
            );
        }
        return (estimate.sub(_totalSupply), 0);
    }


    /**
     * @dev fallback for processing ether
     */
    function() payable public {
        return getTokens(msg.sender);
    }


    /**
     * @dev sell token and send to contributor address
     * @param contributor address
     */
    function getTokens(address contributor) payable stopInEmergency validPurchase public {
        uint256 amount;
        uint256 oddEthers;
        uint256 ethers;
        uint256 _at;
        uint8 _winNum;

        _at = block.timestamp;

        require(contributor != 0x0);
       
        if (withinPeriod()) {
        
            (amount, oddEthers) = calcAmountAt(msg.value, _at, token.totalSupply());  // recheck!!!
  
            require(amount + token.totalSupply() &amp;lt;= hardCapInTokens);

            ethers = msg.value.sub(oddEthers);

            token.mint(contributor, amount); // fail if minting is finished
            TokenPurchase(contributor, ethers, amount);
            counter_in = counter_in.add(ethers);
            crowdTokensTLP2 = crowdTokensTLP2.add(amount);

            if (oddEthers &amp;gt; 0) {
                require(oddEthers &amp;lt; msg.value);
                contributor.transfer(oddEthers);
                TransferOddEther(contributor, oddEthers);
            }

            wallet.transfer(ethers);
        } else {
            require(msg.value &amp;gt;= minETHin); // checks min ETH income
            _winNum = stageName();
            require(_winNum &amp;gt;= 0 &amp;amp;&amp;amp; _winNum &amp;lt; 5);
            Window storage w = ww[_winNum];

            require(w.tokenPerWindow &amp;gt; 0); // check that we have tokens!

            w.totalEthInWindow = w.totalEthInWindow.add(msg.value);
            ppls[w.totalTransCnt].addr = contributor;
            ppls[w.totalTransCnt].amount = msg.value;
            w.totalTransCnt++;
            TokenPurchaseInWindow(contributor, msg.value, _winNum, w.totalTransCnt, w.totalEthInWindow);
        }
    }


    /**
     * @dev close Window and transfer Eth to wallet address
     * @param _winNum - number of window 0-4 to close
     */
    function closeWindow(uint8 _winNum) onlyOwner stopInEmergency public {
        require(ww[_winNum].active);
        ww[_winNum].active = false;

        wallet.transfer(this.balance);
    }


    /**
     * @dev transfer tokens to ppl accts (window1-5)
     * @param _winNum - number of window 0-4 to close
     */
    function sendTokensWindow(uint8 _winNum) onlyOwner stopInEmergency public {
        uint256 _tokenPerETH;
        uint256 _tokenToSend = 0;
        address _tempAddr;
        uint32 index = ww[_winNum].refundIndex;

        TokenETH(ww[_winNum].totalEthInWindow, ww[_winNum].totalTransCnt);

        require(ww[_winNum].active);
        require(ww[_winNum].totalEthInWindow &amp;gt; 0);
        require(ww[_winNum].totalTransCnt &amp;gt; 0);

        _tokenPerETH = ww[_winNum].tokenPerWindow.div(ww[_winNum].totalEthInWindow); // max McFly in window / ethInWindow

        while (index &amp;lt; ww[_winNum].totalTransCnt &amp;amp;&amp;amp; msg.gas &amp;gt; 100000) {
            _tokenToSend = _tokenPerETH.mul(ppls[index].amount);
            ppls[index].amount = 0;
            _tempAddr = ppls[index].addr;
            ppls[index].addr = 0;
            index++;
            token.transfer(_tempAddr, _tokenToSend);
            TokenWithdrawAtWindow(_tempAddr, _tokenToSend);
        }
        ww[_winNum].refundIndex = index;
    }


    /**
     * @dev open new window 0-5 and write totl token per window in structure
     * @param _winNum - number of window 0-4 to close
     * @param _tokenPerWindow - total token for window 0-4
     */
    function newWindow(uint8 _winNum, uint256 _tokenPerWindow) private {
        ww[_winNum] = Window(true, 0, 0, 0, _tokenPerWindow);
        NewWindow(_winNum, _tokenPerWindow);
    }


    /**
     * @dev Finish crowdsale TLP1.2 period and open window1-5 crowdsale
     */
    function finishCrowd() onlyOwner public {
        uint256 _tokenPerWindow;
        require(now &amp;gt; (sT2.add(dTLP2)) || hardCapInTokens == token.totalSupply());
        require(!token.mintingFinished());

        _tokenPerWindow = (mintCapInTokens.sub(crowdTokensTLP2).sub(fundTotalSupply)).div(5);
        token.mint(this, _tokenPerWindow.mul(5)); // mint to contract address
        // shoud be MAX tokens minted!!! 1,800,000,000
        for (uint8 y = 0; y &amp;lt; 5; y++) {
            newWindow(y, _tokenPerWindow);
        }

        token.finishMinting();
    }


    /**
     * @dev withdraw tokens amount within vesting rules for team, advisory and reserved
     * @param withdrawWallet - wallet to transfer tokens
     * @param withdrawTokens - amount of tokens to transfer to
     * @param withdrawTotalSupply - total amount of tokens transfered to account
     * @return unit256 total amount of tokens after transfer
     */
    function vestingWithdraw(address withdrawWallet, uint256 withdrawTokens, uint256 withdrawTotalSupply) private returns (uint256) {
        require(token.mintingFinished());
        require(msg.sender == withdrawWallet || isOwner());

        uint256 currentPeriod = (block.timestamp.sub(sT2.add(dTLP2))).div(VestingPeriodInSeconds);
        if (currentPeriod &amp;gt; VestingPeriodsCount) {
            currentPeriod = VestingPeriodsCount;
        }
        uint256 tokenAvailable = withdrawTokens.mul(currentPeriod).div(VestingPeriodsCount).sub(withdrawTotalSupply);  // RECHECK!!!!!

        require(withdrawTotalSupply + tokenAvailable &amp;lt;= withdrawTokens);

        uint256 _withdrawTotalSupply = withdrawTotalSupply + tokenAvailable;

        token.transfer(withdrawWallet, tokenAvailable);
        WithdrawVesting(withdrawWallet, currentPeriod, tokenAvailable, _withdrawTotalSupply);

        return _withdrawTotalSupply;
    }


    /**
     * @dev withdraw tokens amount within vesting rules for team
     */
    function teamWithdraw() public {
        teamTotalSupply = vestingWithdraw(teamWallet, _teamTokens, teamTotalSupply);
    }


    /**
     * @dev withdraw tokens amount within vesting rules for advisory
     */
    function advisoryWithdraw() public {
        advisoryTotalSupply = vestingWithdraw(advisoryWallet, _advisoryTokens, advisoryTotalSupply);
    }


    /**
     * @dev withdraw tokens amount within vesting rules for reserved wallet
     */
    function reservedWithdraw() public {
        reservedTotalSupply = vestingWithdraw(reservedWallet, _reservedTokens, reservedTotalSupply);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xb280ff2d72bc6a2190b6faf3fec330c5bbba535f.sol" target="_blank" title="show github file">0xb280ff2d72bc6a2190b6faf3fec330c5bbba535f.sol</a>
        </div>
        <div class="path">solidity-files/0xb280ff2d72bc6a2190b6faf3fec330c5bbba535f.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;ACT167113&amp;#39; token contract
//
// Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
// Symbol      : ACT167113
// Name        : ADZbuzz Nbcnews.com Community Token
// Total supply: 2000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function ADZbuzzCommunityToken() public {
        symbol = &amp;quot;ACT167113&amp;quot;;
        name = &amp;quot;ADZbuzz Nbcnews.com Community Token&amp;quot;;
        decimals = 8;
        _totalSupply = 200000000000000;
        balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
        emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x1da7280c3c48d1a38b4fed5a12d086150483ffa2.sol" target="_blank" title="show github file">0x1da7280c3c48d1a38b4fed5a12d086150483ffa2.sol</a>
        </div>
        <div class="path">solidity-files/0x1da7280c3c48d1a38b4fed5a12d086150483ffa2.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT333522&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT333522
    // Name        : ADZbuzz Cyclingnews.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT333522&amp;quot;;
            name = &amp;quot;ADZbuzz Cyclingnews.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x2d07d53c82978fdce1dae5d5dee38923f520dd63.sol" target="_blank" title="show github file">0x2d07d53c82978fdce1dae5d5dee38923f520dd63.sol</a>
        </div>
        <div class="path">solidity-files/0x2d07d53c82978fdce1dae5d5dee38923f520dd63.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.16;

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }

contract ZazToken {
    // Public variables of the token
    string public name = &amp;quot;ZAZ TOKEN&amp;quot;;
    string public symbol = &amp;quot;ZTZ&amp;quot;;
    uint8 public decimals = 0;
    // 18 decimals is the strongly suggested default
    uint256 public totalSupply;
    uint256 public zazSupply = 20000000;
    uint256 public price ;
    address public creator;
    // This creates an array with all balances
    mapping (address =&amp;gt; uint256) public balanceOf;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);
    event FundTransfer(address backer, uint amount, bool isContribution);
    
    
    /**
     * Constrctor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function ZazToken() public {
        totalSupply = zazSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;    // Give ZazToken Mint the total created tokens
        creator = msg.sender;
    }
    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] &amp;gt;= _value);
        // Check for overflows
        require(balanceOf[_to] + _value &amp;gt;= balanceOf[_to]);
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
      
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    
    /// @notice Buy tokens from contract by sending ether
    function () payable internal {
        
        if (price &amp;gt;= 0 ether &amp;amp;&amp;amp; price &amp;lt; 0.005 ether){
        uint ammount = 500;                  // calculates the amount, made it so you can get many ZazMinth but to get MANY ZazToken you have to spend ETH and not WEI
        uint ammountRaised;                                     
        amountRaised += msg.value;                            //many thanks Zaz, couldnt do it without r/me_irl
        require(balanceOf[creator] &amp;gt;= ammount);               // checks if it has enough to sell
        require(msg.value &amp;lt; 0.1 ether);                        // so any person who wants to put more then 0.1 ETH has time to think about what they are doing
        balanceOf[msg.sender] += ammount;                  // adds the amount to buyer&amp;#39;s balance
        balanceOf[creator] -= ammount;                        // sends ETH to ZazMinth
        Transfer(creator, msg.sender, ammount);               // execute an event reflecting the change
        creator.transfer(ammountRaised);
        }
        if (price &amp;gt;= 0.005 ether &amp;amp;&amp;amp; price &amp;lt; 0.03 ether){
        uint amount = 2000;                  // calculates the amount, made it so you can get many ZazToken but to get MANY ZazToken you have to spend ETH and not WEI
        uint amountRaised;                                     
        amountRaised += msg.value;                            //many thanks zaz, couldnt do it without r/me_irl
        require(balanceOf[creator] &amp;gt;= amount);               // checks if it has enough to sell
        require(msg.value &amp;lt; 0.1 ether);                        // so any person who wants to put more then 0.1 ETH has time to think about what they are doing
        balanceOf[msg.sender] += amount;                  // adds the amount to buyer&amp;#39;s balance
        balanceOf[creator] -= amount;                        // sends ETH to ZazMinth
        Transfer(creator, msg.sender, amount);               // execute an event reflecting the change
        creator.transfer(amountRaised);
        }
         if (price &amp;gt;= 0.03 ether){
        uint amnount = 10000;                  // calculates the amount, made it so you can get many ZazToken but to get MANY  you have to spend ETH and not WEI
        uint amnountRaised;                                     
        amountRaised += msg.value;                            //many thanks Zaz, couldnt do it without r/me_irl
        require(balanceOf[creator] &amp;gt;= amnount);               // checks if it has enough to sell
        require(msg.value &amp;lt; 0.1 ether);                        // so any person who wants to put more then 0.1 ETH has time to think about what they are doing
        balanceOf[msg.sender] += amnount;                  // adds the amount to buyer&amp;#39;s balance
        balanceOf[creator] -= amnount;                        // sends ETH to ZazMinth
        Transfer(creator, msg.sender, amnount);               // execute an event reflecting the change
        creator.transfer(amnountRaised);
        }
    }

 }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xe0670e32c120813a54860442155659cfa029d343.sol" target="_blank" title="show github file">0xe0670e32c120813a54860442155659cfa029d343.sol</a>
        </div>
        <div class="path">solidity-files/0xe0670e32c120813a54860442155659cfa029d343.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity 0.4.19;

// File: contracts/NokuPricingPlan.sol

/**
* @dev The NokuPricingPlan contract defines the responsibilities of a Noku pricing plan.
*/
interface NokuPricingPlan {
    /**
    * @dev Pay the fee for the service identified by the specified name.
    * The fee amount shall already be approved by the client.
    * @param serviceName The name of the target service.
    * @param multiplier The multiplier of the base service fee to apply.
    * @param client The client of the target service.
    * @return true if fee has been paid.
    */
    function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);

    /**
    * @dev Get the usage fee for the service identified by the specified name.
    * The returned fee amount shall be approved before using #payFee method.
    * @param serviceName The name of the target service.
    * @param multiplier The multiplier of the base service fee to apply.
    * @return The amount to approve before really paying such fee.
    */
    function usageFee(bytes32 serviceName, uint256 multiplier) public constant returns(uint fee);
}

// File: zeppelin-solidity/contracts/ownership/Ownable.sol

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol

/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  /**
   * @dev Modifier to make a function callable only when the contract is paused.
   */
  modifier whenPaused() {
    require(paused);
    _;
  }

  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
    paused = false;
    Unpause();
  }
}

// File: zeppelin-solidity/contracts/math/SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol

/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: contracts/NokuTokenBurner.sol

contract BurnableERC20 is ERC20 {
    function burn(uint256 amount) public returns (bool burned);
}

/**
* @dev The NokuTokenBurner contract has the responsibility to burn the configured fraction of received
* ERC20-compliant tokens and distribute the remainder to the configured wallet.
*/
contract NokuTokenBurner is Pausable {
    using SafeMath for uint256;

    event LogNokuTokenBurnerCreated(address indexed caller, address indexed wallet);
    event LogBurningPercentageChanged(address indexed caller, uint256 indexed burningPercentage);

    // The wallet receiving the unburnt tokens.
    address public wallet;

    // The percentage of tokens to burn after being received (range [0, 100])
    uint256 public burningPercentage;

    // The cumulative amount of burnt tokens.
    uint256 public burnedTokens;

    // The cumulative amount of tokens transferred back to the wallet.
    uint256 public transferredTokens;

    /**
    * @dev Create a new NokuTokenBurner with predefined burning fraction.
    * @param _wallet The wallet receiving the unburnt tokens.
    */
    function NokuTokenBurner(address _wallet) public {
        require(_wallet != address(0));
        
        wallet = _wallet;
        burningPercentage = 100;

        LogNokuTokenBurnerCreated(msg.sender, _wallet);
    }

    /**
    * @dev Change the percentage of tokens to burn after being received.
    * @param _burningPercentage The percentage of tokens to be burnt.
    */
    function setBurningPercentage(uint256 _burningPercentage) public onlyOwner {
        require(0 &amp;lt;= _burningPercentage &amp;amp;&amp;amp; _burningPercentage &amp;lt;= 100);
        require(_burningPercentage != burningPercentage);
        
        burningPercentage = _burningPercentage;

        LogBurningPercentageChanged(msg.sender, _burningPercentage);
    }

    /**
    * @dev Called after burnable tokens has been transferred for burning.
    * @param _token THe extended ERC20 interface supported by the sent tokens.
    * @param _amount The amount of burnable tokens just arrived ready for burning.
    */
    function tokenReceived(address _token, uint256 _amount) public whenNotPaused {
        require(_token != address(0));
        require(_amount &amp;gt; 0);

        uint256 amountToBurn = _amount.mul(burningPercentage).div(100);
        if (amountToBurn &amp;gt; 0) {
            assert(BurnableERC20(_token).burn(amountToBurn));
            
            burnedTokens = burnedTokens.add(amountToBurn);
        }

        uint256 amountToTransfer = _amount.sub(amountToBurn);
        if (amountToTransfer &amp;gt; 0) {
            assert(BurnableERC20(_token).transfer(wallet, amountToTransfer));

            transferredTokens = transferredTokens.add(amountToTransfer);
        }
    }
}

// File: contracts/NokuConsumptionPlan.sol

/**
* @dev The NokuConsumptionPlan contract implements a flexible pricing plan, manageable by the contract owner, which can be:
* - extended by inserting a new service with its associated fee
* - modified by updating an existing service fee
* - reduced by removing an existing service with its associated fee
* - queried to obtain the count of services
* The service [name, fee] association is maintained using an index in order to make the data traversable.
*/
contract NokuConsumptionPlan is NokuPricingPlan, Ownable {
    using SafeMath for uint256;

    event LogNokuConsumptionPlanCreated(address indexed caller, address indexed nokuMasterToken, address indexed tokenBurner);
    event LogServiceAdded(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee);
    event LogServiceChanged(bytes32 indexed serviceName, uint indexed index, uint indexed serviceFee);
    event LogServiceRemoved(bytes32 indexed serviceName, uint indexed index);
    
    struct NokuService {
        uint serviceFee;
        uint index;
    }

    bytes32[] private serviceIndex;

    mapping(bytes32 =&amp;gt; NokuService) private services;

    // The NOKU utility token used for paying fee  
    address public nokuMasterToken;

    // The contract responsible for burning the NOKU tokens paid as service fee
    address public tokenBurner;

    function NokuConsumptionPlan(address _nokuMasterToken, address _tokenBurner) public {
        require(_nokuMasterToken != 0);
        require(_tokenBurner != 0);

        nokuMasterToken = _nokuMasterToken;
        tokenBurner = _tokenBurner;

        LogNokuConsumptionPlanCreated(msg.sender, _nokuMasterToken, _tokenBurner);
    }

    function isService(bytes32 _serviceName) public constant returns(bool isIndeed) {
        require(_serviceName != 0);

        if (serviceIndex.length == 0)
            return false;
        else
            return (serviceIndex[services[_serviceName].index] == _serviceName);
    }

    function addService(bytes32 _serviceName, uint _serviceFee) public onlyOwner returns(uint index) {
        require(!isService(_serviceName));
        
        services[_serviceName].serviceFee = _serviceFee;
        services[_serviceName].index = serviceIndex.push(_serviceName)-1;

        LogServiceAdded(_serviceName, serviceIndex.length-1, _serviceFee);

        return serviceIndex.length-1;
    }

    function removeService(bytes32 _serviceName) public onlyOwner returns(uint index) {
        require(isService(_serviceName));

        uint rowToDelete = services[_serviceName].index;
        bytes32 keyToMove = serviceIndex[serviceIndex.length-1];
        serviceIndex[rowToDelete] = keyToMove;
        services[keyToMove].index = rowToDelete; 
        serviceIndex.length--;

        LogServiceRemoved(_serviceName,  rowToDelete);
        LogServiceChanged(keyToMove, rowToDelete, services[keyToMove].serviceFee);

        return rowToDelete;
    }

    function updateServiceFee(bytes32 _serviceName, uint _serviceFee) public onlyOwner returns(bool success) {
        require(isService(_serviceName));

        services[_serviceName].serviceFee = _serviceFee;

        LogServiceChanged(_serviceName, services[_serviceName].index, _serviceFee);

        return true;
    }

    function payFee(bytes32 _serviceName, uint256 _amount, address _client) public returns(bool paid) {
        //require(isService(_serviceName)); // Already checked by #usageFee
        //require(_amount != 0); // Already checked by #usageFee
        require(_client != 0);

        uint256 fee = usageFee(_serviceName, _amount);

        assert(ERC20(nokuMasterToken).transferFrom(_client, tokenBurner, fee));

        NokuTokenBurner(tokenBurner).tokenReceived(nokuMasterToken, fee);

        return true;
    }

    function usageFee(bytes32 _serviceName, uint256 _amount) public constant returns(uint fee) {
        require(isService(_serviceName));
        require(_amount != 0);
        
        // Assume fee are represented in 18-decimals notation
        return _amount.mul(services[_serviceName].serviceFee).div(10**18);
    }

    function serviceCount() public constant returns(uint count) {
        return serviceIndex.length;
    }

    function serviceAtIndex(uint _index) public constant returns(bytes32 serviceName) {
        return serviceIndex[_index];
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x6ea3c9cf7b462a67069a5dcfb4c3d7cb6f694917.sol" target="_blank" title="show github file">0x6ea3c9cf7b462a67069a5dcfb4c3d7cb6f694917.sol</a>
        </div>
        <div class="path">solidity-files/0x6ea3c9cf7b462a67069a5dcfb4c3d7cb6f694917.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT107368&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT107368
    // Name        : ADZbuzz Makemoney123.org Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT107368&amp;quot;;
            name = &amp;quot;ADZbuzz Makemoney123.org Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xe344757aea83ac838f22e757991489993e5d3760.sol" target="_blank" title="show github file">0xe344757aea83ac838f22e757991489993e5d3760.sol</a>
        </div>
        <div class="path">solidity-files/0xe344757aea83ac838f22e757991489993e5d3760.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

// File: contracts/BdpBaseData.sol

contract BdpBaseData {

	address public ownerAddress;

	address public managerAddress;

	address[16] public contracts;

	bool public paused = false;

	bool public setupCompleted = false;

	bytes8 public version;

}

// File: contracts/libraries/BdpContracts.sol

library BdpContracts {

	function getBdpEntryPoint(address[16] _contracts) pure internal returns (address) {
		return _contracts[0];
	}

	function getBdpController(address[16] _contracts) pure internal returns (address) {
		return _contracts[1];
	}

	function getBdpControllerHelper(address[16] _contracts) pure internal returns (address) {
		return _contracts[3];
	}

	function getBdpDataStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[4];
	}

	function getBdpImageStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[5];
	}

	function getBdpOwnershipStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[6];
	}

	function getBdpPriceStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[7];
	}

}

// File: contracts/BdpBase.sol

contract BdpBase is BdpBaseData {

	modifier onlyOwner() {
		require(msg.sender == ownerAddress);
		_;
	}

	modifier onlyAuthorized() {
		require(msg.sender == ownerAddress || msg.sender == managerAddress);
		_;
	}

	modifier whileContractIsActive() {
		require(!paused &amp;amp;&amp;amp; setupCompleted);
		_;
	}

	modifier storageAccessControl() {
		require(
			(! setupCompleted &amp;amp;&amp;amp; (msg.sender == ownerAddress || msg.sender == managerAddress))
			|| (setupCompleted &amp;amp;&amp;amp; !paused &amp;amp;&amp;amp; (msg.sender == BdpContracts.getBdpEntryPoint(contracts)))
		);
		_;
	}

	function setOwner(address _newOwner) external onlyOwner {
		require(_newOwner != address(0));
		ownerAddress = _newOwner;
	}

	function setManager(address _newManager) external onlyOwner {
		require(_newManager != address(0));
		managerAddress = _newManager;
	}

	function setContracts(address[16] _contracts) external onlyOwner {
		contracts = _contracts;
	}

	function pause() external onlyAuthorized {
		paused = true;
	}

	function unpause() external onlyOwner {
		paused = false;
	}

	function setSetupCompleted() external onlyOwner {
		setupCompleted = true;
	}

	function kill() public onlyOwner {
		selfdestruct(ownerAddress);
	}

}

// File: contracts/libraries/SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

	/**
	* @dev Multiplies two numbers, throws on overflow.
	*/
	function mul(uint256 a, uint256 b) internal pure returns (uint256) {
		if (a == 0) {
			return 0;
		}
		uint256 c = a * b;
		assert(c / a == b);
		return c;
	}

	/**
	* @dev Integer division of two numbers, truncating the quotient.
	*/
	function div(uint256 a, uint256 b) internal pure returns (uint256) {
		// assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
		uint256 c = a / b;
		// assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
		return c;
	}

	/**
	* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
	*/
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
		assert(b &amp;lt;= a);
		return a - b;
	}

	/**
	* @dev Adds two numbers, throws on overflow.
	*/
	function add(uint256 a, uint256 b) internal pure returns (uint256) {
		uint256 c = a + b;
		assert(c &amp;gt;= a);
		return c;
	}
}

// File: contracts/storage/BdpDataStorage.sol

contract BdpDataStorage is BdpBase {

	using SafeMath for uint256;

	struct Region {
		uint256 x1;
		uint256 y1;
		uint256 x2;
		uint256 y2;
		uint256 currentImageId;
		uint256 nextImageId;
		uint8[128] url;
		uint256 currentPixelPrice;
		uint256 blockUpdatedAt;
		uint256 updatedAt;
		uint256 purchasedAt;
		uint256 purchasedPixelPrice;
	}

	uint256 public lastRegionId = 0;

	mapping (uint256 =&amp;gt; Region) public data;


	function getLastRegionId() view public returns (uint256) {
		return lastRegionId;
	}

	function getNextRegionId() public storageAccessControl returns (uint256) {
		lastRegionId = lastRegionId.add(1);
		return lastRegionId;
	}

	function deleteRegionData(uint256 _id) public storageAccessControl {
		delete data[_id];
	}

	function getRegionCoordinates(uint256 _id) view public returns (uint256, uint256, uint256, uint256) {
		return (data[_id].x1, data[_id].y1, data[_id].x2, data[_id].y2);
	}

	function setRegionCoordinates(uint256 _id, uint256 _x1, uint256 _y1, uint256 _x2, uint256 _y2) public storageAccessControl {
		data[_id].x1 = _x1;
		data[_id].y1 = _y1;
		data[_id].x2 = _x2;
		data[_id].y2 = _y2;
	}

	function getRegionCurrentImageId(uint256 _id) view public returns (uint256) {
		return data[_id].currentImageId;
	}

	function setRegionCurrentImageId(uint256 _id, uint256 _currentImageId) public storageAccessControl {
		data[_id].currentImageId = _currentImageId;
	}

	function getRegionNextImageId(uint256 _id) view public returns (uint256) {
		return data[_id].nextImageId;
	}

	function setRegionNextImageId(uint256 _id, uint256 _nextImageId) public storageAccessControl {
		data[_id].nextImageId = _nextImageId;
	}

	function getRegionUrl(uint256 _id) view public returns (uint8[128]) {
		return data[_id].url;
	}

	function setRegionUrl(uint256 _id, uint8[128] _url) public storageAccessControl {
		data[_id].url = _url;
	}

	function getRegionCurrentPixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].currentPixelPrice;
	}

	function setRegionCurrentPixelPrice(uint256 _id, uint256 _currentPixelPrice) public storageAccessControl {
		data[_id].currentPixelPrice = _currentPixelPrice;
	}

	function getRegionBlockUpdatedAt(uint256 _id) view public returns (uint256) {
		return data[_id].blockUpdatedAt;
	}

	function setRegionBlockUpdatedAt(uint256 _id, uint256 _blockUpdatedAt) public storageAccessControl {
		data[_id].blockUpdatedAt = _blockUpdatedAt;
	}

	function getRegionUpdatedAt(uint256 _id) view public returns (uint256) {
		return data[_id].updatedAt;
	}

	function setRegionUpdatedAt(uint256 _id, uint256 _updatedAt) public storageAccessControl {
		data[_id].updatedAt = _updatedAt;
	}

	function getRegionPurchasedAt(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedAt;
	}

	function setRegionPurchasedAt(uint256 _id, uint256 _purchasedAt) public storageAccessControl {
		data[_id].purchasedAt = _purchasedAt;
	}

	function getRegionUpdatedAtPurchasedAt(uint256 _id) view public returns (uint256 _updatedAt, uint256 _purchasedAt) {
		return (data[_id].updatedAt, data[_id].purchasedAt);
	}

	function getRegionPurchasePixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedPixelPrice;
	}

	function setRegionPurchasedPixelPrice(uint256 _id, uint256 _purchasedPixelPrice) public storageAccessControl {
		data[_id].purchasedPixelPrice = _purchasedPixelPrice;
	}

	function BdpDataStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/storage/BdpImageStorage.sol

contract BdpImageStorage is BdpBase {

	using SafeMath for uint256;

	struct Image {
		address owner;
		uint256 regionId;
		uint256 currentRegionId;
		mapping(uint16 =&amp;gt; uint256[1000]) data;
		mapping(uint16 =&amp;gt; uint16) dataLength;
		uint16 partsCount;
		uint16 width;
		uint16 height;
		uint16 imageDescriptor;
		uint256 blurredAt;
	}

	uint256 public lastImageId = 0;

	mapping(uint256 =&amp;gt; Image) public images;


	function getLastImageId() view public returns (uint256) {
		return lastImageId;
	}

	function getNextImageId() public storageAccessControl returns (uint256) {
		lastImageId = lastImageId.add(1);
		return lastImageId;
	}

	function createImage(address _owner, uint256 _regionId, uint16 _width, uint16 _height, uint16 _partsCount, uint16 _imageDescriptor) public storageAccessControl returns (uint256) {
		require(_owner != address(0) &amp;amp;&amp;amp; _width &amp;gt; 0 &amp;amp;&amp;amp; _height &amp;gt; 0 &amp;amp;&amp;amp; _partsCount &amp;gt; 0 &amp;amp;&amp;amp; _imageDescriptor &amp;gt; 0);
		uint256 id = getNextImageId();
		images[id].owner = _owner;
		images[id].regionId = _regionId;
		images[id].width = _width;
		images[id].height = _height;
		images[id].partsCount = _partsCount;
		images[id].imageDescriptor = _imageDescriptor;
		return id;
	}

	function imageExists(uint256 _imageId) view public returns (bool) {
		return _imageId &amp;gt; 0 &amp;amp;&amp;amp; images[_imageId].owner != address(0);
	}

	function deleteImage(uint256 _imageId) public storageAccessControl {
		require(imageExists(_imageId));
		delete images[_imageId];
	}

	function getImageOwner(uint256 _imageId) public view returns (address) {
		require(imageExists(_imageId));
		return images[_imageId].owner;
	}

	function setImageOwner(uint256 _imageId, address _owner) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].owner = _owner;
	}

	function getImageRegionId(uint256 _imageId) public view returns (uint256) {
		require(imageExists(_imageId));
		return images[_imageId].regionId;
	}

	function setImageRegionId(uint256 _imageId, uint256 _regionId) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].regionId = _regionId;
	}

	function getImageCurrentRegionId(uint256 _imageId) public view returns (uint256) {
		require(imageExists(_imageId));
		return images[_imageId].currentRegionId;
	}

	function setImageCurrentRegionId(uint256 _imageId, uint256 _currentRegionId) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].currentRegionId = _currentRegionId;
	}

	function getImageData(uint256 _imageId, uint16 _part) view public returns (uint256[1000]) {
		require(imageExists(_imageId));
		return images[_imageId].data[_part];
	}

	function setImageData(uint256 _imageId, uint16 _part, uint256[] _data) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].dataLength[_part] = uint16(_data.length);
		for (uint256 i = 0; i &amp;lt; _data.length; i++) {
			images[_imageId].data[_part][i] = _data[i];
		}
	}

	function getImageDataLength(uint256 _imageId, uint16 _part) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].dataLength[_part];
	}

	function setImageDataLength(uint256 _imageId, uint16 _part, uint16 _dataLength) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].dataLength[_part] = _dataLength;
	}

	function getImagePartsCount(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].partsCount;
	}

	function setImagePartsCount(uint256 _imageId, uint16 _partsCount) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].partsCount = _partsCount;
	}

	function getImageWidth(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].width;
	}

	function setImageWidth(uint256 _imageId, uint16 _width) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].width = _width;
	}

	function getImageHeight(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].height;
	}

	function setImageHeight(uint256 _imageId, uint16 _height) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].height = _height;
	}

	function getImageDescriptor(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].imageDescriptor;
	}

	function setImageDescriptor(uint256 _imageId, uint16 _imageDescriptor) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].imageDescriptor = _imageDescriptor;
	}

	function getImageBlurredAt(uint256 _imageId) view public returns (uint256) {
		return images[_imageId].blurredAt;
	}

	function setImageBlurredAt(uint256 _imageId, uint256 _blurredAt) public storageAccessControl {
		images[_imageId].blurredAt = _blurredAt;
	}

	function imageUploadComplete(uint256 _imageId) view public returns (bool) {
		require(imageExists(_imageId));
		for (uint16 i = 1; i &amp;lt;= images[_imageId].partsCount; i++) {
			if(images[_imageId].data[i].length == 0) {
				return false;
			}
		}
		return true;
	}

	function BdpImageStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/storage/BdpPriceStorage.sol

contract BdpPriceStorage is BdpBase {

	uint64[1001] public pricePoints;

	uint256 public pricePointsLength = 0;

	address public forwardPurchaseFeesTo = address(0);

	address public forwardUpdateFeesTo = address(0);


	function getPricePointsLength() view public returns (uint256) {
		return pricePointsLength;
	}

	function getPricePoint(uint256 _i) view public returns (uint256) {
		return pricePoints[_i];
	}

	function setPricePoints(uint64[] _pricePoints) public storageAccessControl {
		pricePointsLength = 0;
		appendPricePoints(_pricePoints);
	}

	function appendPricePoints(uint64[] _pricePoints) public storageAccessControl {
		for (uint i = 0; i &amp;lt; _pricePoints.length; i++) {
			pricePoints[pricePointsLength++] = _pricePoints[i];
		}
	}

	function getForwardPurchaseFeesTo() view public returns (address) {
		return forwardPurchaseFeesTo;
	}

	function setForwardPurchaseFeesTo(address _forwardPurchaseFeesTo) public storageAccessControl {
		forwardPurchaseFeesTo = _forwardPurchaseFeesTo;
	}

	function getForwardUpdateFeesTo() view public returns (address) {
		return forwardUpdateFeesTo;
	}

	function setForwardUpdateFeesTo(address _forwardUpdateFeesTo) public storageAccessControl {
		forwardUpdateFeesTo = _forwardUpdateFeesTo;
	}

	function BdpPriceStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/libraries/BdpCalculator.sol

library BdpCalculator {

	using SafeMath for uint256;

	function calculateArea(address[16] _contracts, uint256 _regionId) view public returns (uint256 _area, uint256 _width, uint256 _height) {
		var (x1, y1, x2, y2) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCoordinates(_regionId);
		_width = x2 - x1 + 1;
		_height = y2 - y1 + 1;
		_area = _width * _height;
	}

	function countPurchasedPixels(address[16] _contracts) view public returns (uint256 _count) {
		var lastRegionId = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getLastRegionId();
		for (uint256 i = 0; i &amp;lt;= lastRegionId; i++) {
			if(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionPurchasedAt(i) &amp;gt; 0) { // region is purchased
				var (area,,) = calculateArea(_contracts, i);
				_count += area;
			}
		}
	}

	function calculateCurrentMarketPixelPrice(address[16] _contracts) view public returns(uint) {
		return calculateMarketPixelPrice(_contracts, countPurchasedPixels(_contracts));
	}

	function calculateMarketPixelPrice(address[16] _contracts, uint _pixelsSold) view public returns(uint) {
		var pricePointsLength = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePointsLength();
		uint mod = _pixelsSold % (1000000 / (pricePointsLength - 1));
		uint div = _pixelsSold * (pricePointsLength - 1) / 1000000;
		var divPoint = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div);
		if(mod == 0) return divPoint;
		return divPoint + mod * (BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div+1) - divPoint) * (pricePointsLength - 1) / 1000000;
	}

	function calculateAveragePixelPrice(address[16] _contracts, uint _a, uint _b) view public returns (uint _price) {
		_price = (calculateMarketPixelPrice(_contracts, _a) + calculateMarketPixelPrice(_contracts, _b)) / 2;
	}

	/** Current market price per pixel for this region if it is the first sale of this region
	  */
	function calculateRegionInitialSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		require(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAt(_regionId) &amp;gt; 0); // region exists
		var purchasedPixels = countPurchasedPixels(_contracts);
		var (area,,) = calculateArea(_contracts, _regionId);
		return calculateAveragePixelPrice(_contracts, purchasedPixels, purchasedPixels + area);
	}

	/** Current market price or (Current market price)*3 if the region was sold
	  */
	function calculateRegionSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		var pixelPrice = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCurrentPixelPrice(_regionId);
		if(pixelPrice &amp;gt; 0) {
			return pixelPrice * 3;
		} else {
			return calculateRegionInitialSalePixelPrice(_contracts, _regionId);
		}
	}

	/** Setup is allowed one whithin one day after purchase
	  */
	function calculateSetupAllowedUntil(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		var (updatedAt, purchasedAt) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAtPurchasedAt(_regionId);
		if(updatedAt != purchasedAt) {
			return 0;
		} else {
			return purchasedAt + 1 days;
		}
	}

}

// File: contracts/storage/BdpOwnershipStorage.sol

contract BdpOwnershipStorage is BdpBase {

	using SafeMath for uint256;

	// Mapping from token ID to owner
	mapping (uint256 =&amp;gt; address) public tokenOwner;

	// Mapping from token ID to approved address
	mapping (uint256 =&amp;gt; address) public tokenApprovals;

	// Mapping from owner to the sum of owned area
	mapping (address =&amp;gt; uint256) public ownedArea;

	// Mapping from owner to list of owned token IDs
	mapping (address =&amp;gt; uint256[]) public ownedTokens;

	// Mapping from token ID to index of the owner tokens list
	mapping(uint256 =&amp;gt; uint256) public ownedTokensIndex;

	// All tokens list tokens ids
	uint256[] public tokenIds;

	// Mapping from tokenId to index of the tokens list
	mapping (uint256 =&amp;gt; uint256) public tokenIdsIndex;


	function getTokenOwner(uint256 _tokenId) view public returns (address) {
		return tokenOwner[_tokenId];
	}

	function setTokenOwner(uint256 _tokenId, address _owner) public storageAccessControl {
		tokenOwner[_tokenId] = _owner;
	}

	function getTokenApproval(uint256 _tokenId) view public returns (address) {
		return tokenApprovals[_tokenId];
	}

	function setTokenApproval(uint256 _tokenId, address _to) public storageAccessControl {
		tokenApprovals[_tokenId] = _to;
	}

	function getOwnedArea(address _owner) view public returns (uint256) {
		return ownedArea[_owner];
	}

	function setOwnedArea(address _owner, uint256 _area) public storageAccessControl {
		ownedArea[_owner] = _area;
	}

	function incrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].add(_area);
		return ownedArea[_owner];
	}

	function decrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].sub(_area);
		return ownedArea[_owner];
	}

	function getOwnedTokensLength(address _owner) view public returns (uint256) {
		return ownedTokens[_owner].length;
	}

	function getOwnedToken(address _owner, uint256 _index) view public returns (uint256) {
		return ownedTokens[_owner][_index];
	}

	function setOwnedToken(address _owner, uint256 _index, uint256 _tokenId) public storageAccessControl {
		ownedTokens[_owner][_index] = _tokenId;
	}

	function pushOwnedToken(address _owner, uint256 _tokenId) public storageAccessControl returns (uint256) {
		ownedTokens[_owner].push(_tokenId);
		return ownedTokens[_owner].length;
	}

	function decrementOwnedTokensLength(address _owner) public storageAccessControl {
		ownedTokens[_owner].length--;
	}

	function getOwnedTokensIndex(uint256 _tokenId) view public returns (uint256) {
		return ownedTokensIndex[_tokenId];
	}

	function setOwnedTokensIndex(uint256 _tokenId, uint256 _tokenIndex) public storageAccessControl {
		ownedTokensIndex[_tokenId] = _tokenIndex;
	}

	function getTokenIdsLength() view public returns (uint256) {
		return tokenIds.length;
	}

	function getTokenIdByIndex(uint256 _index) view public returns (uint256) {
		return tokenIds[_index];
	}

	function setTokenIdByIndex(uint256 _index, uint256 _tokenId) public storageAccessControl {
		tokenIds[_index] = _tokenId;
	}

	function pushTokenId(uint256 _tokenId) public storageAccessControl returns (uint256) {
		tokenIds.push(_tokenId);
		return tokenIds.length;
	}

	function decrementTokenIdsLength() public storageAccessControl {
		tokenIds.length--;
	}

	function getTokenIdsIndex(uint256 _tokenId) view public returns (uint256) {
		return tokenIdsIndex[_tokenId];
	}

	function setTokenIdsIndex(uint256 _tokenId, uint256 _tokenIdIndex) public storageAccessControl {
		tokenIdsIndex[_tokenId] = _tokenIdIndex;
	}

	function BdpOwnershipStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/libraries/BdpOwnership.sol

/**
 * Ownership manager
 * Does not check if the caller is allowed to call functions
 * State changing methods are not intended to be called from controller
 */
library BdpOwnership {

	using SafeMath for uint256;

	event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

	event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

	function ownerOf(address[16] _contracts, uint256 _tokenId) public view returns (address) {
		var owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);
		require(owner != address(0));
		return owner;
	}

	function balanceOf(address[16] _contracts, address _owner) public view returns (uint256) {
		return BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getOwnedTokensLength(_owner);
	}

	function approve(address[16] _contracts, address _to, uint256 _tokenId) public {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		address owner = ownerOf(_contracts, _tokenId);
		require(_to != owner);
		if (ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0) {
			ownStorage.setTokenApproval(_tokenId, _to);
			Approval(owner, _to, _tokenId);
		}
	}

	/**
	 * @dev Clear current approval of a given token ID
	 * @param _tokenId uint256 ID of the token to be transferred
	 */
	function clearApproval(address[16] _contracts, address _owner, uint256 _tokenId) public {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownerOf(_contracts, _tokenId) == _owner);
		if (ownStorage.getTokenApproval(_tokenId) != 0) {
			BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).setTokenApproval(_tokenId, 0);
			Approval(_owner, 0, _tokenId);
		}
	}

	/**
	 * @dev Clear current approval and transfer the ownership of a given token ID
	 * @param _from address which you want to send tokens from
	 * @param _to address which you want to transfer the token to
	 * @param _tokenId uint256 ID of the token to be transferred
	 */
	function clearApprovalAndTransfer(address[16] _contracts, address _from, address _to, uint256 _tokenId) public {
		require(_to != address(0));
		require(_to != ownerOf(_contracts, _tokenId));
		require(ownerOf(_contracts, _tokenId) == _from);

		clearApproval(_contracts, _from, _tokenId);
		removeToken(_contracts, _from, _tokenId);
		addToken(_contracts, _to, _tokenId);
		Transfer(_from, _to, _tokenId);
	}

	/**
	 * @dev Internal function to add a token ID to the list of a given address
	 * @param _to address representing the new owner of the given token ID
	 * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address
	 */
	function addToken(address[16] _contracts, address _to, uint256 _tokenId) private {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownStorage.getTokenOwner(_tokenId) == address(0));

		// Set token owner
		ownStorage.setTokenOwner(_tokenId, _to);

		// Add token to tokenIds list
		var tokenIdsLength = ownStorage.pushTokenId(_tokenId);
		ownStorage.setTokenIdsIndex(_tokenId, tokenIdsLength.sub(1));

		uint256 ownedTokensLength = ownStorage.getOwnedTokensLength(_to);

		// Add token to ownedTokens list
		ownStorage.pushOwnedToken(_to, _tokenId);
		ownStorage.setOwnedTokensIndex(_tokenId, ownedTokensLength);

		// Increment total owned area
		var (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);
		ownStorage.incrementOwnedArea(_to, area);
	}

	/**
	 * @dev Internal function to remove a token ID from the list of a given address
	 * @param _from address representing the previous owner of the given token ID
	 * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address
	 */
	function removeToken(address[16] _contracts, address _from, uint256 _tokenId) private {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownerOf(_contracts, _tokenId) == _from);

		// Clear token owner
		ownStorage.setTokenOwner(_tokenId, 0);

		removeFromTokenIds(ownStorage, _tokenId);
		removeFromOwnedToken(ownStorage, _from, _tokenId);

		// Decrement total owned area
		var (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);
		ownStorage.decrementOwnedArea(_from, area);
	}

	/**
	 * @dev Remove token from ownedTokens list
	 * Note that this will handle single-element arrays. In that case, both ownedTokenIndex and lastOwnedTokenIndex are going to
	 * be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping
	 * the lastOwnedToken to the first position, and then dropping the element placed in the last position of the list
	 */
	function removeFromOwnedToken(BdpOwnershipStorage _ownStorage, address _from, uint256 _tokenId) private {
		var ownedTokenIndex = _ownStorage.getOwnedTokensIndex(_tokenId);
		var lastOwnedTokenIndex = _ownStorage.getOwnedTokensLength(_from).sub(1);
		var lastOwnedToken = _ownStorage.getOwnedToken(_from, lastOwnedTokenIndex);
		_ownStorage.setOwnedToken(_from, ownedTokenIndex, lastOwnedToken);
		_ownStorage.setOwnedToken(_from, lastOwnedTokenIndex, 0);
		_ownStorage.decrementOwnedTokensLength(_from);
		_ownStorage.setOwnedTokensIndex(_tokenId, 0);
		_ownStorage.setOwnedTokensIndex(lastOwnedToken, ownedTokenIndex);
	}

	/**
	 * @dev Remove token from tokenIds list
	 */
	function removeFromTokenIds(BdpOwnershipStorage _ownStorage, uint256 _tokenId) private {
		var tokenIndex = _ownStorage.getTokenIdsIndex(_tokenId);
		var lastTokenIdIndex = _ownStorage.getTokenIdsLength().sub(1);
		var lastTokenId = _ownStorage.getTokenIdByIndex(lastTokenIdIndex);
		_ownStorage.setTokenIdByIndex(tokenIndex, lastTokenId);
		_ownStorage.setTokenIdByIndex(lastTokenIdIndex, 0);
		_ownStorage.decrementTokenIdsLength();
		_ownStorage.setTokenIdsIndex(_tokenId, 0);
		_ownStorage.setTokenIdsIndex(lastTokenId, tokenIndex);
	}

	/**
	 * @dev Mint token function
	 * @param _to The address that will own the minted token
	 * @param _tokenId uint256 ID of the token to be minted by the msg.sender
	 */
	function mint(address[16] _contracts, address _to, uint256 _tokenId) public {
		require(_to != address(0));
		addToken(_contracts, _to, _tokenId);
		Transfer(address(0), _to, _tokenId);
	}

	/**
	 * @dev Burns a specific token
	 * @param _tokenId uint256 ID of the token being burned
	 */
	function burn(address[16] _contracts, uint256 _tokenId) public {
		address owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);
		clearApproval(_contracts, owner, _tokenId);
		removeToken(_contracts, owner, _tokenId);
		Transfer(owner, address(0), _tokenId);
	}

}

// File: contracts/libraries/BdpImage.sol

library BdpImage {

	function checkImageInput(address[16] _contracts, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, bool _clearImage) view public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));

		require( (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage) // Only one way to change image can be specified
			|| (_imageId != 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage) // If image has to be changed
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length != 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage)
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; _swapImages &amp;amp;&amp;amp; !_clearImage)
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; _clearImage) );

		require(_imageId == 0 || // Can use only own images not used by other regions
			( (msg.sender == imageStorage.getImageOwner(_imageId)) &amp;amp;&amp;amp; (imageStorage.getImageCurrentRegionId(_imageId) == 0) ) );

		var nextImageId = dataStorage.getRegionNextImageId(_regionId);
		require(!_swapImages || imageUploadComplete(_contracts, nextImageId)); // Can swap images if next image upload is complete
	}

	function setNextImagePart(address[16] _contracts, uint256 _regionId, uint16 _part, uint16 _partsCount, uint16 _imageDescriptor, uint256[] _imageData) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));

		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		require(_imageData.length != 0);
		require(_part &amp;gt; 0);
		require(_part &amp;lt;= _partsCount);

		var nextImageId = dataStorage.getRegionNextImageId(_regionId);
		if(nextImageId == 0 || _imageDescriptor != imageStorage.getImageDescriptor(nextImageId)) {
			var (, width, height) = BdpCalculator.calculateArea(_contracts, _regionId);
			nextImageId = imageStorage.createImage(msg.sender, _regionId, uint16(width), uint16(height), _partsCount, _imageDescriptor);
			dataStorage.setRegionNextImageId(_regionId, nextImageId);
		}

		imageStorage.setImageData(nextImageId, _part, _imageData);
	}

	function setImageOwner(address[16] _contracts, uint256 _imageId, address _owner) public {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		require(imageStorage.getImageOwner(_imageId) == msg.sender);
		require(_owner != address(0));

		imageStorage.setImageOwner(_imageId, _owner);
	}

	function setImageData(address[16] _contracts, uint256 _imageId, uint16 _part, uint256[] _imageData) public returns (address) {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		require(imageStorage.getImageOwner(_imageId) == msg.sender);
		require(imageStorage.getImageCurrentRegionId(_imageId) == 0);
		require(_imageData.length != 0);
		require(_part &amp;gt; 0);
		require(_part &amp;lt;= imageStorage.getImagePartsCount(_imageId));

		imageStorage.setImageData(_imageId, _part, _imageData);
	}

	function imageUploadComplete(address[16] _contracts, uint256 _imageId) view public returns (bool) {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		var partsCount = imageStorage.getImagePartsCount(_imageId);
		for (uint16 i = 1; i &amp;lt;= partsCount; i++) {
			if(imageStorage.getImageDataLength(_imageId, i) == 0) {
				return false;
			}
		}
		return true;
	}

}

// File: contracts/libraries/BdpCrud.sol

library BdpCrud {

	function createRegion(address[16] _contracts, address _to, uint256 _x1, uint256 _y1, uint256 _x2, uint256 _y2) public returns (uint256) {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		require(_x2 &amp;lt; 1000 &amp;amp;&amp;amp; _x1 &amp;lt;= _x2);
		require(_y2 &amp;lt; 1000 &amp;amp;&amp;amp; _y1 &amp;lt;= _y2);

		var regionId = dataStorage.getNextRegionId();
		dataStorage.setRegionCoordinates(regionId, _x1, _y1, _x2, _y2);
		dataStorage.setRegionBlockUpdatedAt(regionId, block.number);
		dataStorage.setRegionUpdatedAt(regionId, block.timestamp);

		BdpOwnership.mint(_contracts, _to, regionId);

		return regionId;
	}

	function deleteRegion(address[16] _contracts, uint256 _regionId) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		var regionPurchasePixelPrice = dataStorage.getRegionPurchasePixelPrice(_regionId);
		require(regionPurchasePixelPrice == 0);
		BdpOwnership.burn(_contracts, _regionId);
		dataStorage.deleteRegionData(_regionId);
	}

	function setupRegion(address[16] _contracts, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, uint8[128] _url) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		require(_imageId != 0 || _imageData.length != 0 || _swapImages || _url.length != 0); // Only if image or url is specified
		require(block.timestamp &amp;lt; BdpCalculator.calculateSetupAllowedUntil(_contracts, _regionId)); // Can only execute if setup is allowed
		BdpImage.checkImageInput(_contracts, _regionId, _imageId, _imageData, _swapImages, false);

		_updateRegionImage(_contracts, dataStorage, _regionId, _imageId, _imageData, _swapImages, false);
		_updateRegionUrl(dataStorage, _regionId, _url, false);

		dataStorage.setRegionBlockUpdatedAt(_regionId, block.number);
		dataStorage.setRegionUpdatedAt(_regionId, block.timestamp);
	}

	function updateRegion(address[16] _contracts, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, bool _clearImage, uint8[128] _url, bool _deleteUrl, address _newOwner) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		BdpImage.checkImageInput(_contracts, _regionId, _imageId, _imageData, _swapImages, _clearImage);
		var regionCurrentPixelPrice = dataStorage.getRegionCurrentPixelPrice(_regionId);
		require(regionCurrentPixelPrice != 0); // region was purchased

		var marketPixelPrice = BdpCalculator.calculateCurrentMarketPixelPrice(_contracts);

		var (area,,) = BdpCalculator.calculateArea(_contracts, _regionId);
		_processUpdateFee(_contracts, marketPixelPrice * area / 20);

		_updateRegionImage(_contracts, dataStorage, _regionId, _imageId, _imageData, _swapImages, _clearImage);
		_updateRegionUrl(dataStorage, _regionId, _url, _deleteUrl);
		_updateRegionOwner(_contracts, _regionId, _newOwner);
		if(marketPixelPrice &amp;gt; regionCurrentPixelPrice) {
			dataStorage.setRegionCurrentPixelPrice(_regionId, marketPixelPrice);
		}
		dataStorage.setRegionBlockUpdatedAt(_regionId, block.number);
		dataStorage.setRegionUpdatedAt(_regionId, block.timestamp);
	}

	function updateRegionPixelPrice(address[16] _contracts, uint256 _regionId, uint256 _pixelPrice) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		var regionCurrentPixelPrice = dataStorage.getRegionCurrentPixelPrice(_regionId);
		require(regionCurrentPixelPrice != 0); // region was purchased

		var marketPixelPrice = BdpCalculator.calculateCurrentMarketPixelPrice(_contracts);
		require(_pixelPrice &amp;gt;= marketPixelPrice);

		var (area,,) = BdpCalculator.calculateArea(_contracts, _regionId);
		_processUpdateFee(_contracts, _pixelPrice * area / 20);

		dataStorage.setRegionCurrentPixelPrice(_regionId, _pixelPrice);
	}

	function _processUpdateFee(address[16] _contracts, uint256 _updateFee) internal {
		require(msg.value &amp;gt;= _updateFee);

		if(msg.value &amp;gt; _updateFee) {
			var change = msg.value - _updateFee;
			msg.sender.transfer(change);
		}

		var forwardUpdateFeesTo = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getForwardUpdateFeesTo();
		if(forwardUpdateFeesTo != address(0)) {
			forwardUpdateFeesTo.transfer(_updateFee);
		}
	}

	function _updateRegionImage(address[16] _contracts, BdpDataStorage _dataStorage, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, bool _clearImage) internal {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		var currentImageId = _dataStorage.getRegionCurrentImageId(_regionId);
		if(_imageId != 0) {
			if(currentImageId != 0) {
				imageStorage.setImageCurrentRegionId(currentImageId, 0);
			}
			_dataStorage.setRegionCurrentImageId(_regionId, _imageId);
			imageStorage.setImageCurrentRegionId(_imageId, _regionId);
		}

		if(_imageData.length &amp;gt; 0) {
			if(currentImageId != 0) {
				imageStorage.setImageCurrentRegionId(currentImageId, 0);
			}
			var (, width, height) = BdpCalculator.calculateArea(_contracts, _regionId);
			var imageId = imageStorage.createImage(msg.sender, _regionId, uint16(width), uint16(height), 1, 1);
			imageStorage.setImageData(imageId, 1, _imageData);
			_dataStorage.setRegionCurrentImageId(_regionId, imageId);
			imageStorage.setImageCurrentRegionId(imageId, _regionId);
		}

		if(_swapImages) {
			if(currentImageId != 0) {
				imageStorage.setImageCurrentRegionId(currentImageId, 0);
			}
			var nextImageId = _dataStorage.getRegionNextImageId(_regionId);
			_dataStorage.setRegionCurrentImageId(_regionId, nextImageId);
			imageStorage.setImageCurrentRegionId(nextImageId, _regionId);
			_dataStorage.setRegionNextImageId(_regionId, 0);
		}

		if(_clearImage) {
			if(currentImageId != 0) {
				imageStorage.setImageCurrentRegionId(currentImageId, 0);
			}
			_dataStorage.setRegionCurrentImageId(_regionId, 0);
		}
	}

	function _updateRegionUrl(BdpDataStorage _dataStorage, uint256 _regionId, uint8[128] _url, bool _deleteUrl) internal {
		if(_url[0] != 0) {
			_dataStorage.setRegionUrl(_regionId, _url);
		}
		if(_deleteUrl) {
			uint8[128] memory emptyUrl;
			_dataStorage.setRegionUrl(_regionId, emptyUrl);
		}
	}

	function _updateRegionOwner(address[16] _contracts, uint256 _regionId, address _newOwner) internal {
		if(_newOwner != address(0)) {
			BdpOwnership.clearApprovalAndTransfer(_contracts, msg.sender, _newOwner, _regionId);
		}
	}

}

// File: contracts/libraries/BdpTransfer.sol

library BdpTransfer {

	using SafeMath for uint256;

	function approve(address[16] _contracts, address _to, uint256 _regionId) public {
		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		BdpOwnership.approve(_contracts, _to, _regionId);
	}

	function purchase(address[16] _contracts, uint256 _regionId) public {
		uint256 pixelPrice = BdpCalculator.calculateRegionSalePixelPrice(_contracts, _regionId);
		var (area,,) = BdpCalculator.calculateArea(_contracts, _regionId);
		uint256 regionPrice = pixelPrice * area;

		require(msg.value &amp;gt;= regionPrice );

		if(msg.value &amp;gt; regionPrice) {
			uint256 change = msg.value - regionPrice;
			msg.sender.transfer(change);
		}

		if(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCurrentPixelPrice(_regionId) &amp;gt; 0) { // send 95% ether to ownerOf(_regionId)
			uint256 etherToPreviousOwner = regionPrice * 19 / 20;
			BdpOwnership.ownerOf(_contracts, _regionId).transfer(etherToPreviousOwner);
			var forwardUpdateFeesTo = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getForwardUpdateFeesTo();
			if(forwardUpdateFeesTo != address(0)) {
				forwardUpdateFeesTo.transfer(regionPrice - etherToPreviousOwner);
			}
		} else {
			var forwardPurchaseFeesTo = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getForwardPurchaseFeesTo();
			if(forwardPurchaseFeesTo != address(0)) {
				forwardPurchaseFeesTo.transfer(regionPrice);
			}
		}

		BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionCurrentPixelPrice(_regionId, pixelPrice);
		BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionBlockUpdatedAt(_regionId, block.number);
		BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionUpdatedAt(_regionId, block.timestamp);
		BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedAt(_regionId, block.timestamp);
		BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedPixelPrice(_regionId, pixelPrice);

		BdpOwnership.clearApprovalAndTransfer(_contracts, BdpOwnership.ownerOf(_contracts, _regionId), msg.sender, _regionId);
	}

}

// File: contracts/controller/BdpController.sol

contract BdpController is BdpBase {

	function name() external pure returns (string) {
		return &amp;quot;CryptoPicture Block&amp;quot;;
	}

	function tokenURI(uint256 _tokenId) external view returns (string _tokenURI) {
		_tokenURI = &amp;quot;https://cryptopicture.com/#0000000&amp;quot;;
		bytes memory tokenURIBytes = bytes(_tokenURI);
		tokenURIBytes[27] = byte(48+(_tokenId / 1000000) % 10);
		tokenURIBytes[28] = byte(48+(_tokenId / 100000) % 10);
		tokenURIBytes[29] = byte(48+(_tokenId / 10000) % 10);
		tokenURIBytes[30] = byte(48+(_tokenId / 1000) % 10);
		tokenURIBytes[31] = byte(48+(_tokenId / 100) % 10);
		tokenURIBytes[32] = byte(48+(_tokenId / 10) % 10);
		tokenURIBytes[33] = byte(48+(_tokenId / 1) % 10);
	}


	// BdpCrud

	function createRegion(uint256 _x1, uint256 _y1, uint256 _x2, uint256 _y2) public onlyAuthorized returns (uint256) {
		BdpCrud.createRegion(contracts, ownerAddress, _x1, _y1, _x2, _y2);
	}

	function deleteRegion(uint256 _regionId) public onlyAuthorized returns (uint256) {
		BdpCrud.deleteRegion(contracts, _regionId);
	}

	function setupRegion(uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, uint8[128] _url) whileContractIsActive public {
		BdpCrud.setupRegion(contracts, _regionId, _imageId, _imageData, _swapImages, _url);
	}

	function updateRegion(uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, bool _clearImage, uint8[128] _url, bool _deleteUrl, address _newOwner) whileContractIsActive public payable {
		BdpCrud.updateRegion(contracts, _regionId, _imageId, _imageData, _swapImages, _clearImage, _url, _deleteUrl, _newOwner);
	}

	function updateRegionPixelPrice(uint256 _regionId, uint256 _pixelPrice) whileContractIsActive public payable {
		BdpCrud.updateRegionPixelPrice(contracts, _regionId, _pixelPrice);
	}


	// BdpImage

	function checkImageInput(uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, bool _clearImage) view public {
		BdpImage.checkImageInput(contracts, _regionId, _imageId, _imageData, _swapImages, _clearImage);
	}

	function setNextImagePart(uint256 _regionId, uint16 _part, uint16 _partsCount, uint16 _imageDescriptor, uint256[] _imageData) whileContractIsActive public {
		BdpImage.setNextImagePart(contracts, _regionId, _part, _partsCount, _imageDescriptor, _imageData);
	}


	// BdpOwnership

	function ownerOf(uint256 _tokenId) external view returns (address _owner) {
		return BdpOwnership.ownerOf(contracts, _tokenId);
	}

	function totalSupply() external view returns (uint256 _count) {
		return BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(contracts)).getTokenIdsLength();
	}

	function balanceOf(address _owner) external view returns (uint256 _count) {
		return BdpOwnership.balanceOf(contracts, _owner);
	}

	function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId) {
		return BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(contracts)).getOwnedToken(_owner, _index);
	}

	function tokenByIndex(uint256 _index) external view returns (uint256) {
		return BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(contracts)).getTokenIdByIndex(_index);
	}

	function getOwnedArea(address _owner) public view returns (uint256) {
		return BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(contracts)).getOwnedArea(_owner);
	}


	// BdpTransfer

	function purchase(uint256 _regionId) whileContractIsActive external payable {
		BdpTransfer.purchase(contracts, _regionId);
	}


	// Withdraw

	function withdrawBalance() external onlyOwner {
		ownerAddress.transfer(this.balance);
	}


	// BdpControllerHelper

	function () public {
		address _impl = BdpContracts.getBdpControllerHelper(contracts);
		require(_impl != address(0));
		bytes memory data = msg.data;

		assembly {
			let result := delegatecall(gas, _impl, add(data, 0x20), mload(data), 0, 0)
			let size := returndatasize
			let ptr := mload(0x40)
			returndatacopy(ptr, 0, size)
			switch result
			case 0 { revert(ptr, size) }
			default { return(ptr, size) }
		}
	}

	function BdpController(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x34b138ccf40413907fca0a30a6f465d7ade64ded.sol" target="_blank" title="show github file">0x34b138ccf40413907fca0a30a6f465d7ade64ded.sol</a>
        </div>
        <div class="path">solidity-files/0x34b138ccf40413907fca0a30a6f465d7ade64ded.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;ACT239008&amp;#39; token contract
//
// Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
// Symbol      : ACT239008
// Name        : ADZbuzz Avaaz.org Community Token
// Total supply: 2000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function ADZbuzzCommunityToken() public {
        symbol = &amp;quot;ACT239008&amp;quot;;
        name = &amp;quot;ADZbuzz Avaaz.org Community Token&amp;quot;;
        decimals = 8;
        _totalSupply = 200000000000000;
        balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
        emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x9b97eec77819f40a544d25116410d18d86650e93.sol" target="_blank" title="show github file">0x9b97eec77819f40a544d25116410d18d86650e93.sol</a>
        </div>
        <div class="path">solidity-files/0x9b97eec77819f40a544d25116410d18d86650e93.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT111204&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT111204
    // Name        : ADZbuzz Livegood.gq Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT111204&amp;quot;;
            name = &amp;quot;ADZbuzz Livegood.gq Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xb114ad08c67a80fd697f16499b14c7e1bc2913c7.sol" target="_blank" title="show github file">0xb114ad08c67a80fd697f16499b14c7e1bc2913c7.sol</a>
        </div>
        <div class="path">solidity-files/0xb114ad08c67a80fd697f16499b14c7e1bc2913c7.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.13;


contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

contract QYCC is ERC20,Ownable{
	using SafeMath for uint256;

	string public constant name=&amp;quot;qiyuan chain&amp;quot;;
	string public symbol=&amp;quot;QYCC&amp;quot;;
	string public constant version = &amp;quot;1.0&amp;quot;;
	uint256 public constant decimals = 18;
	uint256 public totalSupply;

	uint256 public constant MAX_SUPPLY=2100000000*10**decimals;

	
    mapping(address =&amp;gt; uint256) balances;
	mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;
	event GetETH(address indexed _from, uint256 _value);

	function QYCC(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}

	function () payable external
	{
		GetETH(msg.sender,msg.value);
	}

	function etherProceeds() external
		onlyOwner
	{
		if(!msg.sender.send(this.balance)) revert();
	}

  	function transfer(address _to, uint256 _value) public  returns (bool)
 	{
		require(_to != address(0));
		// SafeMath.sub will throw if there is not enough balance.
		balances[msg.sender] = balances[msg.sender].sub(_value);
		balances[_to] = balances[_to].add(_value);
		Transfer(msg.sender, _to, _value);
		return true;
  	}

  	function balanceOf(address _owner) public constant returns (uint256 balance) 
  	{
		return balances[_owner];
  	}

  	function transferFrom(address _from, address _to, uint256 _value) public returns (bool) 
  	{
		require(_to != address(0));
		uint256 _allowance = allowed[_from][msg.sender];

		balances[_from] = balances[_from].sub(_value);
		balances[_to] = balances[_to].add(_value);
		allowed[_from][msg.sender] = _allowance.sub(_value);
		Transfer(_from, _to, _value);
		return true;
  	}

  	function approve(address _spender, uint256 _value) public returns (bool) 
  	{
		allowed[msg.sender][_spender] = _value;
		Approval(msg.sender, _spender, _value);
		return true;
  	}

  	function allowance(address _owner, address _spender) public constant returns (uint256 remaining) 
  	{
		return allowed[_owner][_spender];
  	}

	  
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xb53a656bd0bbde2b272aa002a2f1a8d6137fce31.sol" target="_blank" title="show github file">0xb53a656bd0bbde2b272aa002a2f1a8d6137fce31.sol</a>
        </div>
        <div class="path">solidity-files/0xb53a656bd0bbde2b272aa002a2f1a8d6137fce31.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.2;
interface token {
   function transfer (address receiver, uint amount) public;
}
contract Crowdsale {
   address public beneficiary;
   uint public fundingGoal;
   uint public amountRaised;
   uint public currentBalance;
   uint public deadline;
   uint public bonusPhaseOneDeadline;
   uint public bonusPhaseTwoDeadline;
   uint public bonusPhaseThreeDeadline;
   uint public price;
   uint public phaseOneBonusPercent;
   uint public phaseTwoBonusPercent;
   uint public phaseThreeBonusPercent;
   uint public remainingTokens;
   token public tokenReward;
   mapping(address =&amp;gt; uint256) public balanceOf;
   bool public crowdsaleClosed = false;
   event GoalReached(address recipient, uint totalAmountRaised);
   event FundTransfer(address backer, uint amount, bool isContribution);
   function Crowdsale(
       address ifSuccessfulSendTo,
       uint fundingGoalInEthers,
       uint durationInMinutes,
       address addressOfTokenUsedAsReward,
       uint phaseOneDuration,
       uint phaseTwoDuration,
       uint phaseThreeDuration,
       uint additionalBonusTokens
   ) public {
       beneficiary = ifSuccessfulSendTo;
       fundingGoal = fundingGoalInEthers * 1 ether;
       deadline = now + durationInMinutes * 1 minutes;
       bonusPhaseOneDeadline = now + phaseOneDuration * 1 minutes;
       bonusPhaseTwoDeadline = now + phaseTwoDuration * 1 minutes;
       bonusPhaseThreeDeadline = now + phaseThreeDuration * 1 minutes;
       price = 0.0002 * 1 ether;
       tokenReward = token(addressOfTokenUsedAsReward);
       currentBalance = 0;
       remainingTokens = (5000 * fundingGoalInEthers * 10 ** uint256(8)) + (additionalBonusTokens * 10 ** uint256(8));
       phaseOneBonusPercent = 40;
       phaseTwoBonusPercent = 35;
       phaseThreeBonusPercent = 30;
   }
   function () public payable {
       require(!crowdsaleClosed);
       require(now &amp;lt; deadline);
       uint amount = msg.value;
       if (msg.sender != beneficiary) {
           require(msg.value &amp;gt;= 1 ether);
           amountRaised += amount;
           uint tokens = uint(amount * 10 ** uint256(8) / price);
           if (now &amp;lt; bonusPhaseOneDeadline) {
               tokens += ((phaseOneBonusPercent * tokens)/100 );
           } else if (now &amp;lt; bonusPhaseTwoDeadline) {
               tokens += ((phaseTwoBonusPercent * tokens)/100);
           } else if (now &amp;lt; bonusPhaseThreeDeadline) {
               tokens += ((phaseThreeBonusPercent * tokens)/100);
           }
           balanceOf[msg.sender] += tokens;
           remainingTokens -= tokens;
           tokenReward.transfer(msg.sender, tokens);
           FundTransfer(msg.sender, amount, true);
       }
       currentBalance += amount;
   }
   function checkGoalReached() public {
       require(beneficiary == msg.sender);
       crowdsaleClosed = true;
   }
   function safeWithdrawal(uint amountInWei) public {
       require(beneficiary == msg.sender);
       if (beneficiary.send(amountInWei)) {
           FundTransfer(beneficiary, amountInWei, false);
           currentBalance -= amountInWei;
       }
   }
   function withdrawUnsold() public {
       require(msg.sender == beneficiary);
       require(remainingTokens &amp;gt; 0);
       tokenReward.transfer(msg.sender, remainingTokens);
   }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x383be54c223dd41d5512ef5d69e6d07f45db42fe.sol" target="_blank" title="show github file">0x383be54c223dd41d5512ef5d69e6d07f45db42fe.sol</a>
        </div>
        <div class="path">solidity-files/0x383be54c223dd41d5512ef5d69e6d07f45db42fe.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;0HitCash&amp;#39; token contract
//
// Deployed to : 0xd37f5e615E9f21971E9fa2D56BcA3A44e49438EA
// Symbol      : 0HCH
// Name        : 0 Hit Cash
// Total supply: 1000000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract HitCash is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function HitCash() public {
        symbol = &amp;quot;0HCH&amp;quot;;
        name = &amp;quot;0 Hit Cash&amp;quot;;
        decimals = 8;
        _totalSupply = 100000000000000000;
        balances[0xd37f5e615E9f21971E9fa2D56BcA3A44e49438EA] = _totalSupply;
        Transfer(address(0), 0xd37f5e615E9f21971E9fa2D56BcA3A44e49438EA, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x43ca6017e714123a2780cc1d556b45d13a911a3f.sol" target="_blank" title="show github file">0x43ca6017e714123a2780cc1d556b45d13a911a3f.sol</a>
        </div>
        <div class="path">solidity-files/0x43ca6017e714123a2780cc1d556b45d13a911a3f.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }
  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }
  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}
/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;
  mapping(address =&amp;gt; uint256) balances;
  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
}
/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}
/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {
  mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;
  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    uint256 _allowance = allowed[_from][msg.sender];
    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value &amp;lt;= _allowance);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
  /**
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   */
  function increaseApproval (address _spender, uint _addedValue)
    returns (bool success) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
  function decreaseApproval (address _spender, uint _subtractedValue)
    returns (bool success) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue &amp;gt; oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
}


/**
 * @title Mintable token
 * @dev Simple ERC20 Token example, with mintable token creation
 * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
 */
contract MintableToken is StandardToken, Ownable {
  event Mint(address indexed to, uint256 amount);
  event MintFinished();
  bool public mintingFinished = false;
  modifier canMint() {
    require(!mintingFinished);
    _;
  }
  /**
   * @dev Function to mint tokens
   * @param _to The address that will receive the minted tokens.
   * @param _amount The amount of tokens to mint.
   * @return A boolean that indicates if the operation was successful.
   */
  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    Transfer(0x0, _to, _amount);
    return true;
  }
  /**
   * @dev Function to stop minting new tokens.
   * @return True if the operation was successful.
   */
  function finishMinting() onlyOwner public returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
}

contract Crowdsale {
  using SafeMath for uint256;

  // The token being sold
  ERC20 public token;

  // Address where funds are collected
  address public wallet;

  // How many token units a buyer gets per wei
  uint256 public rate;

  // Amount of wei raised
  uint256 public weiRaised;

  /**
   * Event for token purchase logging
   * @param purchaser who paid for the tokens
   * @param beneficiary who got the tokens
   * @param value weis paid for purchase
   * @param amount amount of tokens purchased
   */
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

  /**
   * @param _rate Number of token units a buyer gets per wei
   * @param _wallet Address where collected funds will be forwarded to
   * @param _token Address of the token being sold
   */
  function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate &amp;gt; 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = _rate;
    wallet = _wallet;
    token = _token;
  }

  // -----------------------------------------
  // Crowdsale external interface
  // -----------------------------------------

  /**
   * @dev fallback function ***DO NOT OVERRIDE***
   */
  function () external payable {
    buyTokens(msg.sender);
  }

  /**
   * @dev low level token purchase ***DO NOT OVERRIDE***
   * @param _beneficiary Address performing the token purchase
   */
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    // calculate token amount to be created
    uint256 tokens = _getTokenAmount(weiAmount);

    // update state
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  // -----------------------------------------
  // Internal interface (extensible)
  // -----------------------------------------

  /**
   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.
   * @param _beneficiary Address performing the token purchase
   * @param _weiAmount Value in wei involved in the purchase
   */
  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  /**
   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.
   * @param _beneficiary Address performing the token purchase
   * @param _weiAmount Value in wei involved in the purchase
   */
  function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
    // optional override
  }

  /**
   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.
   * @param _beneficiary Address performing the token purchase
   * @param _tokenAmount Number of tokens to be emitted
   */
  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
    token.transfer(_beneficiary, _tokenAmount);
  }

  /**
   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.
   * @param _beneficiary Address receiving the tokens
   * @param _tokenAmount Number of tokens to be purchased
   */
  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  /**
   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)
   * @param _beneficiary Address receiving the tokens
   * @param _weiAmount Value in wei involved in the purchase
   */
  function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {
    // optional override
  }

  /**
   * @dev Override to extend the way in which ether is converted to tokens.
   * @param _weiAmount Value in wei to be converted into tokens
   * @return Number of tokens that can be purchased with the specified _weiAmount
   */
  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
    return _weiAmount.mul(rate);
  }

  /**
   * @dev Determines how ETH is stored/forwarded on purchases.
   */
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}

contract TimedCrowdsale is Crowdsale {
  using SafeMath for uint256;

  uint256 public openingTime;
  uint256 public closingTime;

  /**
   * @dev Reverts if not in crowdsale time range. 
   */
  modifier onlyWhileOpen {
    require(now &amp;gt;= openingTime &amp;amp;&amp;amp; now &amp;lt;= closingTime);
    _;
  }

  /**
   * @dev Constructor, takes crowdsale opening and closing times.
   * @param _openingTime Crowdsale opening time
   * @param _closingTime Crowdsale closing time
   */
  function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {
    require(_openingTime &amp;gt;= now);
    require(_closingTime &amp;gt;= _openingTime);

    openingTime = _openingTime;
    closingTime = _closingTime;
  }

  /**
   * @dev Checks whether the period in which the crowdsale is open has already elapsed.
   * @return Whether crowdsale period has elapsed
   */
  function hasClosed() public view returns (bool) {
    return now &amp;gt; closingTime;
  }
  
  /**
   * @dev Extend parent behavior requiring to be within contributing period
   * @param _beneficiary Token purchaser
   * @param _weiAmount Amount of wei contributed
   */
  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen {
    super._preValidatePurchase(_beneficiary, _weiAmount);
  }

}

/**
 * @title IncreasingPriceCrowdsale
 * @dev Extension of Crowdsale contract that increases the price of tokens linearly in time. 
 * Note that what should be provided to the constructor is the initial and final _rates_, that is,
 * the amount of tokens per wei contributed. Thus, the initial rate must be greater than the final rate.
 */
contract IncreasingPriceCrowdsale is TimedCrowdsale {
  using SafeMath for uint256;

  uint256 public initialRate;
  uint256 public finalRate;

  /**
   * @dev Constructor, takes intial and final rates of tokens received per wei contributed.
   * @param _initialRate Number of tokens a buyer gets per wei at the start of the crowdsale
   * @param _finalRate Number of tokens a buyer gets per wei at the end of the crowdsale
   */
  function IncreasingPriceCrowdsale(uint256 _initialRate, uint256 _finalRate) public {
    require(_initialRate &amp;gt;= _finalRate);
    require(_finalRate &amp;gt; 0);
    initialRate = _initialRate;
    finalRate = _finalRate;
  }

  /**
   * @dev Returns the rate of tokens per wei at the present time. 
   * Note that, as price _increases_ with time, the rate _decreases_. 
   * @return The number of tokens a buyer gets per wei at a given time
   */
  function getCurrentRate() public view returns (uint256) {
    uint256 elapsedTime = now.sub(openingTime);
    uint256 timeRange = closingTime.sub(openingTime);
    uint256 rateRange = initialRate.sub(finalRate);
    return initialRate.sub(elapsedTime.mul(rateRange).div(timeRange));
  }

  /**
   * @dev Overrides parent method taking into account variable rate.
   * @param _weiAmount The value in wei to be converted into tokens
   * @return The number of tokens _weiAmount wei will buy at present time
   */
  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
    uint256 currentRate = getCurrentRate();
    return currentRate.mul(_weiAmount);
  }

}

/**
 * @title MintedCrowdsale
 * @dev Extension of Crowdsale contract whose tokens are minted in each purchase.
 * Token ownership should be transferred to MintedCrowdsale for minting. 
 */
contract MintedCrowdsale is Crowdsale {

  /**
   * @dev Overrides delivery by minting tokens upon purchase.
   * @param _beneficiary Token purchaser
   * @param _tokenAmount Number of tokens to be minted
   */
  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
    require(MintableToken(token).mint(_beneficiary, _tokenAmount));
  }
}

contract BigLuvCrowdsale is  TimedCrowdsale, MintedCrowdsale,Ownable {
 
  //decimal value
  uint256 public constant DECIMAL_FACTOR = 10 ** uint256(18);
  uint256 public publicAllocationTokens = 50000000*DECIMAL_FACTOR;

  
  function BigLuvCrowdsale(uint256 _starttime, uint256 _endTime, uint256 _rate, address _wallet,ERC20 _token)
  TimedCrowdsale(_starttime,_endTime)Crowdsale(_rate, _wallet,_token)
  {
  }
    
  /**
   * @dev fallback function ***DO NOT OVERRIDE***
   */
  function () external payable {
    buyTokens(msg.sender);
  }
  
  function buyTokens(address _beneficiary) public payable {
    require(_beneficiary != address(0));
  
    uint256 weiAmount = msg.value;
    // calculate token amount to be created
    uint256 tokens = weiAmount.mul(rate);
    // update state
    weiRaised = weiRaised.add(weiAmount);
    _processPurchase(_beneficiary, tokens);
    TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
    _forwardFunds();
  }
  
 /**
 * @dev Change TokenPrice
 * @param  _rate is TokenPrice
 */
  function changeRate(uint256 _rate) public onlyOwner {
    require(_rate != 0);
    rate = _rate;

}

 /**
 * @dev Change crowdsale OpeningTime 
 * @param  _startTime is Start time in Seconds
 */
  function changeStarttime(uint256 _startTime) public onlyOwner {
    require(_startTime != 0); 
    openingTime = _startTime;
    }
    
     /**
 * @dev Change crowdsale ClosingTime
 * @param  _endTime is End time in Seconds
 */
  function changeEndtime(uint256 _endTime) public onlyOwner {
    require(_endTime != 0); 
    closingTime = _endTime;
    }
 
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xda1e79b074a5500a763132c5bba56aadf564235f.sol" target="_blank" title="show github file">0xda1e79b074a5500a763132c5bba56aadf564235f.sol</a>
        </div>
        <div class="path">solidity-files/0xda1e79b074a5500a763132c5bba56aadf564235f.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

// File: contracts/BdpBaseData.sol

contract BdpBaseData {

	address public ownerAddress;

	address public managerAddress;

	address[16] public contracts;

	bool public paused = false;

	bool public setupCompleted = false;

	bytes8 public version;

}

// File: contracts/libraries/BdpContracts.sol

library BdpContracts {

	function getBdpEntryPoint(address[16] _contracts) pure internal returns (address) {
		return _contracts[0];
	}

	function getBdpController(address[16] _contracts) pure internal returns (address) {
		return _contracts[1];
	}

	function getBdpControllerHelper(address[16] _contracts) pure internal returns (address) {
		return _contracts[3];
	}

	function getBdpDataStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[4];
	}

	function getBdpImageStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[5];
	}

	function getBdpOwnershipStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[6];
	}

	function getBdpPriceStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[7];
	}

}

// File: contracts/BdpBase.sol

contract BdpBase is BdpBaseData {

	modifier onlyOwner() {
		require(msg.sender == ownerAddress);
		_;
	}

	modifier onlyAuthorized() {
		require(msg.sender == ownerAddress || msg.sender == managerAddress);
		_;
	}

	modifier whileContractIsActive() {
		require(!paused &amp;amp;&amp;amp; setupCompleted);
		_;
	}

	modifier storageAccessControl() {
		require(
			(! setupCompleted &amp;amp;&amp;amp; (msg.sender == ownerAddress || msg.sender == managerAddress))
			|| (setupCompleted &amp;amp;&amp;amp; !paused &amp;amp;&amp;amp; (msg.sender == BdpContracts.getBdpEntryPoint(contracts)))
		);
		_;
	}

	function setOwner(address _newOwner) external onlyOwner {
		require(_newOwner != address(0));
		ownerAddress = _newOwner;
	}

	function setManager(address _newManager) external onlyOwner {
		require(_newManager != address(0));
		managerAddress = _newManager;
	}

	function setContracts(address[16] _contracts) external onlyOwner {
		contracts = _contracts;
	}

	function pause() external onlyAuthorized {
		paused = true;
	}

	function unpause() external onlyOwner {
		paused = false;
	}

	function setSetupCompleted() external onlyOwner {
		setupCompleted = true;
	}

	function kill() public onlyOwner {
		selfdestruct(ownerAddress);
	}

}

// File: contracts/libraries/SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

	/**
	* @dev Multiplies two numbers, throws on overflow.
	*/
	function mul(uint256 a, uint256 b) internal pure returns (uint256) {
		if (a == 0) {
			return 0;
		}
		uint256 c = a * b;
		assert(c / a == b);
		return c;
	}

	/**
	* @dev Integer division of two numbers, truncating the quotient.
	*/
	function div(uint256 a, uint256 b) internal pure returns (uint256) {
		// assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
		uint256 c = a / b;
		// assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
		return c;
	}

	/**
	* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
	*/
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
		assert(b &amp;lt;= a);
		return a - b;
	}

	/**
	* @dev Adds two numbers, throws on overflow.
	*/
	function add(uint256 a, uint256 b) internal pure returns (uint256) {
		uint256 c = a + b;
		assert(c &amp;gt;= a);
		return c;
	}
}

// File: contracts/storage/BdpDataStorage.sol

contract BdpDataStorage is BdpBase {

	using SafeMath for uint256;

	struct Region {
		uint256 x1;
		uint256 y1;
		uint256 x2;
		uint256 y2;
		uint256 currentImageId;
		uint256 nextImageId;
		uint8[128] url;
		uint256 currentPixelPrice;
		uint256 blockUpdatedAt;
		uint256 updatedAt;
		uint256 purchasedAt;
		uint256 purchasedPixelPrice;
	}

	uint256 public lastRegionId = 0;

	mapping (uint256 =&amp;gt; Region) public data;


	function getLastRegionId() view public returns (uint256) {
		return lastRegionId;
	}

	function getNextRegionId() public storageAccessControl returns (uint256) {
		lastRegionId = lastRegionId.add(1);
		return lastRegionId;
	}

	function deleteRegionData(uint256 _id) public storageAccessControl {
		delete data[_id];
	}

	function getRegionCoordinates(uint256 _id) view public returns (uint256, uint256, uint256, uint256) {
		return (data[_id].x1, data[_id].y1, data[_id].x2, data[_id].y2);
	}

	function setRegionCoordinates(uint256 _id, uint256 _x1, uint256 _y1, uint256 _x2, uint256 _y2) public storageAccessControl {
		data[_id].x1 = _x1;
		data[_id].y1 = _y1;
		data[_id].x2 = _x2;
		data[_id].y2 = _y2;
	}

	function getRegionCurrentImageId(uint256 _id) view public returns (uint256) {
		return data[_id].currentImageId;
	}

	function setRegionCurrentImageId(uint256 _id, uint256 _currentImageId) public storageAccessControl {
		data[_id].currentImageId = _currentImageId;
	}

	function getRegionNextImageId(uint256 _id) view public returns (uint256) {
		return data[_id].nextImageId;
	}

	function setRegionNextImageId(uint256 _id, uint256 _nextImageId) public storageAccessControl {
		data[_id].nextImageId = _nextImageId;
	}

	function getRegionUrl(uint256 _id) view public returns (uint8[128]) {
		return data[_id].url;
	}

	function setRegionUrl(uint256 _id, uint8[128] _url) public storageAccessControl {
		data[_id].url = _url;
	}

	function getRegionCurrentPixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].currentPixelPrice;
	}

	function setRegionCurrentPixelPrice(uint256 _id, uint256 _currentPixelPrice) public storageAccessControl {
		data[_id].currentPixelPrice = _currentPixelPrice;
	}

	function getRegionBlockUpdatedAt(uint256 _id) view public returns (uint256) {
		return data[_id].blockUpdatedAt;
	}

	function setRegionBlockUpdatedAt(uint256 _id, uint256 _blockUpdatedAt) public storageAccessControl {
		data[_id].blockUpdatedAt = _blockUpdatedAt;
	}

	function getRegionUpdatedAt(uint256 _id) view public returns (uint256) {
		return data[_id].updatedAt;
	}

	function setRegionUpdatedAt(uint256 _id, uint256 _updatedAt) public storageAccessControl {
		data[_id].updatedAt = _updatedAt;
	}

	function getRegionPurchasedAt(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedAt;
	}

	function setRegionPurchasedAt(uint256 _id, uint256 _purchasedAt) public storageAccessControl {
		data[_id].purchasedAt = _purchasedAt;
	}

	function getRegionUpdatedAtPurchasedAt(uint256 _id) view public returns (uint256 _updatedAt, uint256 _purchasedAt) {
		return (data[_id].updatedAt, data[_id].purchasedAt);
	}

	function getRegionPurchasePixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedPixelPrice;
	}

	function setRegionPurchasedPixelPrice(uint256 _id, uint256 _purchasedPixelPrice) public storageAccessControl {
		data[_id].purchasedPixelPrice = _purchasedPixelPrice;
	}

	function BdpDataStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/storage/BdpPriceStorage.sol

contract BdpPriceStorage is BdpBase {

	uint64[1001] public pricePoints;

	uint256 public pricePointsLength = 0;

	address public forwardPurchaseFeesTo = address(0);

	address public forwardUpdateFeesTo = address(0);


	function getPricePointsLength() view public returns (uint256) {
		return pricePointsLength;
	}

	function getPricePoint(uint256 _i) view public returns (uint256) {
		return pricePoints[_i];
	}

	function setPricePoints(uint64[] _pricePoints) public storageAccessControl {
		pricePointsLength = 0;
		appendPricePoints(_pricePoints);
	}

	function appendPricePoints(uint64[] _pricePoints) public storageAccessControl {
		for (uint i = 0; i &amp;lt; _pricePoints.length; i++) {
			pricePoints[pricePointsLength++] = _pricePoints[i];
		}
	}

	function getForwardPurchaseFeesTo() view public returns (address) {
		return forwardPurchaseFeesTo;
	}

	function setForwardPurchaseFeesTo(address _forwardPurchaseFeesTo) public storageAccessControl {
		forwardPurchaseFeesTo = _forwardPurchaseFeesTo;
	}

	function getForwardUpdateFeesTo() view public returns (address) {
		return forwardUpdateFeesTo;
	}

	function setForwardUpdateFeesTo(address _forwardUpdateFeesTo) public storageAccessControl {
		forwardUpdateFeesTo = _forwardUpdateFeesTo;
	}

	function BdpPriceStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/libraries/BdpCalculator.sol

library BdpCalculator {

	using SafeMath for uint256;

	function calculateArea(address[16] _contracts, uint256 _regionId) view public returns (uint256 _area, uint256 _width, uint256 _height) {
		var (x1, y1, x2, y2) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCoordinates(_regionId);
		_width = x2 - x1 + 1;
		_height = y2 - y1 + 1;
		_area = _width * _height;
	}

	function countPurchasedPixels(address[16] _contracts) view public returns (uint256 _count) {
		var lastRegionId = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getLastRegionId();
		for (uint256 i = 0; i &amp;lt;= lastRegionId; i++) {
			if(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionPurchasedAt(i) &amp;gt; 0) { // region is purchased
				var (area,,) = calculateArea(_contracts, i);
				_count += area;
			}
		}
	}

	function calculateCurrentMarketPixelPrice(address[16] _contracts) view public returns(uint) {
		return calculateMarketPixelPrice(_contracts, countPurchasedPixels(_contracts));
	}

	function calculateMarketPixelPrice(address[16] _contracts, uint _pixelsSold) view public returns(uint) {
		var pricePointsLength = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePointsLength();
		uint mod = _pixelsSold % (1000000 / (pricePointsLength - 1));
		uint div = _pixelsSold * (pricePointsLength - 1) / 1000000;
		var divPoint = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div);
		if(mod == 0) return divPoint;
		return divPoint + mod * (BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div+1) - divPoint) * (pricePointsLength - 1) / 1000000;
	}

	function calculateAveragePixelPrice(address[16] _contracts, uint _a, uint _b) view public returns (uint _price) {
		_price = (calculateMarketPixelPrice(_contracts, _a) + calculateMarketPixelPrice(_contracts, _b)) / 2;
	}

	/** Current market price per pixel for this region if it is the first sale of this region
	  */
	function calculateRegionInitialSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		require(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAt(_regionId) &amp;gt; 0); // region exists
		var purchasedPixels = countPurchasedPixels(_contracts);
		var (area,,) = calculateArea(_contracts, _regionId);
		return calculateAveragePixelPrice(_contracts, purchasedPixels, purchasedPixels + area);
	}

	/** Current market price or (Current market price)*3 if the region was sold
	  */
	function calculateRegionSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		var pixelPrice = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCurrentPixelPrice(_regionId);
		if(pixelPrice &amp;gt; 0) {
			return pixelPrice * 3;
		} else {
			return calculateRegionInitialSalePixelPrice(_contracts, _regionId);
		}
	}

	/** Setup is allowed one whithin one day after purchase
	  */
	function calculateSetupAllowedUntil(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		var (updatedAt, purchasedAt) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAtPurchasedAt(_regionId);
		if(updatedAt != purchasedAt) {
			return 0;
		} else {
			return purchasedAt + 1 days;
		}
	}

}

// File: contracts/storage/BdpOwnershipStorage.sol

contract BdpOwnershipStorage is BdpBase {

	using SafeMath for uint256;

	// Mapping from token ID to owner
	mapping (uint256 =&amp;gt; address) public tokenOwner;

	// Mapping from token ID to approved address
	mapping (uint256 =&amp;gt; address) public tokenApprovals;

	// Mapping from owner to the sum of owned area
	mapping (address =&amp;gt; uint256) public ownedArea;

	// Mapping from owner to list of owned token IDs
	mapping (address =&amp;gt; uint256[]) public ownedTokens;

	// Mapping from token ID to index of the owner tokens list
	mapping(uint256 =&amp;gt; uint256) public ownedTokensIndex;

	// All tokens list tokens ids
	uint256[] public tokenIds;

	// Mapping from tokenId to index of the tokens list
	mapping (uint256 =&amp;gt; uint256) public tokenIdsIndex;


	function getTokenOwner(uint256 _tokenId) view public returns (address) {
		return tokenOwner[_tokenId];
	}

	function setTokenOwner(uint256 _tokenId, address _owner) public storageAccessControl {
		tokenOwner[_tokenId] = _owner;
	}

	function getTokenApproval(uint256 _tokenId) view public returns (address) {
		return tokenApprovals[_tokenId];
	}

	function setTokenApproval(uint256 _tokenId, address _to) public storageAccessControl {
		tokenApprovals[_tokenId] = _to;
	}

	function getOwnedArea(address _owner) view public returns (uint256) {
		return ownedArea[_owner];
	}

	function setOwnedArea(address _owner, uint256 _area) public storageAccessControl {
		ownedArea[_owner] = _area;
	}

	function incrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].add(_area);
		return ownedArea[_owner];
	}

	function decrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].sub(_area);
		return ownedArea[_owner];
	}

	function getOwnedTokensLength(address _owner) view public returns (uint256) {
		return ownedTokens[_owner].length;
	}

	function getOwnedToken(address _owner, uint256 _index) view public returns (uint256) {
		return ownedTokens[_owner][_index];
	}

	function setOwnedToken(address _owner, uint256 _index, uint256 _tokenId) public storageAccessControl {
		ownedTokens[_owner][_index] = _tokenId;
	}

	function pushOwnedToken(address _owner, uint256 _tokenId) public storageAccessControl returns (uint256) {
		ownedTokens[_owner].push(_tokenId);
		return ownedTokens[_owner].length;
	}

	function decrementOwnedTokensLength(address _owner) public storageAccessControl {
		ownedTokens[_owner].length--;
	}

	function getOwnedTokensIndex(uint256 _tokenId) view public returns (uint256) {
		return ownedTokensIndex[_tokenId];
	}

	function setOwnedTokensIndex(uint256 _tokenId, uint256 _tokenIndex) public storageAccessControl {
		ownedTokensIndex[_tokenId] = _tokenIndex;
	}

	function getTokenIdsLength() view public returns (uint256) {
		return tokenIds.length;
	}

	function getTokenIdByIndex(uint256 _index) view public returns (uint256) {
		return tokenIds[_index];
	}

	function setTokenIdByIndex(uint256 _index, uint256 _tokenId) public storageAccessControl {
		tokenIds[_index] = _tokenId;
	}

	function pushTokenId(uint256 _tokenId) public storageAccessControl returns (uint256) {
		tokenIds.push(_tokenId);
		return tokenIds.length;
	}

	function decrementTokenIdsLength() public storageAccessControl {
		tokenIds.length--;
	}

	function getTokenIdsIndex(uint256 _tokenId) view public returns (uint256) {
		return tokenIdsIndex[_tokenId];
	}

	function setTokenIdsIndex(uint256 _tokenId, uint256 _tokenIdIndex) public storageAccessControl {
		tokenIdsIndex[_tokenId] = _tokenIdIndex;
	}

	function BdpOwnershipStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/libraries/BdpOwnership.sol

/**
 * Ownership manager
 * Does not check if the caller is allowed to call functions
 * State changing methods are not intended to be called from controller
 */
library BdpOwnership {

	using SafeMath for uint256;

	event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

	event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

	function ownerOf(address[16] _contracts, uint256 _tokenId) public view returns (address) {
		var owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);
		require(owner != address(0));
		return owner;
	}

	function balanceOf(address[16] _contracts, address _owner) public view returns (uint256) {
		return BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getOwnedTokensLength(_owner);
	}

	function approve(address[16] _contracts, address _to, uint256 _tokenId) public {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		address owner = ownerOf(_contracts, _tokenId);
		require(_to != owner);
		if (ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0) {
			ownStorage.setTokenApproval(_tokenId, _to);
			Approval(owner, _to, _tokenId);
		}
	}

	/**
	 * @dev Clear current approval of a given token ID
	 * @param _tokenId uint256 ID of the token to be transferred
	 */
	function clearApproval(address[16] _contracts, address _owner, uint256 _tokenId) public {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownerOf(_contracts, _tokenId) == _owner);
		if (ownStorage.getTokenApproval(_tokenId) != 0) {
			BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).setTokenApproval(_tokenId, 0);
			Approval(_owner, 0, _tokenId);
		}
	}

	/**
	 * @dev Clear current approval and transfer the ownership of a given token ID
	 * @param _from address which you want to send tokens from
	 * @param _to address which you want to transfer the token to
	 * @param _tokenId uint256 ID of the token to be transferred
	 */
	function clearApprovalAndTransfer(address[16] _contracts, address _from, address _to, uint256 _tokenId) public {
		require(_to != address(0));
		require(_to != ownerOf(_contracts, _tokenId));
		require(ownerOf(_contracts, _tokenId) == _from);

		clearApproval(_contracts, _from, _tokenId);
		removeToken(_contracts, _from, _tokenId);
		addToken(_contracts, _to, _tokenId);
		Transfer(_from, _to, _tokenId);
	}

	/**
	 * @dev Internal function to add a token ID to the list of a given address
	 * @param _to address representing the new owner of the given token ID
	 * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address
	 */
	function addToken(address[16] _contracts, address _to, uint256 _tokenId) private {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownStorage.getTokenOwner(_tokenId) == address(0));

		// Set token owner
		ownStorage.setTokenOwner(_tokenId, _to);

		// Add token to tokenIds list
		var tokenIdsLength = ownStorage.pushTokenId(_tokenId);
		ownStorage.setTokenIdsIndex(_tokenId, tokenIdsLength.sub(1));

		uint256 ownedTokensLength = ownStorage.getOwnedTokensLength(_to);

		// Add token to ownedTokens list
		ownStorage.pushOwnedToken(_to, _tokenId);
		ownStorage.setOwnedTokensIndex(_tokenId, ownedTokensLength);

		// Increment total owned area
		var (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);
		ownStorage.incrementOwnedArea(_to, area);
	}

	/**
	 * @dev Internal function to remove a token ID from the list of a given address
	 * @param _from address representing the previous owner of the given token ID
	 * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address
	 */
	function removeToken(address[16] _contracts, address _from, uint256 _tokenId) private {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownerOf(_contracts, _tokenId) == _from);

		// Clear token owner
		ownStorage.setTokenOwner(_tokenId, 0);

		removeFromTokenIds(ownStorage, _tokenId);
		removeFromOwnedToken(ownStorage, _from, _tokenId);

		// Decrement total owned area
		var (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);
		ownStorage.decrementOwnedArea(_from, area);
	}

	/**
	 * @dev Remove token from ownedTokens list
	 * Note that this will handle single-element arrays. In that case, both ownedTokenIndex and lastOwnedTokenIndex are going to
	 * be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping
	 * the lastOwnedToken to the first position, and then dropping the element placed in the last position of the list
	 */
	function removeFromOwnedToken(BdpOwnershipStorage _ownStorage, address _from, uint256 _tokenId) private {
		var ownedTokenIndex = _ownStorage.getOwnedTokensIndex(_tokenId);
		var lastOwnedTokenIndex = _ownStorage.getOwnedTokensLength(_from).sub(1);
		var lastOwnedToken = _ownStorage.getOwnedToken(_from, lastOwnedTokenIndex);
		_ownStorage.setOwnedToken(_from, ownedTokenIndex, lastOwnedToken);
		_ownStorage.setOwnedToken(_from, lastOwnedTokenIndex, 0);
		_ownStorage.decrementOwnedTokensLength(_from);
		_ownStorage.setOwnedTokensIndex(_tokenId, 0);
		_ownStorage.setOwnedTokensIndex(lastOwnedToken, ownedTokenIndex);
	}

	/**
	 * @dev Remove token from tokenIds list
	 */
	function removeFromTokenIds(BdpOwnershipStorage _ownStorage, uint256 _tokenId) private {
		var tokenIndex = _ownStorage.getTokenIdsIndex(_tokenId);
		var lastTokenIdIndex = _ownStorage.getTokenIdsLength().sub(1);
		var lastTokenId = _ownStorage.getTokenIdByIndex(lastTokenIdIndex);
		_ownStorage.setTokenIdByIndex(tokenIndex, lastTokenId);
		_ownStorage.setTokenIdByIndex(lastTokenIdIndex, 0);
		_ownStorage.decrementTokenIdsLength();
		_ownStorage.setTokenIdsIndex(_tokenId, 0);
		_ownStorage.setTokenIdsIndex(lastTokenId, tokenIndex);
	}

	/**
	 * @dev Mint token function
	 * @param _to The address that will own the minted token
	 * @param _tokenId uint256 ID of the token to be minted by the msg.sender
	 */
	function mint(address[16] _contracts, address _to, uint256 _tokenId) public {
		require(_to != address(0));
		addToken(_contracts, _to, _tokenId);
		Transfer(address(0), _to, _tokenId);
	}

	/**
	 * @dev Burns a specific token
	 * @param _tokenId uint256 ID of the token being burned
	 */
	function burn(address[16] _contracts, uint256 _tokenId) public {
		address owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);
		clearApproval(_contracts, owner, _tokenId);
		removeToken(_contracts, owner, _tokenId);
		Transfer(owner, address(0), _tokenId);
	}

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x7c08e870a8f056d147604d3d5d1b95d1f76e0f79.sol" target="_blank" title="show github file">0x7c08e870a8f056d147604d3d5d1b95d1f76e0f79.sol</a>
        </div>
        <div class="path">solidity-files/0x7c08e870a8f056d147604d3d5d1b95d1f76e0f79.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.11;



/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {

  function mul(uint256 a, uint256 b) internal constant returns (uint256) {

    uint256 c = a * b;

    assert(a == 0 || c / a == b);

    return c;

  }



  function div(uint256 a, uint256 b) internal constant returns (uint256) {

    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0

    uint256 c = a / b;

    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold

    return c;

  }



  function sub(uint256 a, uint256 b) internal constant returns (uint256) {

    assert(b &amp;lt;= a);

    return a - b;

  }



  function add(uint256 a, uint256 b) internal constant returns (uint256) {

    uint256 c = a + b;

    assert(c &amp;gt;= a);

    return c;

  }

}



/**

 * @title Crowdsale

 * @dev Crowdsale is a base contract for managing a token crowdsale.

 * Crowdsales have a start and end timestamps, where investors can make

 * token purchases and the crowdsale will assign them tokens based

 * on a token per ETH rate. Funds collected are forwarded to a wallet

 * as they arrive.

 */

contract token { function transfer(address receiver, uint amount){  } }

contract Crowdsale {

  using SafeMath for uint256;



  // uint256 durationInMinutes;

  // address where funds are collected

  address public wallet;

  // token address

  address addressOfTokenUsedAsReward;



  token tokenReward;







  // start and end timestamps where investments are allowed (both inclusive)

  uint256 public startTime;

  uint256 public endTime;

  // amount of raised money in wei

  uint256 public weiRaised;



  /**

   * event for token purchase logging

   * @param purchaser who paid for the tokens

   * @param beneficiary who got the tokens

   * @param value weis paid for purchase

   * @param amount amount of tokens purchased

   */

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);





  function Crowdsale() {

    wallet = 0x205E2ACd291E235425b5c10feC8F62FE7Ec26063;

    // durationInMinutes = _durationInMinutes;

    addressOfTokenUsedAsReward = 0x82B99C8a12B6Ee50191B9B2a03B9c7AEF663D527;





    tokenReward = token(addressOfTokenUsedAsReward);

  }



  bool started = false;



  function startSale(uint256 delay){

    if (msg.sender != wallet || started) throw;

    startTime = now + delay * 1 minutes;

    endTime = startTime + 20 * 24 * 60 * 1 minutes;

    started = true;

  }



  // fallback function can be used to buy tokens

  function () payable {

    buyTokens(msg.sender);

  }



  // low level token purchase function

  function buyTokens(address beneficiary) payable {

    require(beneficiary != 0x0);

    require(validPurchase());



    uint256 weiAmount = msg.value;



    // calculate token amount to be sent

    uint256 tokens = (weiAmount/10**10) * 490;



    if(now &amp;lt; startTime + 1*7*24*60* 1 minutes){

      tokens += (tokens * 20) / 100;

    }else if(now &amp;lt; startTime + 2*7*24*60* 1 minutes){

      tokens += (tokens * 10) / 100;

    }else{

      tokens += (tokens * 5) / 100;

    }



    // update state

    weiRaised = weiRaised.add(weiAmount);



    tokenReward.transfer(beneficiary, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();

  }



  // send ether to the fund collection wallet

  // override to create custom fund forwarding mechanisms

  function forwardFunds() internal {

    // wallet.transfer(msg.value);

    if (!wallet.send(msg.value)) {

      throw;

    }

  }



  // @return true if the transaction can buy tokens

  function validPurchase() internal constant returns (bool) {

    bool withinPeriod = now &amp;gt;= startTime &amp;amp;&amp;amp; now &amp;lt;= endTime;

    bool nonZeroPurchase = msg.value != 0;

    return withinPeriod &amp;amp;&amp;amp; nonZeroPurchase;

  }



  // @return true if crowdsale event has ended

  function hasEnded() public constant returns (bool) {

    return now &amp;gt; endTime;

  }



  function withdrawTokens(uint256 _amount) {

    if(msg.sender!=wallet) throw;

    tokenReward.transfer(wallet,_amount);

  }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xb818853ba8f4c1483f36dd7b4fb75c9490ac406e.sol" target="_blank" title="show github file">0xb818853ba8f4c1483f36dd7b4fb75c9490ac406e.sol</a>
        </div>
        <div class="path">solidity-files/0xb818853ba8f4c1483f36dd7b4fb75c9490ac406e.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;ACT115442&amp;#39; token contract
//
// Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
// Symbol      : ACT115442
// Name        : ADZbuzz Url-tipp.com Community Token
// Total supply: 2000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function ADZbuzzCommunityToken() public {
        symbol = &amp;quot;ACT115442&amp;quot;;
        name = &amp;quot;ADZbuzz Url-tipp.com Community Token&amp;quot;;
        decimals = 8;
        _totalSupply = 200000000000000;
        balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
        emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x2768a34d8567e35e5b19a24231581392755cc0ce.sol" target="_blank" title="show github file">0x2768a34d8567e35e5b19a24231581392755cc0ce.sol</a>
        </div>
        <div class="path">solidity-files/0x2768a34d8567e35e5b19a24231581392755cc0ce.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;




/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}
/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */

contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}
/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {

  using SafeMath for uint256;

 

  mapping(address =&amp;gt; uint256) balances;

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }
}

/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

  mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[_from]);
    require(_value &amp;lt;= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue &amp;gt; oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}


contract MintBurnableToken is StandardToken, Ownable {
  event Mint(address indexed to, uint256 amount);
  event MintFinished();

  bool public mintingFinished = false;


  modifier canMint() {
    require(!mintingFinished);
    _;
  }

  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    Transfer(address(0), _to, _amount);
    return true;
  }

  function finishMinting() onlyOwner canMint public returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }

  event Burn(address indexed burner, uint256 value);

  /**
   * @dev Burns a specific amount of tokens.
   * @param _value The amount of token to be burned.
   */
  function burn(uint256 _value) public {
    require(_value &amp;lt;= balances[msg.sender]);
    // no need to require value &amp;lt;= totalSupply, since that would imply the
    // sender&amp;#39;s balance is greater than the totalSupply, which *should* be an assertion failure

    address burner = msg.sender;
    balances[burner] = balances[burner].sub(_value);
    totalSupply = totalSupply.sub(_value);
    Burn(burner, _value);
    Transfer(burner, address(0), _value);
  }

}

contract DLH is MintBurnableToken {

  string public constant name = &amp;quot;Depositor-investor L&amp;amp;H&amp;quot;;

  string public constant symbol = &amp;quot;DLH&amp;quot;;

  uint8 public constant decimals = 18;

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x7007e73703061ad273e37d14f43f9d9d32b5a493.sol" target="_blank" title="show github file">0x7007e73703061ad273e37d14f43f9d9d32b5a493.sol</a>
        </div>
        <div class="path">solidity-files/0x7007e73703061ad273e37d14f43f9d9d32b5a493.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

pragma solidity ^0.4.18;

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
    uint256 public totalSupply;
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b &amp;lt;= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c &amp;gt;= a);
        return c;
    }
}



/**
 * @title Basic contracts
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {
    using SafeMath for uint256;

    mapping(address =&amp;gt; uint256) balances;

    /**
    * @dev transfer contracts for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

}


/**
 * @title Burnable Token
 * @dev Token that can be irreversibly burned (destroyed).
 */
contract BurnableToken is BasicToken {

    event Burn(address indexed burner, uint256 value);

    /**
     * @dev Burns a specific amount of tokens.
     * @param _value The amount of contracts to be burned.
     */
    function burn(uint256 _value) public {
        require(_value &amp;lt;= balances[msg.sender]);
        // no need to require value &amp;lt;= totalSupply, since that would imply the
        // sender&amp;#39;s balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(burner, _value);
    }
}


/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}



/**
 * @title Standard ERC20 contracts
 *
 * @dev Implementation of the basic standard contracts.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;


    /**
     * @dev Transfer tokens from one address to another
     * @param _from address The address which you want to send tokens from
     * @param _to address The address which you want to transfer to
     * @param _value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[_from]);
        require(_value &amp;lt;= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     *
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param _spender The address which will spend the funds.
     * @param _value The amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _addedValue The amount of tokens to increase the allowance by.
     */
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue &amp;gt; oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

}

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
    address public owner;


    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


    /**
     * @dev The Ownable constructor sets the original `owner` of the contract to the sender
     * account.
     */
    function Ownable() public {
        owner = msg.sender;
    }


    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }


    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

}



/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
    event Pause();
    event Unpause();

    bool public paused = false;


    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
        require(!paused);
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     */
    modifier whenPaused() {
        require(paused);
        _;
    }

    /**
     * @dev called by the owner to pause, triggers stopped state
     */
    function pause() onlyOwner whenNotPaused public {
        paused = true;
        emit Pause();
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() onlyOwner whenPaused public {
        paused = false;
        emit Unpause();
    }
}


/**
 * @title Pausable token
 *
 * @dev StandardToken modified with pausable transfers.
 **/

contract PausableToken is StandardToken, Pausable {

    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
        return super.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }

    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
        return super.approve(_spender, _value);
    }

    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
        return super.increaseApproval(_spender, _addedValue);
    }

    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
        return super.decreaseApproval(_spender, _subtractedValue);
    }

}

contract PAXToken is BurnableToken, PausableToken {

    using SafeMath for uint;

    string public constant name = &amp;quot;Pax Token&amp;quot;;

    string public constant symbol = &amp;quot;PAX&amp;quot;;

    uint32 public constant decimals = 10;

    uint256 public constant INITIAL_SUPPLY = 999500000 * (10 ** uint256(decimals));

    /**
     * @dev Constructor that gives msg.sender all of existing tokens.
     * @param _company address reserve tokens (300000000)
     * @param _founders_1 address reserve tokens (300000000)
     * @param _founders_2 address reserve tokens (50000000)
     * @param _isPause bool (pause === true)
     */
    function PAXToken(address _company, address _founders_1, address _founders_2, bool _isPause) public {
        require(_company != address(0) &amp;amp;&amp;amp; _founders_1 != address(0) &amp;amp;&amp;amp; _founders_2 != address(0));
        paused = _isPause;
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = 349500000 * (10 ** uint256(decimals));
        balances[_company] = 300000000 * (10 ** uint256(decimals));
        balances[_founders_1] = 300000000 * (10 ** uint256(decimals));
        balances[_founders_2] = 50000000 * (10 ** uint256(decimals));
        emit Transfer(0x0, msg.sender, balances[msg.sender]);
        emit Transfer(0x0, _company, balances[_company]);
        emit Transfer(0x0, _founders_1, balances[_founders_1]);
        emit Transfer(0x0, _founders_2, balances[_founders_2]);

    }

    /**
    * @dev transfer contracts for a specified address, despite the pause state
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function ownersTransfer(address _to, uint256 _value) public onlyOwner returns (bool) {
        return BasicToken.transfer(_to, _value);
    }
}

contract Crowdsale is Pausable {

    struct stageInfo {
        uint start;
        uint stop;
        uint duration;
        uint bonus;
        uint limit;
    }

    /**
     * @dev Mapping with stageId = stageInfo
     */
    mapping (uint =&amp;gt; stageInfo) public stages;

    /**
     * @dev Mapping with adress = with balance
     */
    mapping(address =&amp;gt; uint) public balances;

    /**
     * @dev Softcap
     */
    uint public constant softcap = 2500 ether;

    /**
     * @dev xDecimals
     */
    uint public constant decimals = 1E10;

    /**
     * @dev ICO Period Number
     */
    uint public period = 5;

    /**
     * @dev Total number of minted tokens
     */
    uint public hardcap;

    /**
     * @dev Cost of the token
     */
    uint public rate;

    /**
     * @dev Number of sold tokens
     */
    uint public totalSold = 0;

    /**
     * @dev Assembled Eth
     */
    uint256 public sumWei;

    /**
     * @dev ICO Status
     */
    bool public state;

    /**
     * @dev Once call flag
     */
    bool public requireOnce = true;

    /**
     * @dev Once burning flag
     */
    bool public isBurned;

    /**
     * @dev Reserve tokens adress for company (300000000)
     */
    address public company;

    /**
     * @dev Reserve tokens adress for founders first (300000000)
     */
    address public founders_1;

    /**
     * @dev Reserve tokens adress for founders second (50000000)
     */
    address public founders_2;

    /**
     * @dev The address to which the received ether will be sent
     */
    address public multisig;

    /**
     * @dev Tokens classes
     */
    PAXToken public token;

    /**
     * @dev Number of coins for the typical period
     */
    uint private constant typicalBonus = 100;

    /**
     * @dev Sending tokens
     */
    uint private sendingTokens;

    /**
     * @dev Time left
     */
    uint private timeLeft;

    /**
     * @dev Pause date
     */
    uint private pauseDate;

    /**
     * @dev Paused by value flag
     */
    bool private pausedByValue;

    /**
     * @dev Manual pause flag
     */
    bool private manualPause;


    event StartICO();

    event StopICO();

    event BurnUnsoldTokens();

    event NewWalletAddress(address _to);

    event Refund(address _wallet, uint _val);

    event DateMoved(uint value);

    using SafeMath for uint;

    modifier saleIsOn() {
        require(state);
        uint stageId = getStageId();
        if (period != stageId || stageId == 5) {
            usersPause();
            (msg.sender).transfer(msg.value);
        }
        else
            _;
    }

    modifier isUnderHardCap() {
        uint tokenBalance = token.balanceOf(this);
        require(
            tokenBalance &amp;lt;= hardcap &amp;amp;&amp;amp;
            tokenBalance &amp;gt;= 500
        );
        _;
    }


    function Crowdsale(address _company, address _founders_1, address _founders_2, address _token) public {
        multisig = owner;
        rate = (uint)(1 ether).div(5000);

        stages[0] = stageInfo({
            start: 0,
            stop: 0,
            duration: 14 days,
            bonus: 130,
            limit:  44500000 * decimals
            });

        stages[1] = stageInfo({
            start: 0,
            stop: 0,
            duration: 14 days,
            bonus: 115,
            limit:  85000000 * decimals
            });

        stages[2] = stageInfo({
            start: 0,
            stop: 0,
            duration: 14 days,
            bonus: 110,
            limit:  100000000 * decimals
            });

        stages[3] = stageInfo({
            start: 0,
            stop: 0,
            duration: 14 days,
            bonus: 105,
            limit:  120000000 * decimals
            });

        hardcap = 349500000 * decimals;

        token = PAXToken(_token);

        company = _company;
        founders_1 = _founders_1;
        founders_2 = _founders_2;
    }


    /**
     * @dev Fallback function
     */
    function() whenNotPaused saleIsOn external payable {
        require (msg.value &amp;gt; 0);
        sendTokens(msg.value, msg.sender);
    }

    /**
     * @dev Manual sending tokens
     * @param _to address where sending tokens
     * @param _value uint256 value tokens for sending
     */
    function manualSendTokens(address _to, uint256 _value) public onlyOwner returns(bool) {
        uint tokens = _value;
        uint avalibleTokens = token.balanceOf(this);

        if (tokens &amp;lt; avalibleTokens) {
            if (tokens &amp;lt;= stages[3].limit) {
                stages[3].limit = (stages[3].limit).sub(tokens);
            } else if (tokens &amp;lt;= (stages[3].limit).add(stages[2].limit)) {
                stages[2].limit = (stages[2].limit).sub(tokens.sub(stages[3].limit));
                stages[3].limit = 0;
            } else if (tokens &amp;lt;= (stages[3].limit).add(stages[2].limit).add(stages[1].limit)) {
                stages[1].limit = (stages[1].limit).sub(tokens.sub(stages[3].limit).sub(stages[2].limit));
                stages[3].limit = 0;
                stages[2].limit = 0;
            } else if (tokens &amp;lt;= (stages[3].limit).add(stages[2].limit).add(stages[1].limit).add(stages[0].limit)) {
                stages[0].limit = (stages[0].limit).sub(tokens.sub(stages[3].limit).sub(stages[2].limit).sub(stages[1].limit));
                stages[3].limit = 0;
                stages[2].limit = 0;
                stages[1].limit = 0;
            }
        } else {
            tokens = avalibleTokens;
            stages[3].limit = 0;
            stages[2].limit = 0;
            stages[1].limit = 0;
            stages[0].limit = 0;
        }

        sendingTokens = sendingTokens.add(tokens);
        sumWei = sumWei.add(tokens.mul(rate).div(decimals));
        totalSold = totalSold.add(tokens);
        token.ownersTransfer(_to, tokens);

        return true;
    }

    /**
     * @dev Return Etherium all investors
     */
    function refund() public {
        require(sumWei &amp;lt; softcap &amp;amp;&amp;amp; !state);
        uint value = balances[msg.sender];
        balances[msg.sender] = 0;
        emit Refund(msg.sender, value);
        msg.sender.transfer(value);
    }

    /**
     * @dev Burning all tokens on mintAddress
     */
    function burnUnsoldTokens() onlyOwner public returns(bool) {
        require(!state);
        require(!isBurned);
        isBurned = true;
        emit BurnUnsoldTokens();
        token.burn(token.balanceOf(this));
        if (token.paused()) {
            token.unpause();
        }
        return true;
    }

    /**
     * @dev Starting ICO
     */
    function startICO() public onlyOwner returns(bool) {
        require(stages[0].start &amp;gt;= now);
        require(requireOnce);
        requireOnce = false;
        state = true;
        period = 0;
        emit StartICO();
        token.ownersTransfer(company, (uint)(300000000).mul(decimals));
        token.ownersTransfer(founders_1, (uint)(300000000).mul(decimals));
        token.ownersTransfer(founders_2, (uint)(50000000).mul(decimals));
        return true;
    }

    /**
     * @dev Turning off the ICO
     */
    function stopICO() onlyOwner public returns(bool) {
        state = false;
        emit StopICO();
        if (token.paused()) {
            token.unpause();
        }
        return true;
    }

    /**
     * @dev called by the owner to pause, triggers stopped state
     */
    function pause() onlyOwner whenNotPaused public {
        manualPause = true;
        usersPause();
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() onlyOwner whenPaused public {
        uint shift = now.sub(pauseDate);
        dateMove(shift);
        period = getStageId();
        pausedByValue = false;
        manualPause = false;
        super.unpause();
    }

    /**
     * @dev Withdrawal Etherium from smart-contract
     */
    function withDrawal() public onlyOwner {
        if(!state &amp;amp;&amp;amp; sumWei &amp;gt;= softcap) {
            multisig.transfer(address(this).balance);
        }
    }

    /**
     * @dev Returns stage id
     */
    function getStageId() public view returns(uint) {
        uint stageId;
        uint today = now;

        if (today &amp;lt; stages[0].stop) {
            stageId = 0;

        } else if (today &amp;gt;= stages[1].start &amp;amp;&amp;amp;
        today &amp;lt; stages[1].stop ) {
            stageId = 1;

        } else if (today &amp;gt;= stages[2].start &amp;amp;&amp;amp;
        today &amp;lt; stages[2].stop ) {
            stageId = 2;

        } else if (today &amp;gt;= stages[3].start &amp;amp;&amp;amp;
        today &amp;lt; stages[3].stop ) {
            stageId = 3;

        } else if (today &amp;gt;= stages[3].stop) {
            stageId = 4;

        } else {
            return 5;
        }

        uint tempId = (stageId &amp;gt; period) ? stageId : period;
        return tempId;
    }

    /**
     * @dev Returns Limit of coins for the period and Number of coins taking
     * into account the bonus for the period
     */
    function getStageData() public view returns(uint tempLimit, uint tempBonus) {
        uint stageId = getStageId();
        tempBonus = stages[stageId].bonus;

        if (stageId == 0) {
            tempLimit = stages[0].limit;

        } else if (stageId == 1) {
            tempLimit = (stages[0].limit).add(stages[1].limit);

        } else if (stageId == 2) {
            tempLimit = (stages[0].limit).add(stages[1].limit).add(stages[2].limit);

        } else if (stageId == 3) {
            tempLimit = (stages[0].limit).add(stages[1].limit).add(stages[2].limit).add(stages[3].limit);

        } else {
            tempLimit = token.balanceOf(this);
            tempBonus = typicalBonus;
            return;
        }
        tempLimit = tempLimit.sub(totalSold);
        return;
    }

    /**
     * @dev Returns the amount for which you can redeem all tokens for the current period
     */
    function calculateStagePrice() public view returns(uint price) {
        uint limit;
        uint bonusCoefficient;
        (limit, bonusCoefficient) = getStageData();

        price = limit.mul(rate).mul(100).div(bonusCoefficient).div(decimals);
    }

    /**
     * @dev Sending tokens to the recipient, based on the amount of ether that it sent
     * @param _etherValue uint Amount of sent ether
     * @param _to address The address which you want to transfer to
     */
    function sendTokens(uint _etherValue, address _to) internal isUnderHardCap {
        uint limit;
        uint bonusCoefficient;
        (limit, bonusCoefficient) = getStageData();
        uint tokens = (_etherValue).mul(bonusCoefficient).mul(decimals).div(100);
        tokens = tokens.div(rate);
        bool needPause;

        if (tokens &amp;gt; limit) {
            needPause = true;
            uint stageEther = calculateStagePrice();
            period++;
            if (period == 4) {
                balances[msg.sender] = balances[msg.sender].add(stageEther);
                sumWei = sumWei.add(stageEther);
                token.ownersTransfer(_to, limit);
                totalSold = totalSold.add(limit);
                _to.transfer(_etherValue.sub(stageEther));
                state = false;
                return;
            }
            balances[msg.sender] = balances[msg.sender].add(stageEther);
            sumWei = sumWei.add(stageEther);
            token.ownersTransfer(_to, limit);
            totalSold = totalSold.add(limit);
            sendTokens(_etherValue.sub(stageEther), _to);

        } else {
            require(tokens &amp;lt;= token.balanceOf(this));
            if (limit.sub(tokens) &amp;lt; 500) {
                needPause = true;
                period++;
            }
            balances[msg.sender] = balances[msg.sender].add(_etherValue);
            sumWei = sumWei.add(_etherValue);
            token.ownersTransfer(_to, tokens);
            totalSold = totalSold.add(tokens);
        }

        if (needPause) {
            pausedByValue = true;
            usersPause();
        }
    }

    /**
     * @dev called by the contract to pause, triggers stopped state
     */
    function usersPause() private {
        pauseDate = now;
        paused = true;
        emit Pause();
    }

    /**
     * @dev Moving date after the pause
     * @param _shift uint Time in seconds
     */
    function dateMove(uint _shift) private returns(bool) {
        require(_shift &amp;gt; 0);

        uint i;

        if (pausedByValue) {
            stages[period].start = now;
            stages[period].stop = (stages[period].start).add(stages[period].duration);

            for (i = period + 1; i &amp;lt; 4; i++) {
                stages[i].start = stages[i - 1].stop;
                stages[i].stop = (stages[i].start).add(stages[i].duration);
            }

        } else {
            if (manualPause) stages[period].stop = (stages[period].stop).add(_shift);

            for (i = period + 1; i &amp;lt; 4; i++) {
                stages[i].start = (stages[i].start).add(_shift);
                stages[i].stop = (stages[i].stop).add(_shift);
            }
        }

        emit DateMoved(_shift);

        return true;
    }

    /**
     * @dev Returns the total number of tokens available for sale
     */
    function tokensAmount() public view returns(uint) {
        return token.balanceOf(this);
    }

    /**
     * @dev Returns number of supplied tokens
     */
    function tokensSupply() public view returns(uint) {
        return token.totalSupply();
    }

    /**
     * @dev Set start date
     * @param _start uint Time start
     */
    function setStartDate(uint _start) public onlyOwner returns(bool) {
        require(_start &amp;gt; now);
        require(requireOnce);

        stages[0].start = _start;
        stages[0].stop = _start.add(stages[0].duration);
        stages[1].start = stages[0].stop;
        stages[1].stop = stages[1].start.add(stages[1].duration);
        stages[2].start = stages[1].stop;
        stages[2].stop = stages[2].start.add(stages[2].duration);
        stages[3].start = stages[2].stop;
        stages[3].stop = stages[3].start.add(stages[3].duration);

        return true;
    }

    /**
     * @dev Sets new multisig address to which the received ether will be sent
     * @param _to address
     */
    function setMultisig(address _to) public onlyOwner returns(bool) {
        require(_to != address(0));
        multisig = _to;
        emit NewWalletAddress(_to);
        return true;
    }

    /**
     * @dev Change first adress with reserve(300000000 tokens)
     * @param _company address
     */
    function setReserveForCompany(address _company) public onlyOwner {
        require(_company != address(0));
        require(requireOnce);
        company = _company;
    }

    /**
     * @dev Change second adress with reserve(300000000 tokens)
     * @param _founders_1 address
     */
    function setReserveForFoundersFirst(address _founders_1) public onlyOwner {
        require(_founders_1 != address(0));
        require(requireOnce);
        founders_1 = _founders_1;
    }

    /**
     * @dev Change third adress with reserve(50000000 tokens)
     * @param _founders_2 address
     */
    function setReserveForFoundersSecond(address _founders_2) public onlyOwner {
        require(_founders_2 != address(0));
        require(requireOnce);
        founders_2 = _founders_2;
    }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x63768b2d4afeb3aad9150bd51f1c20a649bc43f0.sol" target="_blank" title="show github file">0x63768b2d4afeb3aad9150bd51f1c20a649bc43f0.sol</a>
        </div>
        <div class="path">solidity-files/0x63768b2d4afeb3aad9150bd51f1c20a649bc43f0.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity 0.4.19;

// File: contracts/NokuPricingPlan.sol

/**
* @dev The NokuPricingPlan contract defines the responsibilities of a Noku pricing plan.
*/
interface NokuPricingPlan {
    /**
    * @dev Pay the fee for the service identified by the specified name.
    * The fee amount shall already be approved by the client.
    * @param serviceName The name of the target service.
    * @param multiplier The multiplier of the base service fee to apply.
    * @param client The client of the target service.
    * @return true if fee has been paid.
    */
    function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);

    /**
    * @dev Get the usage fee for the service identified by the specified name.
    * The returned fee amount shall be approved before using #payFee method.
    * @param serviceName The name of the target service.
    * @param multiplier The multiplier of the base service fee to apply.
    * @return The amount to approve before really paying such fee.
    */
    function usageFee(bytes32 serviceName, uint256 multiplier) public constant returns(uint fee);
}

// File: zeppelin-solidity/contracts/ownership/Ownable.sol

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol

/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  /**
   * @dev Modifier to make a function callable only when the contract is paused.
   */
  modifier whenPaused() {
    require(paused);
    _;
  }

  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
    paused = false;
    Unpause();
  }
}

// File: zeppelin-solidity/contracts/math/SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol

/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: contracts/NokuTokenBurner.sol

contract BurnableERC20 is ERC20 {
    function burn(uint256 amount) public returns (bool burned);
}

/**
* @dev The NokuTokenBurner contract has the responsibility to burn the configured fraction of received
* ERC20-compliant tokens and distribute the remainder to the configured wallet.
*/
contract NokuTokenBurner is Pausable {
    using SafeMath for uint256;

    event LogNokuTokenBurnerCreated(address indexed caller, address indexed wallet);
    event LogBurningPercentageChanged(address indexed caller, uint256 indexed burningPercentage);

    // The wallet receiving the unburnt tokens.
    address public wallet;

    // The percentage of tokens to burn after being received (range [0, 100])
    uint256 public burningPercentage;

    // The cumulative amount of burnt tokens.
    uint256 public burnedTokens;

    // The cumulative amount of tokens transferred back to the wallet.
    uint256 public transferredTokens;

    /**
    * @dev Create a new NokuTokenBurner with predefined burning fraction.
    * @param _wallet The wallet receiving the unburnt tokens.
    */
    function NokuTokenBurner(address _wallet) public {
        require(_wallet != address(0));
        
        wallet = _wallet;
        burningPercentage = 100;

        LogNokuTokenBurnerCreated(msg.sender, _wallet);
    }

    /**
    * @dev Change the percentage of tokens to burn after being received.
    * @param _burningPercentage The percentage of tokens to be burnt.
    */
    function setBurningPercentage(uint256 _burningPercentage) public onlyOwner {
        require(0 &amp;lt;= _burningPercentage &amp;amp;&amp;amp; _burningPercentage &amp;lt;= 100);
        require(_burningPercentage != burningPercentage);
        
        burningPercentage = _burningPercentage;

        LogBurningPercentageChanged(msg.sender, _burningPercentage);
    }

    /**
    * @dev Called after burnable tokens has been transferred for burning.
    * @param _token THe extended ERC20 interface supported by the sent tokens.
    * @param _amount The amount of burnable tokens just arrived ready for burning.
    */
    function tokenReceived(address _token, uint256 _amount) public whenNotPaused {
        require(_token != address(0));
        require(_amount &amp;gt; 0);

        uint256 amountToBurn = _amount.mul(burningPercentage).div(100);
        if (amountToBurn &amp;gt; 0) {
            assert(BurnableERC20(_token).burn(amountToBurn));
            
            burnedTokens = burnedTokens.add(amountToBurn);
        }

        uint256 amountToTransfer = _amount.sub(amountToBurn);
        if (amountToTransfer &amp;gt; 0) {
            assert(BurnableERC20(_token).transfer(wallet, amountToTransfer));

            transferredTokens = transferredTokens.add(amountToTransfer);
        }
    }
}

// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address =&amp;gt; uint256) balances;

  uint256 totalSupply_;

  /**
  * @dev total number of tokens in existence
  */
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}

// File: zeppelin-solidity/contracts/token/ERC20/BurnableToken.sol

/**
 * @title Burnable Token
 * @dev Token that can be irreversibly burned (destroyed).
 */
contract BurnableToken is BasicToken {

  event Burn(address indexed burner, uint256 value);

  /**
   * @dev Burns a specific amount of tokens.
   * @param _value The amount of token to be burned.
   */
  function burn(uint256 _value) public {
    require(_value &amp;lt;= balances[msg.sender]);
    // no need to require value &amp;lt;= totalSupply, since that would imply the
    // sender&amp;#39;s balance is greater than the totalSupply, which *should* be an assertion failure

    address burner = msg.sender;
    balances[burner] = balances[burner].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    Burn(burner, _value);
  }
}

// File: zeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol

contract DetailedERC20 is ERC20 {
  string public name;
  string public symbol;
  uint8 public decimals;

  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
  }
}

// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol

/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

  mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[_from]);
    require(_value &amp;lt;= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue &amp;gt; oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}

// File: zeppelin-solidity/contracts/token/ERC20/MintableToken.sol

/**
 * @title Mintable token
 * @dev Simple ERC20 Token example, with mintable token creation
 * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
 */
contract MintableToken is StandardToken, Ownable {
  event Mint(address indexed to, uint256 amount);
  event MintFinished();

  bool public mintingFinished = false;


  modifier canMint() {
    require(!mintingFinished);
    _;
  }

  /**
   * @dev Function to mint tokens
   * @param _to The address that will receive the minted tokens.
   * @param _amount The amount of tokens to mint.
   * @return A boolean that indicates if the operation was successful.
   */
  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    Transfer(address(0), _to, _amount);
    return true;
  }

  /**
   * @dev Function to stop minting new tokens.
   * @return True if the operation was successful.
   */
  function finishMinting() onlyOwner canMint public returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
}

// File: contracts/NokuCustomERC20.sol

/**
* @dev The NokuCustomERC20Token contract is a custom ERC20-compliant token available in the Noku Service Platform (NSP).
* The Noku customer is able to choose the token name, symbol, decimals, initial supply and to administer its lifecycle
* by minting or burning tokens in order to increase or decrease the token supply.
*/
contract NokuCustomERC20 is Ownable, DetailedERC20, MintableToken, BurnableToken {
    using SafeMath for uint256;

    event LogNokuCustomERC20Created(
        address indexed caller,
        string indexed name,
        string indexed symbol,
        uint8 decimals,
        address pricingPlan,
        address serviceProvider
    );
    event LogTransferFeePercentageChanged(address indexed caller, uint256 indexed transferFeePercentage);
    event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);

    // The entity acting as Custom token service provider i.e. Noku
    address public serviceProvider;

    // The pricing plan determining the fee to be paid in NOKU tokens by customers for using Noku services
    address public pricingPlan;

    // The fee percentage for Custom token transfer or zero if transfer is free of charge
    uint256 public transferFeePercentage;

    bytes32 public constant CUSTOM_ERC20_BURN_SERVICE_NAME = &amp;quot;NokuCustomERC20.burn&amp;quot;;
    bytes32 public constant CUSTOM_ERC20_MINT_SERVICE_NAME = &amp;quot;NokuCustomERC20.mint&amp;quot;;

    /**
    * @dev Modifier to make a function callable only by service provider i.e. Noku.
    */
    modifier onlyServiceProvider() {
        require(msg.sender == serviceProvider);
        _;
    }

    function NokuCustomERC20(
        string _name,
        string _symbol,
        uint8 _decimals,
        address _pricingPlan,
        address _serviceProvider
    )
    DetailedERC20 (_name, _symbol, _decimals) public
    {
        require(bytes(_name).length &amp;gt; 0);
        require(bytes(_symbol).length &amp;gt; 0);
        require(_pricingPlan != 0);
        require(_serviceProvider != 0);

        pricingPlan = _pricingPlan;
        serviceProvider = _serviceProvider;

        LogNokuCustomERC20Created(
            msg.sender,
            _name,
            _symbol,
            _decimals,
            _pricingPlan,
            _serviceProvider
        );
    }

    function isCustomToken() public pure returns(bool isCustom) {
        return true;
    }

    /**
    * @dev Change the transfer fee percentage to be paid in Custom tokens.
    * @param _transferFeePercentage The fee percentage to be paid for transfer in range [0, 100].
    */
    function setTransferFeePercentage(uint256 _transferFeePercentage) public onlyOwner {
        require(0 &amp;lt;= _transferFeePercentage &amp;amp;&amp;amp; _transferFeePercentage &amp;lt;= 100);
        require(_transferFeePercentage != transferFeePercentage);

        transferFeePercentage = _transferFeePercentage;

        LogTransferFeePercentageChanged(msg.sender, _transferFeePercentage);
    }

    /**
    * @dev Change the pricing plan of service fee to be paid in NOKU tokens.
    * @param _pricingPlan The pricing plan of NOKU token to be paid, zero means flat subscription.
    */
    function setPricingPlan(address _pricingPlan) public onlyServiceProvider {
        require(_pricingPlan != 0);
        require(_pricingPlan != pricingPlan);

        pricingPlan = _pricingPlan;

        LogPricingPlanChanged(msg.sender, _pricingPlan);
    }

    /**
    * @dev Get the fee to be paid for the transfer of NOKU tokens.
    * @param _value The amount of NOKU tokens to be transferred.
    */
    function transferFee(uint256 _value) public view returns (uint256 usageFee) {
        return _value.mul(transferFeePercentage).div(100);
    }

    /**
    * @dev Override #transfer for optionally paying fee to Custom token owner.
    */
    function transfer(address _to, uint256 _value) public returns (bool transferred) {
        if (transferFeePercentage == 0) {
            return super.transfer(_to, _value);
        }
        else {
            uint256 usageFee = transferFee(_value);
            uint256 netValue = _value.sub(usageFee);

            bool feeTransferred = super.transfer(owner, usageFee);
            bool netValueTransferred = super.transfer(_to, netValue);

            return feeTransferred &amp;amp;&amp;amp; netValueTransferred;
        }
    }

    /**
    * @dev Override #transferFrom for optionally paying fee to Custom token owner.
    */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool transferred) {
        if (transferFeePercentage == 0) {
            return super.transferFrom(_from, _to, _value);
        }
        else {
            uint256 usageFee = transferFee(_value);
            uint256 netValue = _value.sub(usageFee);

            bool feeTransferred = super.transferFrom(_from, owner, usageFee);
            bool netValueTransferred = super.transferFrom(_from, _to, netValue);

            return feeTransferred &amp;amp;&amp;amp; netValueTransferred;
        }
    }

    /**
    * @dev Burn a specific amount of tokens, paying the service fee.
    * @param _amount The amount of token to be burned.
    */
    function burn(uint256 _amount) public {
        require(_amount &amp;gt; 0);

        super.burn(_amount);

        require(NokuPricingPlan(pricingPlan).payFee(CUSTOM_ERC20_BURN_SERVICE_NAME, _amount, msg.sender));
    }

    /**
    * @dev Mint a specific amount of tokens, paying the service fee.
    * @param _to The address that will receive the minted tokens.
    * @param _amount The amount of tokens to mint.
    * @return A boolean that indicates if the operation was successful.
    */
    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool minted) {
        require(_to != 0);
        require(_amount &amp;gt; 0);

        super.mint(_to, _amount);

        require(NokuPricingPlan(pricingPlan).payFee(CUSTOM_ERC20_MINT_SERVICE_NAME, _amount, msg.sender));

        return true;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x4c1ef44b89fdadaea76a6a8004a1b7a5b6a7f603.sol" target="_blank" title="show github file">0x4c1ef44b89fdadaea76a6a8004a1b7a5b6a7f603.sol</a>
        </div>
        <div class="path">solidity-files/0x4c1ef44b89fdadaea76a6a8004a1b7a5b6a7f603.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^ 0.4.19;
/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
    address public owner;
    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
  * @dev The Ownable constructor sets the original `owner` of the contract to the sender
  * account.
  */
    function Ownable()public {
        owner = msg.sender;
    }
    /**
  * @dev Throws if called by any account other than the owner.
  */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    /**
  * @dev Allows the current owner to transfer control of the contract to a newOwner.
  * @param newOwner The address to transfer ownership to.
  */
    function transferOwnership(address newOwner)public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    function mul(uint256 a, uint256 b)internal pure returns(uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }
    function div(uint256 a, uint256 b)internal pure returns(uint256) {
        assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b);  There is no case in which this doesn&amp;#39;t hold
        return c;
    }
    function sub(uint256 a, uint256 b)internal pure returns(uint256) {
        assert(b &amp;lt;= a);
        return a - b;
    }
    function add(uint256 a, uint256 b)internal pure returns(uint256) {
        uint256 c = a + b;
        assert(c &amp;gt;= a);
        return c;
    }
}
/**
 * @title Destructible
 * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.
 */
contract Destructible is Ownable {

  function Destructible() public payable { }

  /**
   * @dev Transfers the current balance to the owner and terminates the contract.
   */
  function destroy() onlyOwner public {
    selfdestruct(owner);
  }

  function destroyAndSend(address _recipient) onlyOwner public {
    selfdestruct(_recipient);
  }
}

/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Destructible {
    event Pause();
    event Unpause();
    bool public paused = false;
    /**
  * @dev Modifier to make a function callable only when the contract is not paused.
  */
    modifier whenNotPaused() {
        require(!paused);
        _;
    }
    /**
  * @dev Modifier to make a function callable only when the contract is paused.
  */
    modifier whenPaused() {
        require(paused);
        _;
    }
    /**
  * @dev called by the owner to pause, triggers stopped state
  */
    function pause()onlyOwner whenNotPaused public {
        paused = true;
        emit Pause();
    }
    /**
  * @dev called by the owner to unpause, returns to normal state
  */
    function unpause()onlyOwner whenPaused public {
        paused = false;
        emit Unpause();
    }
}

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 */
contract ERC20Basic {
    uint256 public totalSupply;
    uint256 public completeRemainingTokens;
    function balanceOf(address who)public view returns(uint256);
    function transfer(address to, uint256 value)public returns(bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}
/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic,
Pausable {
    uint256 startPreSale; uint256 endPreSale; uint256 startSale; 
    uint256 endSale; 
    using SafeMath for uint256; mapping(address =&amp;gt; uint256)balances; uint256 preICOReserveTokens; uint256 icoReserveTokens; 
    address businessReserveAddress; uint256 public timeLock = 1586217600; //7 April 2020 locked
    uint256 public incentiveTokensLimit;
    modifier checkAdditionalTokenLock(uint256 value) {

        if (msg.sender == businessReserveAddress) {
            
            if ((now&amp;lt;endSale) ||(now &amp;lt; timeLock &amp;amp;&amp;amp;value&amp;gt;incentiveTokensLimit)) {
                revert();
            } else {
                _;
            }
        } else {
            _;
        }

    }
    
    function updateTimeLock(uint256 _timeLock) external onlyOwner {
        timeLock = _timeLock;
    }
    function updateBusinessReserveAddress(address _businessAddress) external onlyOwner {
        businessReserveAddress =_businessAddress;
    }
    
    function updateIncentiveTokenLimit(uint256 _incentiveTokens) external onlyOwner {
      incentiveTokensLimit = _incentiveTokens;
   }    
    /**
 * @dev transfer token for a specified address
 * @param _to The address to transfer to.
 * @param _value The amount to be transferred.
 */
    function transfer(address _to, uint256 _value)public whenNotPaused checkAdditionalTokenLock(_value) returns(
        bool
    ) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[msg.sender]);
        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
 * @dev Gets the balance of the specified address.
 * @param _owner The address to query the the balance of.
 * @return An uint256 representing the amount owned by the passed address.
 */
    function balanceOf(address _owner)public constant returns(uint256 balance) {
        return balances[_owner];
    }
}
/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender)public view returns(uint256);
    function transferFrom(address from, address to, uint256 value)public returns(
        bool
    );
    function approve(address spender, uint256 value)public returns(bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
/**
 * @title Burnable Token
 * @dev Token that can be irreversibly burned (destroyed).
 */
contract BurnableToken is BasicToken {

    event Burn(address indexed burner, uint256 value);

    /**
   * @dev Burns a all amount of tokens of address.
   */
    function burn()public {
        uint256 _value = balances[msg.sender];
        // no need to require value &amp;lt;= totalSupply, since that would imply the sender&amp;#39;s
        // balance is greater than the totalSupply, which *should* be an assertion
        // failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(burner, _value);
        emit Transfer(burner, address(0), _value);
    }
}

contract StandardToken is ERC20,BurnableToken {
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint256))internal allowed;

    /**
  * @dev Transfer tokens from one address to another
  * @param _from address The address which you want to send tokens from
  * @param _to address The address which you want to transfer to
  * @param _value uint256 the amount of tokens to be transferred
  */
    function transferFrom(address _from, address _to, uint256 _value)public whenNotPaused checkAdditionalTokenLock(_value) returns(
        bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[_from]);
        require(_value &amp;lt;= allowed[_from][msg.sender]);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
    /**
  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
  *
  * Beware that changing an allowance with this method brings the risk that someone may use both the old
  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
  * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
  * @param _spender The address which will spend the funds.
  * @param _value The amount of tokens to be spent.
  */
    function approve(address _spender, uint256 _value)public checkAdditionalTokenLock(_value) returns(
        bool
    ) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    /**
  * @dev Function to check the amount of tokens that an owner allowed to a spender.
  * @param _owner address The address which owns the funds.
  * @param _spender address The address which will spend the funds.
  * @return A uint256 specifying the amount of tokens still available for the spender.
  */
    function allowance(address _owner, address _spender)public constant returns(
        uint256 remaining
    ) {
        return allowed[_owner][_spender];
    }
    /**
  * approve should be called when allowed[_spender] == 0. To increment
  * allowed value is better to use this function to avoid 2 calls (and wait until
  * the first transaction is mined)
  * From MonolithDAO Token.sol
  */
    function increaseApproval(address _spender, uint _addedValue)public checkAdditionalTokenLock(_addedValue) returns(
        bool success
    ) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
    function decreaseApproval(address _spender, uint _subtractedValue)public returns(
        bool success
    ) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue &amp;gt; oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}
contract SMRTCoin is StandardToken {
    string public constant name = &amp;quot;SMRT&amp;quot;;
    uint public constant decimals = 18;
    string public constant symbol = &amp;quot;SMRT&amp;quot;;
    using SafeMath for uint256; uint256 public weiRaised = 0; address depositWalletAddress; 
    event Buy(address _from, uint256 _ethInWei, string userId); 
    
    function SMRTCoin()public {
        owner = msg.sender;
        totalSupply = 600000000 * (10 ** decimals);
        preICOReserveTokens = 90000000 * (10 ** decimals);
        icoReserveTokens = 210000000 * (10 ** decimals);
        depositWalletAddress = 0x85a98805C17701504C252eAAB99f60C7c204A785; //TODO change
        businessReserveAddress = 0x73FEC20272a555Af1AEA4bF27D406683632c2a8c; 
        balances[owner] = totalSupply;
        emit Transfer(address(0), owner, totalSupply);
        startPreSale = now; //TODO update 1521900000 24 march 14 00 00 UTC
        endPreSale = 1524319200; //21 April 14 00 00 utc
        startSale = endPreSale + 1;
        endSale = startSale + 30 days;
    }
    function ()public {
        revert();
    }
    /**
   * This will be called by adding data to represnet data.
   */
    function buy(string userId)public payable whenNotPaused {
        require(msg.value &amp;gt; 0);
        require(msg.sender != address(0));
        weiRaised += msg.value;
        forwardFunds();
        emit Buy(msg.sender, msg.value, userId);
    }
    /**
   * This function will called by only distributors to send tokens by calculating from offchain listners
   */
    function getBonustokens(uint256 tokens)internal returns(uint256 bonusTokens) {
        require(now &amp;lt;= endSale);
        uint256 bonus;
        if (now &amp;lt;= endPreSale) {
            bonus = 50;
        } else if (now &amp;lt; startSale + 1 weeks) {
            bonus = 10;
        } else if (now &amp;lt; startSale + 2 weeks) {
            bonus = 5;
        }

        bonusTokens = ((tokens / 100) * bonus);
    }
    function CrowdSale(address recieverAddress, uint256 tokens)public onlyOwner {
        tokens =  tokens.add(getBonustokens(tokens));
        uint256 tokenLimit = (tokens.mul(20)).div(100); //as 20 becuase its 10 percnet of total
        incentiveTokensLimit  = incentiveTokensLimit.add(tokenLimit);
        if (now &amp;lt;= endPreSale &amp;amp;&amp;amp; preICOReserveTokens &amp;gt;= tokens) {
            preICOReserveTokens = preICOReserveTokens.sub(tokens);
            transfer(businessReserveAddress, tokens);
            transfer(recieverAddress, tokens);
        } else if (now &amp;lt; endSale &amp;amp;&amp;amp; icoReserveTokens &amp;gt;= tokens) {
            icoReserveTokens = icoReserveTokens.sub(tokens);
            transfer(businessReserveAddress, tokens);
            transfer(recieverAddress, tokens);
        }
        else{ 
            revert();
        }
    }
    /**
  * @dev Determines how ETH is stored/forwarded on purchases.
  */
    function forwardFunds()internal {
        depositWalletAddress.transfer(msg.value);
    }
    function changeDepositWalletAddress(address newDepositWalletAddr)external onlyOwner {
        require(newDepositWalletAddr != 0);
        depositWalletAddress = newDepositWalletAddr;
    }
    function updateSaleTime(uint256 _startSale, uint256 _endSale)external onlyOwner {
        startSale = _startSale;
        endSale = _endSale;
    }

 

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x4554134be58f741605c5f04fa9cc69ba955c76e6.sol" target="_blank" title="show github file">0x4554134be58f741605c5f04fa9cc69ba955c76e6.sol</a>
        </div>
        <div class="path">solidity-files/0x4554134be58f741605c5f04fa9cc69ba955c76e6.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

contract IGold {
    function balanceOf(address _owner) constant returns (uint256);
    function issueTokens(address _who, uint _tokens);
    function burnTokens(address _who, uint _tokens);
}

// StdToken inheritance is commented, because no &amp;#39;totalSupply&amp;#39; needed
contract IMNTP { /*is StdToken */
    function balanceOf(address _owner) constant returns (uint256);

    // Additional methods that MNTP contract provides
    function lockTransfer(bool _lock);
    function issueTokens(address _who, uint _tokens);
    function burnTokens(address _who, uint _tokens);
}

contract SafeMath {
    function safeAdd(uint a, uint b) internal returns (uint) {
        uint c = a + b;
        assert(c&amp;gt;=a &amp;amp;&amp;amp; c&amp;gt;=b);
        return c;
     }

    function safeSub(uint a, uint b) internal returns (uint) {
        assert(b &amp;lt;= a);
        return a - b;
    }
}

contract CreatorEnabled {
    address public creator = 0x0;

    modifier onlyCreator() { require(msg.sender == creator); _; }

    function changeCreator(address _to) public onlyCreator {
        creator = _to;
    }
}

contract StringMover {
    function stringToBytes32(string s) constant returns(bytes32){
        bytes32 out;
        assembly {
             out := mload(add(s, 32))
        }
        return out;
    }

    function stringToBytes64(string s) constant returns(bytes32,bytes32){
        bytes32 out;
        bytes32 out2;

        assembly {
             out := mload(add(s, 32))
             out2 := mload(add(s, 64))
        }
        return (out,out2);
    }

    function bytes32ToString(bytes32 x) constant returns (string) {
        bytes memory bytesString = new bytes(32);
        uint charCount = 0;
        for (uint j = 0; j &amp;lt; 32; j++) {
             byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
             if (char != 0) {
                  bytesString[charCount] = char;
                  charCount++;
             }
        }
        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (j = 0; j &amp;lt; charCount; j++) {
             bytesStringTrimmed[j] = bytesString[j];
        }
        return string(bytesStringTrimmed);
    }

    function bytes64ToString(bytes32 x, bytes32 y) constant returns (string) {
        bytes memory bytesString = new bytes(64);
        uint charCount = 0;

        for (uint j = 0; j &amp;lt; 32; j++) {
             byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
             if (char != 0) {
                  bytesString[charCount] = char;
                  charCount++;
             }
        }
        for (j = 0; j &amp;lt; 32; j++) {
             char = byte(bytes32(uint(y) * 2 ** (8 * j)));
             if (char != 0) {
                  bytesString[charCount] = char;
                  charCount++;
             }
        }

        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (j = 0; j &amp;lt; charCount; j++) {
             bytesStringTrimmed[j] = bytesString[j];
        }
        return string(bytesStringTrimmed);
    }
}


contract Storage is SafeMath, StringMover {
    function Storage() public {
        controllerAddress = msg.sender;
    }

    address public controllerAddress = 0x0;
    modifier onlyController() { require(msg.sender==controllerAddress); _; }

    function setControllerAddress(address _newController) onlyController {
        controllerAddress = _newController;
    }

    address public hotWalletAddress = 0x0;

    function setHotWalletAddress(address _address) onlyController {
       hotWalletAddress = _address;
    }


    // Fields - 1
    mapping(uint =&amp;gt; string) docs;
    uint public docCount = 0;

    // Fields - 2
    mapping(string =&amp;gt; mapping(uint =&amp;gt; int)) fiatTxs;
    mapping(string =&amp;gt; uint) fiatBalancesCents;
    mapping(string =&amp;gt; uint) fiatTxCounts;
    uint fiatTxTotal = 0;

    // Fields - 3
    mapping(string =&amp;gt; mapping(uint =&amp;gt; int)) goldTxs;
    mapping(string =&amp;gt; uint) goldHotBalances;
    mapping(string =&amp;gt; uint) goldTxCounts;
    uint goldTxTotal = 0;

    // Fields - 4
    struct Request {
        address sender;
        string userId;
        string requestHash;
        bool buyRequest;         // otherwise - sell

        // 0 - init
        // 1 - processed
        // 2 - cancelled
        uint8 state;
    }

    mapping (uint=&amp;gt;Request) requests;
    uint public requestsCount = 0;

    ///////
    function addDoc(string _ipfsDocLink) public onlyController returns(uint) {
        docs[docCount] = _ipfsDocLink;
        uint out = docCount;
        docCount++;

        return out;
    }

    function getDocCount() public constant returns (uint) {
        return docCount;
    }

    function getDocAsBytes64(uint _index) public constant returns (bytes32,bytes32) {
        require(_index &amp;lt; docCount);
        return stringToBytes64(docs[_index]);
    }

    function addFiatTransaction(string _userId, int _amountCents) public onlyController returns(uint) {
        require(0 != _amountCents);

        uint c = fiatTxCounts[_userId];

        fiatTxs[_userId][c] = _amountCents;

        if (_amountCents &amp;gt; 0) {
            fiatBalancesCents[_userId] = safeAdd(fiatBalancesCents[_userId], uint(_amountCents));
        } else {
            fiatBalancesCents[_userId] = safeSub(fiatBalancesCents[_userId], uint(-_amountCents));
        }

        fiatTxCounts[_userId] = safeAdd(fiatTxCounts[_userId], 1);

        fiatTxTotal++;
        return c;
    }

    function getFiatTransactionsCount(string _userId) public constant returns (uint) {
        return fiatTxCounts[_userId];
    }

    function getAllFiatTransactionsCount() public constant returns (uint) {
        return fiatTxTotal;
    }

    function getFiatTransaction(string _userId, uint _index) public constant returns(int) {
        require(_index &amp;lt; fiatTxCounts[_userId]);
        return fiatTxs[_userId][_index];
    }

    function getUserFiatBalance(string _userId) public constant returns(uint) {
        return fiatBalancesCents[_userId];
    }

    function addGoldTransaction(string _userId, int _amount) public onlyController returns(uint) {
        require(0 != _amount);

        uint c = goldTxCounts[_userId];

        goldTxs[_userId][c] = _amount;

        if (_amount &amp;gt; 0) {
            goldHotBalances[_userId] = safeAdd(goldHotBalances[_userId], uint(_amount));
        } else {
            goldHotBalances[_userId] = safeSub(goldHotBalances[_userId], uint(-_amount));
        }

        goldTxCounts[_userId] = safeAdd(goldTxCounts[_userId], 1);

        goldTxTotal++;
        return c;
    }

    function getGoldTransactionsCount(string _userId) public constant returns (uint) {
        return goldTxCounts[_userId];
    }

    function getAllGoldTransactionsCount() public constant returns (uint) {
        return goldTxTotal;
    }

    function getGoldTransaction(string _userId, uint _index) public constant returns(int) {
        require(_index &amp;lt; goldTxCounts[_userId]);
        return goldTxs[_userId][_index];
    }

    function getUserHotGoldBalance(string _userId) public constant returns(uint) {
        return goldHotBalances[_userId];
    }

    function addBuyTokensRequest(address _who, string _userId, string _requestHash) public onlyController returns(uint) {
        Request memory r;
        r.sender = _who;
        r.userId = _userId;
        r.requestHash = _requestHash;
        r.buyRequest = true;
        r.state = 0;

        requests[requestsCount] = r;
        uint out = requestsCount;
        requestsCount++;
        return out;
    }

    function addSellTokensRequest(address _who, string _userId, string _requestHash) onlyController returns(uint) {
        Request memory r;
        r.sender = _who;
        r.userId = _userId;
        r.requestHash = _requestHash;
        r.buyRequest = false;
        r.state = 0;

        requests[requestsCount] = r;
        uint out = requestsCount;
        requestsCount++;
        return out;
    }

    function getRequestsCount() public constant returns(uint) {
        return requestsCount;
    }

    function getRequest(uint _index) public constant returns(
        address a,
        bytes32 userId,
        bytes32 hashA, bytes32 hashB,
        bool buy, uint8 state)
    {
        require(_index &amp;lt; requestsCount);

        Request memory r = requests[_index];

        bytes32 userBytes = stringToBytes32(r.userId);
        var (out1, out2) = stringToBytes64(r.requestHash);

        return (r.sender, userBytes, out1, out2, r.buyRequest, r.state);
    }

    function cancelRequest(uint _index) onlyController public {
        require(_index &amp;lt; requestsCount);
        require(0==requests[_index].state);

        requests[_index].state = 2;
    }

    function setRequestProcessed(uint _index) onlyController public {
        requests[_index].state = 1;
    }
}

contract GoldFiatFee is CreatorEnabled, StringMover {
    string gmUserId = &amp;quot;&amp;quot;;

    // Functions:
    function GoldFiatFee(string _gmUserId) {
        creator = msg.sender;
        gmUserId = _gmUserId;
    }

    function getGoldmintFeeAccount() public constant returns(bytes32) {
        bytes32 userBytes = stringToBytes32(gmUserId);
        return userBytes;
    }

    function setGoldmintFeeAccount(string _gmUserId) public onlyCreator {
        gmUserId = _gmUserId;
    }

    function calculateBuyGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint) {
        return 0;
    }

    function calculateSellGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint) {
        // If the sender holds 0 MNTP, then the transaction fee is 3% fiat,
        // If the sender holds at least 10 MNTP, then the transaction fee is 2% fiat,
        // If the sender holds at least 1000 MNTP, then the transaction fee is 1.5% fiat,
        // If the sender holds at least 10000 MNTP, then the transaction fee is 1% fiat,
        if (_mntpBalance &amp;gt;= (10000 * 1 ether)) {
             return (75 * _goldValue / 10000);
        }

        if (_mntpBalance &amp;gt;= (1000 * 1 ether)) {
             return (15 * _goldValue / 1000);
        }

        if (_mntpBalance &amp;gt;= (10 * 1 ether)) {
             return (25 * _goldValue / 1000);
        }

        // 3%
        return (3 * _goldValue / 100);
    }
}

contract IGoldFiatFee {
    function getGoldmintFeeAccount()public constant returns(bytes32);
    function calculateBuyGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint);
    function calculateSellGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint);
}

contract StorageController is SafeMath, CreatorEnabled, StringMover {
    Storage public stor;
    IMNTP public mntpToken;
    IGold public goldToken;
    IGoldFiatFee public fiatFee;

    address public ethDepositAddress = 0x0;
    address public managerAddress = 0x0;

    event NewTokenBuyRequest(address indexed _from, string indexed _userId);
    event NewTokenSellRequest(address indexed _from, string indexed _userId);
    event RequestCancelled(uint indexed _reqId);
    event RequestProcessed(uint indexed _reqId);
    event EthDeposited(uint indexed _requestId, address indexed _address, uint _ethValue);

    modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }

    function StorageController(address _mntpContractAddress, address _goldContractAddress, address _storageAddress, address _fiatFeeContract) {
        creator = msg.sender;

        if (0 != _storageAddress) {
             // use existing storage
             stor = Storage(_storageAddress);
        } else {
             stor = new Storage();
        }

        require(0x0!=_mntpContractAddress);
        require(0x0!=_goldContractAddress);
        require(0x0!=_fiatFeeContract);

        mntpToken = IMNTP(_mntpContractAddress);
        goldToken = IGold(_goldContractAddress);
        fiatFee = IGoldFiatFee(_fiatFeeContract);
    }

    function setEthDepositAddress(address _address) public onlyCreator {
       ethDepositAddress = _address;
    }

    function setManagerAddress(address _address) public onlyCreator {
       managerAddress = _address;
    }

    function getEthDepositAddress() public constant returns (address) {
       return ethDepositAddress;
    }

    // Only old controller can call setControllerAddress
    function changeController(address _newController) public onlyCreator {
        stor.setControllerAddress(_newController);
    }

    function setHotWalletAddress(address _hotWalletAddress) public onlyCreator {
       stor.setHotWalletAddress(_hotWalletAddress);
    }

    function getHotWalletAddress() public constant returns (address) {
        return stor.hotWalletAddress();
    }

    function changeFiatFeeContract(address _newFiatFee) public onlyCreator {
        fiatFee = IGoldFiatFee(_newFiatFee);
    }

    function addDoc(string _ipfsDocLink) public onlyCreator returns(uint) {
        return stor.addDoc(_ipfsDocLink);
    }

    function getDocCount() public constant returns (uint) {
        return stor.docCount();
    }

    function getDoc(uint _index) public constant returns (string) {
        var (x, y) = stor.getDocAsBytes64(_index);
        return bytes64ToString(x,y);
    }


    // _amountCents can be negative
    // returns index in user array
    function addFiatTransaction(string _userId, int _amountCents) public onlyManagerOrCreator returns(uint) {
        return stor.addFiatTransaction(_userId, _amountCents);
    }

    function getFiatTransactionsCount(string _userId) public constant returns (uint) {
        return stor.getFiatTransactionsCount(_userId);
    }

    function getAllFiatTransactionsCount() public constant returns (uint) {
        return stor.getAllFiatTransactionsCount();
    }

    function getFiatTransaction(string _userId, uint _index) public constant returns(int) {
        return stor.getFiatTransaction(_userId, _index);
    }

    function getUserFiatBalance(string _userId) public constant returns(uint) {
        return stor.getUserFiatBalance(_userId);
    }

    function addGoldTransaction(string _userId, int _amount) public onlyManagerOrCreator returns(uint) {
        return stor.addGoldTransaction(_userId, _amount);
    }

    function getGoldTransactionsCount(string _userId) public constant returns (uint) {
        return stor.getGoldTransactionsCount(_userId);
    }

    function getAllGoldTransactionsCount() public constant returns (uint) {
        return stor.getAllGoldTransactionsCount();
    }

    function getGoldTransaction(string _userId, uint _index) public constant returns(int) {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        return stor.getGoldTransaction(_userId, _index);
    }

    function getUserHotGoldBalance(string _userId) public constant returns(uint) {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        return stor.getUserHotGoldBalance(_userId);
    }


    function addBuyTokensRequest(string _userId, string _requestHash) public returns(uint) {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        NewTokenBuyRequest(msg.sender, _userId);
        return stor.addBuyTokensRequest(msg.sender, _userId, _requestHash);
    }

    function addSellTokensRequest(string _userId, string _requestHash) public returns(uint) {
      require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

      NewTokenSellRequest(msg.sender, _userId);

    return stor.addSellTokensRequest(msg.sender, _userId, _requestHash);
    }

    function getRequestsCount() public constant returns(uint) {
        return stor.getRequestsCount();
    }

    function getRequest(uint _index) public constant returns(address, string, string, bool, uint8) {
        var (sender, userIdBytes, hashA, hashB, buy, state) = stor.getRequest(_index);

        string memory userId = bytes32ToString(userIdBytes);
        string memory hash = bytes64ToString(hashA, hashB);

        return (sender, userId, hash, buy, state);
    }

    function cancelRequest(uint _index) onlyManagerOrCreator public {
        RequestCancelled(_index);
        stor.cancelRequest(_index);
    }

    function processRequest(uint _index, uint _amountCents, uint _centsPerGold) onlyManagerOrCreator public {
        require(_index &amp;lt; getRequestsCount());

        var (sender, userId, hash, isBuy, state) = getRequest(_index);
        require(0 == state);

        if (isBuy) {
             processBuyRequest(userId, sender, _amountCents, _centsPerGold);
        } else {
             processSellRequest(userId, sender, _amountCents, _centsPerGold);
        }

        // 3 - update state
        stor.setRequestProcessed(_index);

        // 4 - send event
        RequestProcessed(_index);
    }

    function processBuyRequest(string _userId, address _userAddress, uint _amountCents, uint _centsPerGold) internal {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        uint userFiatBalance = getUserFiatBalance(_userId);
        require(userFiatBalance &amp;gt; 0);

        if (_amountCents &amp;gt; userFiatBalance) {
             _amountCents = userFiatBalance;
        }

        uint userMntpBalance = mntpToken.balanceOf(_userAddress);
        uint fee = fiatFee.calculateBuyGoldFee(userMntpBalance, _amountCents);
        require(_amountCents &amp;gt; fee);

        // 1 - issue tokens minus fee
        uint amountMinusFee = _amountCents;
        if (fee &amp;gt; 0) {
             amountMinusFee = safeSub(_amountCents, fee);
        }

        require(amountMinusFee &amp;gt; 0);

        uint tokens = (uint(amountMinusFee) * 1 ether) / _centsPerGold;
        issueGoldTokens(_userAddress, tokens);

        // request from hot wallet
        if (isHotWallet(_userAddress)) {
          addGoldTransaction(_userId, int(tokens));
        }

        // 2 - add fiat tx
        // negative for buy (total amount including fee!)
        addFiatTransaction(_userId, - int(_amountCents));

        // 3 - send fee to Goldmint
        // positive for sell
        if (fee &amp;gt; 0) {
             string memory gmAccount = bytes32ToString(fiatFee.getGoldmintFeeAccount());
             addFiatTransaction(gmAccount, int(fee));
        }
    }

    function processSellRequest(string _userId, address _userAddress, uint _amountCents, uint _centsPerGold) internal {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        uint tokens = (uint(_amountCents) * 1 ether) / _centsPerGold;
        uint tokenBalance = goldToken.balanceOf(_userAddress);

        if (isHotWallet(_userAddress)) {
            tokenBalance = getUserHotGoldBalance(_userId);
        }

        if (tokenBalance &amp;lt; tokens) {
             tokens = tokenBalance;
             _amountCents = uint((tokens * _centsPerGold) / 1 ether);
        }

        burnGoldTokens(_userAddress, tokens);

        // request from hot wallet
        if (isHotWallet(_userAddress)) {
          addGoldTransaction(_userId, - int(tokens));
        }

        // 2 - add fiat tx
        uint userMntpBalance = mntpToken.balanceOf(_userAddress);
        uint fee = fiatFee.calculateSellGoldFee(userMntpBalance, _amountCents);
        require(_amountCents &amp;gt; fee);

        uint amountMinusFee = _amountCents;

        if (fee &amp;gt; 0) {
             amountMinusFee = safeSub(_amountCents, fee);
        }

        require(amountMinusFee &amp;gt; 0);
        // positive for sell
        addFiatTransaction(_userId, int(amountMinusFee));

        // 3 - send fee to Goldmint
        if (fee &amp;gt; 0) {
             string memory gmAccount = bytes32ToString(fiatFee.getGoldmintFeeAccount());
             addFiatTransaction(gmAccount, int(fee));
        }
    }

    //////// INTERNAL REQUESTS FROM HOT WALLET
    function processInternalRequest(string _userId, bool _isBuy, uint _amountCents, uint _centsPerGold) onlyManagerOrCreator public {
      if (_isBuy) {
          processBuyRequest(_userId, getHotWalletAddress(), _amountCents, _centsPerGold);
      } else {
          processSellRequest(_userId, getHotWalletAddress(), _amountCents, _centsPerGold);
      }
    }

    function transferGoldFromHotWallet(address _to, uint _value, string _userId) onlyManagerOrCreator public {
      require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

      uint balance = getUserHotGoldBalance(_userId);
      require(balance &amp;gt;= _value);

      goldToken.burnTokens(getHotWalletAddress(), _value);
      goldToken.issueTokens(_to, _value);

      addGoldTransaction(_userId, -int(_value));
    }

    ////////
    function issueGoldTokens(address _userAddress, uint _tokenAmount) internal {
        require(0!=_tokenAmount);
        goldToken.issueTokens(_userAddress, _tokenAmount);
    }

    function burnGoldTokens(address _userAddress, uint _tokenAmount) internal {
        require(0!=_tokenAmount);
        goldToken.burnTokens(_userAddress, _tokenAmount);
    }

    function isHotWallet(address _address) internal returns(bool) {
       return _address == getHotWalletAddress();
    }

    ///////
    function depositEth(uint _requestId) public payable {
      require(ethDepositAddress != 0x0);
      //min deposit is 0.01 ETH
      require(msg.value &amp;gt;= 0.01 * 1 ether);

      ethDepositAddress.transfer(msg.value);

      EthDeposited(_requestId, msg.sender, msg.value);
    }

    // do not allow to send money to this contract...
    function() external payable {
      revert();
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x449f5c827cf7726cc5f181090aa147ca5fb88a40.sol" target="_blank" title="show github file">0x449f5c827cf7726cc5f181090aa147ca5fb88a40.sol</a>
        </div>
        <div class="path">solidity-files/0x449f5c827cf7726cc5f181090aa147ca5fb88a40.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

/// @title ERC-721 Non-Fungible Token Standard
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
///  Note: the ERC-165 identifier for this interface is 0x80ac58cd
interface ERC721 /* is ERC165 */ {
    /// @dev This emits when ownership of any NFT changes by any mechanism.
    ///  This event emits when NFTs are created (`from` == 0) and destroyed
    ///  (`to` == 0). Exception: during contract creation, any number of NFTs
    ///  may be created and assigned without emitting Transfer. At the time of
    ///  any transfer, the approved address for that NFT (if any) is reset to none.
    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);

    /// @dev This emits when the approved address for an NFT is changed or
    ///  reaffirmed. The zero address indicates there is no approved address.
    ///  When a Transfer event emits, this also indicates that the approved
    ///  address for that NFT (if any) is reset to none.
    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);

    /// @dev This emits when an operator is enabled or disabled for an owner.
    ///  The operator can manage all NFTs of the owner.
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    /// @notice Count all NFTs assigned to an owner
    /// @dev NFTs assigned to the zero address are considered invalid, and this
    ///  function throws for queries about the zero address.
    /// @param _owner An address for whom to query the balance
    /// @return The number of NFTs owned by `_owner`, possibly zero
    function balanceOf(address _owner) external view returns (uint256);

    /// @notice Find the owner of an NFT
    /// @param _tokenId The identifier for an NFT
    /// @dev NFTs assigned to zero address are considered invalid, and queries
    ///  about them do throw.
    /// @return The address of the owner of the NFT
    function ownerOf(uint256 _tokenId) external view returns (address);

    /// @notice Transfers the ownership of an NFT from one address to another address
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function
    ///  checks if `_to` is a smart contract (code size &amp;gt; 0). If so, it calls
    ///  `onERC721Received` on `_to` and throws if the return value is not
    ///  `bytes4(keccak256(&amp;quot;onERC721Received(address,uint256,bytes)&amp;quot;))`.
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    /// @param data Additional data with no specified format, sent in call to `_to`
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external;

    /// @notice Transfers the ownership of an NFT from one address to another address
    /// @dev This works identically to the other function with an extra data parameter,
    ///  except this function just sets data to &amp;quot;&amp;quot;
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
    ///  THEY MAY BE PERMANENTLY LOST
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT.
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice Set or reaffirm the approved address for an NFT
    /// @dev The zero address indicates there is no approved address.
    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized
    ///  operator of the current owner.
    /// @param _approved The new approved NFT controller
    /// @param _tokenId The NFT to approve
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice Enable or disable approval for a third party (&amp;quot;operator&amp;quot;) to manage
    ///  all your assets.
    /// @dev Throws unless `msg.sender` is the current NFT owner.
    /// @dev Emits the ApprovalForAll event
    /// @param _operator Address to add to the set of authorized operators.
    /// @param _approved True if the operators is approved, false to revoke approval
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice Get the approved address for a single NFT
    /// @dev Throws if `_tokenId` is not a valid NFT
    /// @param _tokenId The NFT to find the approved address for
    /// @return The approved address for this NFT, or the zero address if there is none
    function getApproved(uint256 _tokenId) external view returns (address);

    /// @notice Query if an address is an authorized operator for another address
    /// @param _owner The address that owns the NFTs
    /// @param _operator The address that acts on behalf of the owner
    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);
}

/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
///  Note: the ERC-165 identifier for this interface is 0x780e9d63
interface ERC721Enumerable /* is ERC721 */ {
  /// @notice Count NFTs tracked by this contract
  /// @return A count of valid NFTs tracked by this contract, where each one of
  ///  them has an assigned and queryable owner not equal to the zero address
  function totalSupply() external view returns (uint256);

  /// @notice Enumerate valid NFTs
  /// @dev Throws if `_index` &amp;gt;= `totalSupply()`.
  /// @param _index A counter less than `totalSupply()`
  /// @return The token identifier for the `_index`th NFT,
  ///  (sort order not specified)
  function tokenByIndex(uint256 _index) external view returns (uint256);

  /// @notice Enumerate NFTs assigned to an owner
  /// @dev Throws if `_index` &amp;gt;= `balanceOf(_owner)` or if
  ///  `_owner` is the zero address, representing invalid NFTs.
  /// @param _owner An address where we are interested in NFTs owned by them
  /// @param _index A counter less than `balanceOf(_owner)`
  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,
  ///   (sort order not specified)
  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);
}

/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
///  Note: the ERC-165 identifier for this interface is 0x5b5e139f
interface ERC721Metadata /* is ERC721 */ {
    /// @notice A descriptive name for a collection of NFTs in this contract
    function name() external pure returns (string _name);

    /// @notice An abbreviated name for NFTs in this contract
    function symbol() external pure returns (string _symbol);

    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC
    ///  3986. The URI may point to a JSON file that conforms to the &amp;quot;ERC721
    ///  Metadata JSON Schema&amp;quot;.
    function tokenURI(uint256 _tokenId) external view returns (string);
}

/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba
interface ERC721TokenReceiver {
    /// @notice Handle the receipt of an NFT
    /// @dev The ERC721 smart contract calls this function on the recipient
    ///  after a `transfer`. This function MAY throw to revert and reject the
    ///  transfer. This function MUST use 50,000 gas or less. Return of other
    ///  than the magic value MUST result in the transaction being reverted.
    ///  Note: the contract address is always the message sender.
    /// @param _from The sending address 
    /// @param _tokenId The NFT identifier which is being transferred
    /// @param data Additional data with no specified format
    /// @return `bytes4(keccak256(&amp;quot;onERC721Received(address,uint256,bytes)&amp;quot;))`
    ///  unless throwing
    function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);
}

contract Ownable {
    address private owner;

    event LogOwnerChange(address _owner);

    // Modify method to only allow calls from the owner of the contract.
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function Ownable() public {
        owner = msg.sender;
    }

    /**
     * Replace the contract owner with a new owner.
     *
     * Parameters
     * ----------
     * _owner : address
     *     The address to replace the current owner with.
     */
    function replaceOwner(address _owner) external onlyOwner {
        owner = _owner;

        LogOwnerChange(_owner);
    }
}

contract Controllable is Ownable {
    // Mapping of a contract address to its position in the list of active
    // contracts. This allows an O(1) look-up of the contract address compared
    // to a linear search within an array.
    mapping(address =&amp;gt; uint256) private contractIndices;

    // The list of contracts that are allowed to call the contract-restricted
    // methods of contracts that extend this `Controllable` contract.
    address[] private contracts;

    /**
     * Modify method to only allow calls from active contract addresses.
     *
     * Notes
     * -----
     * The zero address is considered an inactive address, as it is impossible
     * for users to send a call from that address.
     */
    modifier onlyActiveContracts() {
        require(contractIndices[msg.sender] != 0);
        _;
    }

    function Controllable() public Ownable() {
        // The zeroth index of the list of active contracts is occupied by the
        // zero address to ensure that an index of zero can be used to indicate
        // that the contract address is inactive.
        contracts.push(address(0));
    }

    /**
     * Add a contract address to the list of active contracts.
     *
     * Parameters
     * ----------
     * _address : address
     *     The contract address to add to the list of active contracts.
     */
    function activateContract(address _address) external onlyOwner {
        require(contractIndices[_address] == 0);

        contracts.push(_address);

        // The index of the newly added contract is equal to the length of the
        // array of active contracts minus one, as Solidity is a zero-based
        // language.
        contractIndices[_address] = contracts.length - 1;
    }

    /**
     * Remove a contract address from the list of active contracts.
     *
     * Parameters
     * ----------
     * _address : address
     *     The contract address to remove from the list of active contracts.
     */
    function deactivateContract(address _address) external onlyOwner {
        require(contractIndices[_address] != 0);

        // Get the last contract in the array of active contracts. This address
        // will be used to overwrite the address that will be removed.
        address lastActiveContract = contracts[contracts.length - 1];

        // Overwrite the address that is to be removed with the value of the
        // last contract in the list. There is a possibility that these are the
        // same values, in which case nothing happens.
        contracts[contractIndices[_address]] = lastActiveContract;

        // Reduce the contracts array size by one, as the last contract address
        // will have been successfully moved.
        contracts.length--;

        // Set the address mapping to zero, effectively rendering the contract
        // banned from calling this contract.
        contractIndices[_address] = 0;
    }

    /**
     * Get the list of active contracts for this contract.
     *
     * Returns
     * -------
     * address[]
     *     The list of contract addresses that are allowed to call the
     *     contract-restricted methods of this contract.
     */
    function getActiveContracts() external view returns (address[]) {
        return contracts;
    }
}

library Tools {
    /**
     * Concatenate two strings.
     *
     * Parameters
     * ----------
     * stringLeft : string
     *     A string to concatenate with another string. This is the left part.
     * stringRight : string
     *     A string to concatenate with another string. This is the right part.
     *
     * Returns
     * -------
     * string
     *     The resulting string from concatenating the two given strings.
     */
    function concatenate(
        string stringLeft,
        string stringRight
    )
        internal
        pure
        returns (string)
    {
        // Get byte representations of both strings to allow for one-by-one
        // character iteration.
        bytes memory stringLeftBytes = bytes(stringLeft);
        bytes memory stringRightBytes = bytes(stringRight);

        // Initialize new string holder with the appropriate number of bytes to
        // hold the concatenated string.
        string memory resultString = new string(
            stringLeftBytes.length + stringRightBytes.length
        );

        // Get a bytes representation of the result string to allow for direct
        // modification.
        bytes memory resultBytes = bytes(resultString);

        // Initialize a number to hold the current index of the result string
        // to assign a character to.
        uint k = 0;

        // First loop over the left string, and afterwards over the right
        // string to assign each character to its proper location in the new
        // string.
        for (uint i = 0; i &amp;lt; stringLeftBytes.length; i++) {
            resultBytes[k++] = stringLeftBytes[i];
        }

        for (i = 0; i &amp;lt; stringRightBytes.length; i++) {
            resultBytes[k++] = stringRightBytes[i];
        }

        return string(resultBytes);
    }

    /**
     * Convert 256-bit unsigned integer into a 32 bytes structure.
     *
     * Parameters
     * ----------
     * value : uint256
     *     The unsigned integer to convert to bytes32.
     *
     * Returns
     * -------
     * bytes32
     *     The bytes32 representation of the given unsigned integer.
     */
    function uint256ToBytes32(uint256 value) internal pure returns (bytes32) {
        if (value == 0) {
            return &amp;#39;0&amp;#39;;
        }

        bytes32 resultBytes;

        while (value &amp;gt; 0) {
            resultBytes = bytes32(uint(resultBytes) / (2 ** 8));
            resultBytes |= bytes32(((value % 10) + 48) * 2 ** (8 * 31));
            value /= 10;
        }

        return resultBytes;
    }

    /**
     * Convert bytes32 data structure into a string.
     *
     * Parameters
     * ----------
     * data : bytes32
     *     The bytes to convert to a string.
     *
     * Returns
     * -------
     * string
     *     The string representation of given bytes.
     *
     * Notes
     * -----
     * This method is right-padded with zero bytes.
     */
    function bytes32ToString(bytes32 data) internal pure returns (string) {
        bytes memory bytesString = new bytes(32);

        for (uint i = 0; i &amp;lt; 32; i++) {
            bytes1 char = bytes1(bytes32(uint256(data) * 2 ** (8 * i)));

            if (char != 0) {
                bytesString[i] = char;
            }
        }

        return string(bytesString);
    }
}

/**
 * Partial interface of former ownership contract.
 *
 * This interface is used to perform the migration of tokens, from the former
 * ownership contract to the current version. The inclusion of the entire
 * contract is too bulky, hence the partial interface.
 */
interface PartialOwnership {
    function ownerOf(uint256 _tokenId) external view returns (address);
    function totalSupply() external view returns (uint256);
}

/**
 * Ethergotchi Ownership Contract
 *
 * This contract governs the &amp;quot;non-fungible tokens&amp;quot; (NFTs) that represent the
 * various Ethergotchi owned by players within Aethia.
 *
 * The NFTs are implemented according to the standard described in EIP-721 as
 * it was on March 19th, 2018.
 *
 * In addition to the mentioned specification, a method was added to create new
 * tokens: `add(uint256 _tokenId, address _owner)`. This method can *only* be
 * called by activated Aethia game contracts.
 *
 * For more information on Aethia and/or Ethergotchi, visit the following
 * website: https://aethia.co
 */
contract EthergotchiOwnershipV2 is
    Controllable,
    ERC721,
    ERC721Enumerable,
    ERC721Metadata
{
    // Direct mapping to keep track of token owners.
    mapping(uint256 =&amp;gt; address) private ownerByTokenId;

    // Mapping that keeps track of all tokens owned by a specific address. This
    // allows for iteration by owner, and is implemented to be able to comply
    // with the enumeration methods described in the ERC721Enumerable interface.
    mapping(address =&amp;gt; uint256[]) private tokenIdsByOwner;

    // Mapping that keeps track of a token&amp;quot;s position in an owner&amp;quot;s list of
    // tokens. This allows for constant time look-ups within the list, instead
    // of needing to iterate the list of tokens.
    mapping(uint256 =&amp;gt; uint256) private ownerTokenIndexByTokenId;

    // Mapping that keeps track of addresses that are approved to make a
    // transfer of a token. Approval can only be given to a single address, but
    // can be overridden for modification or retraction purposes.
    mapping(uint256 =&amp;gt; address) private approvedTransfers;

    // Mapping that keeps track of operators that are allowed to perform
    // actions on behalf of another address. An address is allowed to set more
    // than one operator. Operators can perform all actions on behalf on an
    // address, *except* for setting a different operator.
    mapping(address =&amp;gt; mapping(address =&amp;gt; bool)) private operators;

    // Total number of tokens governed by this contract. This allows for the
    // enumeration of all tokens, provided that tokens are created with their
    // identifiers being numbers, incremented by one.
    uint256 private totalTokens;

    // The ERC-165 identifier of the ERC-165 interface. This contract
    // implements the `supportsInterface` method to check whether other types
    // of standard interfaces are supported.
    bytes4 private constant INTERFACE_SIGNATURE_ERC165 = bytes4(
        keccak256(&amp;quot;supportsInterface(bytes4)&amp;quot;)
    );

    // The ERC-165 identifier of the ERC-721 interface. This contract
    // implements all methods of the ERC-721 Enumerable interface, and uses
    // this identifier to supply the correct answer to a call to
    // `supportsInterface`.
    bytes4 private constant INTERFACE_SIGNATURE_ERC721 = bytes4(
        keccak256(&amp;quot;balanceOf(address)&amp;quot;) ^
        keccak256(&amp;quot;ownerOf(uint256)&amp;quot;) ^
        keccak256(&amp;quot;safeTransferFrom(address,address,uint256,bytes)&amp;quot;) ^
        keccak256(&amp;quot;safeTransferFrom(address,address,uint256)&amp;quot;) ^
        keccak256(&amp;quot;transferFrom(address,address,uint256)&amp;quot;) ^
        keccak256(&amp;quot;approve(address,uint256)&amp;quot;) ^
        keccak256(&amp;quot;setApprovalForAll(address,bool)&amp;quot;) ^
        keccak256(&amp;quot;getApproved(uint256)&amp;quot;) ^
        keccak256(&amp;quot;isApprovedForAll(address,address)&amp;quot;)
    );

    // The ERC-165 identifier of the ERC-721 Enumerable interface. This
    // contract implements all methods of the ERC-721 Enumerable interface, and
    // uses this identifier to supply the correct answer to a call to
    // `supportsInterface`.
    bytes4 private constant INTERFACE_SIGNATURE_ERC721_ENUMERABLE = bytes4(
        keccak256(&amp;quot;totalSupply()&amp;quot;) ^
        keccak256(&amp;quot;tokenByIndex(uint256)&amp;quot;) ^
        keccak256(&amp;quot;tokenOfOwnerByIndex(address,uint256)&amp;quot;)
    );

    // The ERC-165 identifier of the ERC-721 Metadata interface. This contract
    // implements all methods of the ERC-721 Metadata interface, and uses the
    // identifier to supply the correct answer to a `supportsInterface` call.
    bytes4 private constant INTERFACE_SIGNATURE_ERC721_METADATA = bytes4(
        keccak256(&amp;quot;name()&amp;quot;) ^
        keccak256(&amp;quot;symbol()&amp;quot;) ^
        keccak256(&amp;quot;tokenURI(uint256)&amp;quot;)
    );

    // The ERC-165 identifier of the ERC-721 Token Receiver interface. This
    // is not implemented by this contract, but is used to identify the
    // response given by the receiving contracts, if the `safeTransferFrom`
    // method is used.
    bytes4 private constant INTERFACE_SIGNATURE_ERC721_TOKEN_RECEIVER = bytes4(
        keccak256(&amp;quot;onERC721Received(address,uint256,bytes)&amp;quot;)
    );

    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _tokenId
    );

    event Approval(
        address indexed _owner,
        address indexed _approved,
        uint256 _tokenId
    );

    event ApprovalForAll(
        address indexed _owner,
        address indexed _operator,
        bool _approved
    );

    /**
     * Modify method to only allow calls if the token is valid.
     *
     * Notice
     * ------
     * Ethergotchi are valid if they are owned by an address that is not the
     * zero address.
     */
    modifier onlyValidToken(uint256 _tokenId) {
        require(ownerByTokenId[_tokenId] != address(0));
        _;
    }

    /**
     * Modify method to only allow transfers from authorized callers.
     *
     * Notice
     * ------
     * This method also adds a few checks against common transfer beneficiary
     * mistakes to prevent a subset of unintended transfers that cannot be
     * reverted.
     */
    modifier onlyValidTransfers(address _from, address _to, uint256 _tokenId) {
        // Get owner of the token. This is used to check against various cases
        // where the caller is allowed to transfer the token.
        address tokenOwner = ownerByTokenId[_tokenId];

        // Check whether the caller is allowed to transfer the token with given
        // identifier. The caller is allowed to perform the transfer in any of
        // the following cases:
        //  1. the caller is the owner of the token;
        //  2. the caller is approved by the owner of the token to transfer
        //     that specific token; or
        //  3. the caller is approved as operator by the owner of the token, in
        //     which case the caller is approved to perform any action on
        //     behalf of the owner.
        require(
            msg.sender == tokenOwner ||
            msg.sender == approvedTransfers[_tokenId] ||
            operators[tokenOwner][msg.sender]
        );

        // Check against accidental transfers to the common &amp;quot;wrong&amp;quot; addresses.
        // This includes the zero address, this ownership contract address, and
        // &amp;quot;non-transfers&amp;quot; where the same address is filled in for both `_from`
        // and `_to`.
        require(
            _to != address(0) &amp;amp;&amp;amp;
            _to != address(this) &amp;amp;&amp;amp;
            _to != _from
        );

        _;
    }

    /**
     * Ethergotchi ownership contract constructor
     *
     * At the time of contract construction, an Ethergotchi is artificially
     * constructed to ensure that Ethergotchi are numbered starting from one.
     */
    function EthergotchiOwnershipV2(
        address _formerContract
    )
        public
        Controllable()
    {
        ownerByTokenId[0] = address(0);
        tokenIdsByOwner[address(0)].push(0);
        ownerTokenIndexByTokenId[0] = 0;

        // The migration index is initialized to 1 as the zeroth token need not
        // be migrated; it is already created during the construction of this
        // contract.
        migrationIndex = 1;
        formerContract = PartialOwnership(_formerContract);
    }

    /**
     * Add new token into circulation.
     *
     * Parameters
     * ----------
     * _tokenId : uint256
     *     The identifier of the token to add into circulation.
     * _owner : address
     *     The address of the owner who receives the newly added token.
     *
     * Notice
     * ------
     * This method can only be called by active game contracts. Game contracts
     * are added and modified manually. These additions and modifications
     * always trigger an event for audit purposes.
     */
    function add(
        uint256 _tokenId,
        address _owner
    )
        external
        onlyActiveContracts
    {
        // Safety checks to prevent contracts from calling this method without
        // setting the proper arguments.
        require(_tokenId != 0 &amp;amp;&amp;amp; _owner != address(0));

        _add(_tokenId, _owner);

        // As per the standard, transfers of newly created tokens should always
        // originate from the zero address.
        Transfer(address(0), _owner, _tokenId);
    }

    /**
     * Check whether contract supports given interface.
     *
     * Parameters
     * ----------
     * interfaceID : bytes4
     *     The four-bytes representation of an interface of which to check
     *     whether this contract supports it.
     *
     * Returns
     * -------
     * bool
     *     True if given interface is supported, else False.
     *
     * Notice
     * ------
     * It is expected that the `bytes4` values of interfaces are generated by
     * calling XOR on all function signatures of the interface.
     *
     * Technically more interfaces are supported, as some interfaces may be
     * subsets of the supported interfaces. This check is only to be used to
     * verify whether &amp;quot;standard interfaces&amp;quot; are supported.
     */
    function supportsInterface(
        bytes4 interfaceID
    )
        external
        view
        returns (bool)
    {
        return (
            interfaceID == INTERFACE_SIGNATURE_ERC165 ||
            interfaceID == INTERFACE_SIGNATURE_ERC721 ||
            interfaceID == INTERFACE_SIGNATURE_ERC721_METADATA ||
            interfaceID == INTERFACE_SIGNATURE_ERC721_ENUMERABLE
        );
    }

    /**
     * Get the name of the token this contract governs ownership of.
     *
     * Notice
     * ------
     * This is the collective name of the token. Individual tokens may be named
     * differently by their owners.
     */
    function name() external pure returns (string) {
        return &amp;quot;Ethergotchi&amp;quot;;
    }

    /**
     * Get the symbol of the token this contract governs ownership of.
     *
     * Notice
     * ------
     * This symbol has been explicitly changed to `ETHERGOTCHI` from `GOTCHI`
     * in the `PHOENIX` patch of Aethia to prevent confusion with older tokens.
     */
    function symbol() external pure returns (string) {
        return &amp;quot;ETHERGOTCHI&amp;quot;;
    }

    /**
     * Get the URI pointing to a JSON file with metadata for a given token.
     *
     * Parameters
     * ----------
     * _tokenId : uint256
     *     The identifier of the token to get the URI for.
     *
     * Returns
     * -------
     * string
     *     The URI pointing to a JSON file with metadata for the token with
     *     given identifier.
     *
     * Notice
     * ------
     * This method returns a string that may contain more than one null-byte,
     * because the conversion method is not ideal.
     */
    function tokenURI(uint256 _tokenId) external view returns (string) {
        bytes32 tokenIdBytes = Tools.uint256ToBytes32(_tokenId);

        return Tools.concatenate(
            &amp;quot;https://aethia.co/ethergotchi/&amp;quot;,
            Tools.bytes32ToString(tokenIdBytes)
        );
    }

    /**
     * Get the number of tokens assigned to given owner.
     *
     * Parameters
     * ----------
     * _owner : address
     *     The address of the owner of which to get the number of owned tokens
     *     of.
     *
     * Returns
     * -------
     * uint256
     *     The number of tokens owned by given owner.
     *
     * Notice
     * ------
     * Tokens owned by the zero address are considered invalid, as described in
     * the EIP 721 standard, and queries regarding the zero address will result
     * in the transaction being rejected.
     */
    function balanceOf(address _owner) external view returns (uint256) {
        require(_owner != address(0));

        return tokenIdsByOwner[_owner].length;
    }

    /**
     * Get the address of the owner of given token.
     *
     * Parameters
     * ----------
     * _tokenId : uint256
     *     The identifier of the token of which to get the owner&amp;quot;s address.
     *
     * Returns
     * -------
     * address
     *     The address of the owner of given token.
     *
     * Notice
     * ------
     * Tokens owned by the zero address are considered invalid, as described in
     * the EIP 721 standard, and queries regarding the zero address will result
     * in the transaction being rejected.
     */
    function ownerOf(uint256 _tokenId) external view returns (address) {
        // Store the owner in a temporary variable to avoid having to do the
        // lookup twice.
        address _owner = ownerByTokenId[_tokenId];

        require(_owner != address(0));

        return _owner;
    }

    /**
     * Transfer the ownership of given token from one address to another.
     *
     * Parameters
     * ----------
     * _from : address
     *     The benefactor address to transfer the given token from.
     * _to : address
     *     The beneficiary address to transfer the given token to.
     * _tokenId : uint256
     *     The identifier of the token to transfer.
     * data : bytes
     *     Non-specified data to send along the transfer towards the `to`
     *     address that can be processed.
     *
     * Notice
     * ------
     * This method performs a check to determine whether the receiving party is
     * a smart contract by calling the `_isContract` method. This works until
     * the `Serenity` update of Ethereum is deployed.
     */
    function safeTransferFrom(
        address _from,
        address _to,
        uint256 _tokenId,
        bytes data
    )
        external
        onlyValidToken(_tokenId)
    {
        // Call the internal `_safeTransferFrom` method to avoid duplicating
        // the transfer code.
        _safeTransferFrom(_from, _to, _tokenId, data);
    }

    /**
     * Transfer the ownership of given token from one address to another.
     *
     * Parameters
     * ----------
     * _from : address
     *     The benefactor address to transfer the given token from.
     * _to : address
     *     The beneficiary address to transfer the given token to.
     * _tokenId : uint256
     *     The identifier of the token to transfer.
     *
     * Notice
     * ------
     * This method does exactly the same as calling the `safeTransferFrom`
     * method with the `data` parameter set to an empty bytes value:
     *  `safeTransferFrom(_from, _to, _tokenId, &amp;quot;&amp;quot;)`
     */
    function safeTransferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    )
        external
        onlyValidToken(_tokenId)
    {
        // Call the internal `_safeTransferFrom` method to avoid duplicating
        // the transfer code.
        _safeTransferFrom(_from, _to, _tokenId, &amp;quot;&amp;quot;);
    }

    /**
     * Transfer the ownership of given token from one address to another.
     *
     * Parameters
     * ----------
     * _from : address
     *     The benefactor address to transfer the given token from.
     * _to : address
     *     The beneficiary address to transfer the given token to.
     * _tokenId : uint256
     *     The identifier of the token to transfer.
     *
     * Notice
     * ------
     * This method performs a few rudimentary checks to determine whether the
     * receiving party can actually receive the token. However, it is still up
     * to the caller to ensure this is actually the case.
     */
    function transferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    )
        external
        onlyValidToken(_tokenId)
        onlyValidTransfers(_from, _to, _tokenId)
    {
        _transfer(_to, _tokenId);
    }

    /**
     * Approve the given address for the transfer of the given token.
     *
     * Parameters
     * ----------
     * _approved : address
     *     The address to approve. Approval allows the address to transfer the
     *     given token to a different address.
     * _tokenId : uint256
     *     The identifier of the token to give transfer approval for.
     *
     * Notice
     * ------
     * There is no specific method to revoke approvals, but the approval is
     * removed after the transfer has been completed. Additionally the owner
     * or operator may call the method with the zero address as `_approved` to
     * effectively revoke the approval.
     */
    function approve(address _approved, uint256 _tokenId) external {
        address _owner = ownerByTokenId[_tokenId];

        // Approval can only be given by the owner or an operator approved by
        // the owner.
        require(msg.sender == _owner || operators[_owner][msg.sender]);

        // Set address as approved for transfer. It can be the case that the
        // address was already set (e.g. this method was called twice in a row)
        // in which case this does not change anything.
        approvedTransfers[_tokenId] = _approved;

        Approval(msg.sender, _approved, _tokenId);
    }

    /**
     * Set approval for a third-party to manage all tokens of the caller.
     *
     * Parameters
     * ----------
     * _operator : address
     *     The address to set the operator status for.
     * _approved : bool
     *     The operator status. True if the given address should be allowed to
     *     act on behalf of the caller, else False.
     *
     * Notice
     * ------
     * There is no duplicate checking done out of simplicity. Callers are thus
     * able to set the same address as operator a multitude of times, even if
     * it does not change the actual state of the system.
     */
    function setApprovalForAll(address _operator, bool _approved) external {
        operators[msg.sender][_operator] = _approved;

        ApprovalForAll(msg.sender, _operator, _approved);
    }

    /**
     * Get approved address for given token.
     *
     * Parameters
     * ----------
     * _tokenId : uint256
     *     The identifier of the token of which to get the approved address of.
     *
     * Returns
     * -------
     * address
     *     The address that is allowed to initiate a transfer of the given
     *     token.
     *
     * Notice
     * ------
     * Technically this method could be implemented without the method modifier
     * as the network guarantees that the address mapping is initiated with all
     * addresses set to the zero address. The requirement is implemented to
     * comply with the standard as described in EIP-721.
     */
    function getApproved(
        uint256 _tokenId
    )
        external
        view
        onlyValidToken(_tokenId)
        returns (address)
    {
        return approvedTransfers[_tokenId];
    }

    /**
     * Check whether an address is an authorized operator of another address.
     *
     * Parameters
     * ----------
     * _owner : address
     *     The address of which to check whether it has approved the other
     *     address to act as operator.
     * _operator : address
     *     The address of which to check whether it has been approved to act
     *     as operator on behalf of `_owner`.
     *
     * Returns
     * -------
     * bool
     *     True if `_operator` is approved for all actions on behalf of
     *     `_owner`.
     *
     * Notice
     * ------
     * This method cannot fail, as the Ethereum network guarantees that all
     * address mappings exist and are set to the zero address by default.
     */
    function isApprovedForAll(
        address _owner,
        address _operator
    )
        external
        view
        returns (bool)
    {
        return operators[_owner][_operator];
    }

    /**
     * Get the total number of tokens currently in circulation.
     *
     * Returns
     * -------
     * uint256
     *     The total number of tokens currently in circulation.
     */
    function totalSupply() external view returns (uint256) {
        return totalTokens;
    }

    /**
     * Get token identifier by index.
     *
     * Parameters
     * ----------
     * _index : uint256
     *     The index of the token to get the identifier of.
     *
     * Returns
     * -------
     * uint256
     *     The identifier of the token at given index.
     *
     * Notice
     * ------
     * Ethergotchi tokens are incrementally numbered starting from zero, and
     * always go up by one. The index of the token is thus equivalent to its
     * identifier.
     */
    function tokenByIndex(uint256 _index) external view returns (uint256) {
        require(_index &amp;lt; totalTokens);

        return _index;
    }

    /**
     * Get token of owner by index.
     *
     * Parameters
     * ----------
     * _owner : address
     *     The address of the owner of which to get the token of.
     * _index : uint256
     *     The index of the token in the given owner&amp;quot;s list of token.
     *
     * Returns
     * -------
     * uint256
     *     The identifier of the token at given index of an owner&amp;quot;s list of
     *     tokens.
     */
    function tokenOfOwnerByIndex(
        address _owner,
        uint256 _index
    )
        external
        view
        returns (uint256)
    {
        require(_index &amp;lt; tokenIdsByOwner[_owner].length);

        return tokenIdsByOwner[_owner][_index];
    }

    /**
     * Check whether given address is a smart contract.
     *
     * Parameters
     * ----------
     * _address : address
     *     The address of which to check whether it is a contract.
     *
     * Returns
     * -------
     * bool
     *     True if given address is a contract, else False.
     *
     * Notice
     * ------
     * This method works as long as the `Serenity` update of Ethereum has not
     * been deployed. At the time of writing, contracts cannot set their code
     * size to zero, nor can &amp;quot;normal&amp;quot; addresses set their code size to anything
     * non-zero. With `Serenity` the idea will be that each and every address
     * is an contract, effectively rendering this method.
     */
    function _isContract(address _address) internal view returns (bool) {
        uint size;

        assembly {
            size := extcodesize(_address)
        }

        return size &amp;gt; 0;
    }

    /**
     * Transfer the ownership of given token from one address to another.
     *
     * Parameters
     * ----------
     * _from : address
     *     The benefactor address to transfer the given token from.
     * _to : address
     *     The beneficiary address to transfer the given token to.
     * _tokenId : uint256
     *     The identifier of the token to transfer.
     * data : bytes
     *     Non-specified data to send along the transfer towards the `to`
     *     address that can be processed.
     *
     * Notice
     * ------
     * This method performs a check to determine whether the receiving party is
     * a smart contract by calling the `_isContract` method. This works until
     * the `Serenity` update of Ethereum is deployed.
     */
    function _safeTransferFrom(
        address _from, 
        address _to, 
        uint256 _tokenId,
        bytes data
    )
        internal
        onlyValidTransfers(_from, _to, _tokenId)
    {
        // Call the method that performs the actual transfer. All common cases
        // of &amp;quot;wrong&amp;quot; transfers have already been checked at this point. The
        // internal transfer method does no checking.
        _transfer(_to, _tokenId);

        // Check whether the receiving party is a contract, and if so, call
        // the `onERC721Received` method as defined in the ERC-721 standard.
        if (_isContract(_to)) {

            // Assume the receiving party has implemented ERC721TokenReceiver,
            // as otherwise the &amp;quot;unsafe&amp;quot; `transferFrom` method should have been
            // called instead.
            ERC721TokenReceiver _receiver = ERC721TokenReceiver(_to);

            // The response returned by `onERC721Received` of the receiving
            // contract&amp;quot;s `on *must* be equal to the magic number defined by
            // the ERC-165 signature of `ERC721TokenReceiver`. If this is not
            // the case, the transaction will be reverted.
            require(
                _receiver.onERC721Received(
                    address(this),
                    _tokenId,
                    data
                ) == INTERFACE_SIGNATURE_ERC721_TOKEN_RECEIVER
            );
        }
    }

    /**
     * Transfer token to new owner.
     *
     * Parameters
     * ----------
     * _to : address
     *     The address of the owner-to-be of given token.
     * _tokenId : _tokenId
     *     The identifier of the token that is to be transferred.
     *
     * Notice
     * ------
     * This method performs no safety checks as it can only be called within
     * the controlled environment of this contract.
     */
    function _transfer(address _to, uint256 _tokenId) internal {
        // Get current owner of the token. It is technically possible that the
        // owner is the same address as the address to which the token is to be
        // sent to. In this case the token will be moved to the end of the list
        // of tokens owned by this address.
        address _from = ownerByTokenId[_tokenId];

        // There are two possible scenarios for transfers when it comes to the
        // removal of the token from the side that currently owns the token:
        //  1: the owner has two or more tokens; or
        //  2: the owner has one token.
        if (tokenIdsByOwner[_from].length &amp;gt; 1) {

            // Get the index of the token that has to be removed from the list
            // of tokens owned by the current owner.
            uint256 tokenIndexToDelete = ownerTokenIndexByTokenId[_tokenId];

            // To keep the list of tokens without gaps, and thus reducing the
            // gas cost associated with interacting with the list, the last
            // token in the owner&amp;quot;s list of tokens is moved to fill the gap
            // created by removing the token.
            uint256 tokenIndexToMove = tokenIdsByOwner[_from].length - 1;

            // Overwrite the token that is to be removed with the token that
            // was at the end of the list. It is possible that both are one and
            // the same, in which case nothing happens.
            tokenIdsByOwner[_from][tokenIndexToDelete] =
                tokenIdsByOwner[_from][tokenIndexToMove];
        }

        // Remove the last item in the list of tokens owned by the current
        // owner. This item has either already been copied to the location of
        // the token that is to be transferred, or is the only token of this
        // owner in which case the list of tokens owned by this owner is now
        // empty.
        tokenIdsByOwner[_from].length--;

        // Add the token to the list of tokens owned by `_to`. Items are always
        // added to the very end of the list. This makes the token index of the
        // new token within the owner&amp;quot;s list of tokens equal to the length of
        // the list minus one as Solidity is a zero-based language. This token
        // index is then set for this token identifier.
        tokenIdsByOwner[_to].push(_tokenId);
        ownerTokenIndexByTokenId[_tokenId] = tokenIdsByOwner[_to].length - 1;

        // Set the direct ownership information of the token to the new owner
        // after all other ownership-related mappings have been updated to make
        // sure the &amp;quot;side&amp;quot; data is correct.
        ownerByTokenId[_tokenId] = _to;

        // Remove the approved address of this token. It may be the case there
        // was no approved address, in which case nothing changes.
        approvedTransfers[_tokenId] = address(0);

        // Log the transfer event onto the blockchain to leave behind an audit
        // trail of all transfers that have taken place.
        Transfer(_from, _to, _tokenId);
    }

    /**
     * Add new token into circulation.
     *
     * Parameters
     * ----------
     * _tokenId : uint256
     *     The identifier of the token to add into circulation.
     * _owner : address
     *     The address of the owner who receives the newly added token.
     */
    function _add(uint256 _tokenId, address _owner) internal {
        // Ensure the token does not already exist, and prevent duplicate calls
        // using the same identifier.
        require(ownerByTokenId[_tokenId] == address(0));

        // Update the direct ownership mapping, by setting the owner of the
        // token identifier to `_owner`, and adding the token to the list of
        // tokens owned by `_owner`. Arrays are always initialized to empty
        // versions of of their specific type, thus ensuring that the `push`
        // method will not fail.
        ownerByTokenId[_tokenId] = _owner;
        tokenIdsByOwner[_owner].push(_tokenId);

        // Update the mapping that keeps track of a token&amp;quot;s index within the
        // list of tokens owned by each owner. At the time of addition a token
        // is always added to the end of the list, and will thus always equal
        // the number of tokens already in the list, minus one, because the
        // arrays within Solidity are zero-based.
        ownerTokenIndexByTokenId[_tokenId] = tokenIdsByOwner[_owner].length - 1;

        totalTokens += 1;
    }

    /*********************************************/
    /** MIGRATION state variables and functions **/
    /*********************************************/

    // This number is used to keep track of how many tokens have been migrated.
    // The number cannot exceed the number of tokens that were assigned to
    // owners in the previous Ownership contract.
    uint256 public migrationIndex;

    // The previous token ownership contract.
    PartialOwnership private formerContract;

    /**
     * Migrate data from the former Ethergotchi ownership contract.
     *
     * Parameters
     * ----------
     * _count : uint256
     *     The number of tokens to migrate in a single transaction.
     *
     * Notice
     * ------
     * This method is limited in use to ensure no &amp;#39;malicious&amp;#39; calls are made.
     * Additionally, this method writes to a contract state variable to keep
     * track of how many tokens have been migrated.
     */
    function migrate(uint256 _count) external onlyOwner {
        // Ensure that the migrate function can *only* be called in a specific
        // time period. This period ranges from Saturday, March 24th, 00:00:00
        // UTC until Sunday, March 25th, 23:59:59 UTC.
        require(1521849600 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1522022399);

        // Get the maximum number of tokens handed out by the previous
        // ownership contract.
        uint256 formerTokenCount = formerContract.totalSupply();

        // The index to stop the migration at for this transaction.
        uint256 endIndex = migrationIndex + _count;

        // It is possible that the final transaction has a higher end index
        // than there are a number of tokens. In this case, the end index is
        // reduced to ensure no non-existent tokens are migrated.
        if (endIndex &amp;gt;= formerTokenCount) {
            endIndex = formerTokenCount;
        }

        // Loop through the token identifiers to migrate in this transaction.
        // Token identifiers are equivalent to their &amp;#39;index&amp;#39;, as identifiers
        // start at zero (with the zeroth token being owned by the zero
        // address), and are incremented by one for each new token.
        for (uint256 i = migrationIndex; i &amp;lt; endIndex; i++) {
            address tokenOwner;

            // There was a malicious account that acquired over 400 eggs via
            // referral codes, which breaks the terms of use. The acquired egg
            // numbers ranged from identifier 1247 up until 1688, excluding
            // 1296, 1297, 1479, 1492, 1550, 1551, and 1555. This was found by
            // looking at activity on the pick-up contract, and tracing it back
            // to the following address:
            //  `0c7a911ac29ea1e3b1d438f98f8bc053131dcaf52`
            if (_isExcluded(i)) {
                tokenOwner = address(0);
            } else {
                tokenOwner = formerContract.ownerOf(i);
            }

            // Assign the token to the same address that owned it in the
            // previous ownership contract.
            _add(i, tokenOwner);

            // Log the token transfer. In this case where the token is &amp;#39;newly&amp;#39;
            // created, but actually transferred from a previous contract, the
            // `_from` address is set to the previous contract address, to
            // signify a migration.
            Transfer(address(formerContract), tokenOwner, i);
        }

        // Set the new migration index to where the current transaction ended
        // its migration.
        migrationIndex = endIndex;
    }

    /**
     * Check if Ethergotchi should be excluded from migration.
     *
     * Parameters
     * ----------
     * _gotchiId : uint256
     *     The identifier of the Ethergotchi of which to check the exclusion
     *     status.
     *
     * Returns
     * -------
     * bool
     *     True if the Ethergotchi should be excluded from the migration, else
     *     False.
     */
    function _isExcluded(uint256 _gotchiId) internal pure returns (bool) {
        return
            1247 &amp;lt;= _gotchiId &amp;amp;&amp;amp; _gotchiId &amp;lt;= 1688 &amp;amp;&amp;amp;
            _gotchiId != 1296 &amp;amp;&amp;amp;
            _gotchiId != 1297 &amp;amp;&amp;amp;
            _gotchiId != 1479 &amp;amp;&amp;amp;
            _gotchiId != 1492 &amp;amp;&amp;amp;
            _gotchiId != 1550 &amp;amp;&amp;amp;
            _gotchiId != 1551 &amp;amp;&amp;amp;
            _gotchiId != 1555;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xd7cc28e7d5ef2adf0bfe010c656642a8351dc548.sol" target="_blank" title="show github file">0xd7cc28e7d5ef2adf0bfe010c656642a8351dc548.sol</a>
        </div>
        <div class="path">solidity-files/0xd7cc28e7d5ef2adf0bfe010c656642a8351dc548.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT364959&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT364959
    // Name        : ADZbuzz Tasty.co Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT364959&amp;quot;;
            name = &amp;quot;ADZbuzz Tasty.co Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x542486d7ae386860d9b659a557d614839689d053.sol" target="_blank" title="show github file">0x542486d7ae386860d9b659a557d614839689d053.sol</a>
        </div>
        <div class="path">solidity-files/0x542486d7ae386860d9b659a557d614839689d053.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.16;

// copyright &lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;26454948524745526663524e4354434b49480845494b&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;

contract SafeMath {

    /* function assert(bool assertion) internal { */
    /*   if (!assertion) { */
    /*     throw; */
    /*   } */
    /* }      // assert no longer needed once solidity is on 0.4.10 */

    function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {
      uint256 z = x + y;
      assert((z &amp;gt;= x) &amp;amp;&amp;amp; (z &amp;gt;= y));
      return z;
    }

    function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {
      assert(x &amp;gt;= y);
      uint256 z = x - y;
      return z;
    }

    function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {
      uint256 z = x * y;
      assert((x == 0)||(z/x == y));
      return z;
    }

}

contract BasicAccessControl {
    address public owner;
    // address[] public moderators;
    uint16 public totalModerators = 0;
    mapping (address =&amp;gt; bool) public moderators;
    bool public isMaintaining = false;

    function BasicAccessControl() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    modifier onlyModerators() {
        require(moderators[msg.sender] == true);
        _;
    }

    modifier isActive {
        require(!isMaintaining);
        _;
    }

    function ChangeOwner(address _newOwner) onlyOwner public {
        if (_newOwner != address(0)) {
            owner = _newOwner;
        }
    }


    function AddModerator(address _newModerator) onlyOwner public {
        if (moderators[_newModerator] == false) {
            moderators[_newModerator] = true;
            totalModerators += 1;
        }
    }
    
    function RemoveModerator(address _oldModerator) onlyOwner public {
        if (moderators[_oldModerator] == true) {
            moderators[_oldModerator] = false;
            totalModerators -= 1;
        }
    }

    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {
        isMaintaining = _isMaintaining;
    }
}

contract EtheremonEnum {

    enum ResultCode {
        SUCCESS,
        ERROR_CLASS_NOT_FOUND,
        ERROR_LOW_BALANCE,
        ERROR_SEND_FAIL,
        ERROR_NOT_TRAINER,
        ERROR_NOT_ENOUGH_MONEY,
        ERROR_INVALID_AMOUNT,
        ERROR_OBJ_NOT_FOUND,
        ERROR_OBJ_INVALID_OWNERSHIP
    }
    
    enum ArrayType {
        CLASS_TYPE,
        STAT_STEP,
        STAT_START,
        STAT_BASE,
        OBJ_SKILL
    }
}

contract EtheremonDataBase is EtheremonEnum, BasicAccessControl, SafeMath {
    
    uint64 public totalMonster;
    uint32 public totalClass;
    
    // write
    function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);
    function removeElementOfArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);
    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) onlyModerators public returns(uint32);
    function addMonsterObj(uint32 _classId, address _trainer, string _name) onlyModerators public returns(uint64);
    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) onlyModerators public;
    function increaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;
    function decreaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;
    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;
    function addMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;
    function clearMonsterReturnBalance(uint64 _monsterId) onlyModerators public returns(uint256 amount);
    function collectAllReturnBalance(address _trainer) onlyModerators public returns(uint256 amount);
    function transferMonster(address _from, address _to, uint64 _monsterId) onlyModerators public returns(ResultCode);
    function addExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);
    function deductExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);
    function setExtraBalance(address _trainer, uint256 _amount) onlyModerators public;
    
    // read
    function getSizeArrayType(ArrayType _type, uint64 _id) constant public returns(uint);
    function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8);
    function getMonsterClass(uint32 _classId) constant public returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);
    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);
    function getMonsterName(uint64 _objId) constant public returns(string name);
    function getExtraBalance(address _trainer) constant public returns(uint256);
    function getMonsterDexSize(address _trainer) constant public returns(uint);
    function getMonsterObjId(address _trainer, uint index) constant public returns(uint64);
    function getExpectedBalance(address _trainer) constant public returns(uint256);
    function getMonsterReturn(uint64 _objId) constant public returns(uint256 current, uint256 total);
}

contract EtheremonDataEvent is BasicAccessControl {
    
    // data contract
    address public dataContract;
    
    // event
    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
    
     // constructor
    function EtheremonDataEvent(address _dataContract) public {
        dataContract = _dataContract;
    }
    
    function setContract(address _dataContract) onlyModerators public {
        dataContract = _dataContract;
    }
    
    // write action
    
    function addExtraBalance(address _trainer, uint256 _amount) onlyModerators external returns(uint256) {
        EtheremonDataBase data = EtheremonDataBase(dataContract);
        return data.addExtraBalance(_trainer, _amount);
    }
    
    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) onlyModerators external {
        EtheremonDataBase data = EtheremonDataBase(dataContract);
        data.setMonsterObj(_objId, _name, _exp, _createIndex, _lastClaimIndex);
    }
    
    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public {
        EtheremonDataBase data = EtheremonDataBase(dataContract);
        data.removeMonsterIdMapping(_trainer, _monsterId);
        Transfer(_trainer, address(0), _monsterId);
    }
    
    function addMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public {
        EtheremonDataBase data = EtheremonDataBase(dataContract);
        data.addMonsterIdMapping(_trainer, _monsterId);
        Transfer(address(0), _trainer, _monsterId);
    }
    
    
    // read action
    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime) {
        EtheremonDataBase data = EtheremonDataBase(dataContract);
        return data.getMonsterObj(_objId);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x150c6206cb5ae77065f452c36a83daaa1caff087.sol" target="_blank" title="show github file">0x150c6206cb5ae77065f452c36a83daaa1caff087.sol</a>
        </div>
        <div class="path">solidity-files/0x150c6206cb5ae77065f452c36a83daaa1caff087.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
/** ----------------------------------------------------------------------------------------------
 * Power_Token by Power Limited.
 */

library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}


contract ERC20 {

    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);

    function allowance(address owner, address spender) public view returns (uint256);
    function approve(address spender, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);

}

contract Ownable {
  address public owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  function Ownable() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}


interface TokenRecipient {
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;
}



contract TokenERC20 is ERC20, Ownable{
    // Public variables of the token
    string public name;
    string public symbol;
    uint8  public decimals = 18;
    // 18 decimals is the strongly suggested default, avoid changing it
    using SafeMath for uint256;
    // Balances
    mapping (address =&amp;gt; uint256) balances;
    // Allowances
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowances;


    // ----- Events -----
    event Burn(address indexed from, uint256 value);

    function TokenERC20(uint256 _initialSupply, string _tokenName, string _tokenSymbol, uint8 _decimals) public {
        name = _tokenName;                                   // Set the name for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
        decimals = _decimals;

        totalSupply = _initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balances[msg.sender] = totalSupply;                // Give the creator all initial tokens
    }

    modifier onlyPayloadSize(uint size) {
      if(msg.data.length &amp;lt; size + 4) {
        revert();
      }
      _;
    }
    

    function balanceOf(address _owner) public view returns(uint256) {
        return balances[_owner];
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowances[_owner][_spender];
    }

    function _transfer(address _from, address _to, uint _value) internal returns(bool) {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balances[_from] &amp;gt;= _value);
        // Check for overflows
        require(balances[_to] + _value &amp;gt; balances[_to]);

        require(_value &amp;gt;= 0);
        // Save this for an assertion in the future
        uint previousBalances = balances[_from].add(balances[_to]);
         // SafeMath.sub will throw if there is not enough balance.
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balances[_from] + balances[_to] == previousBalances);

        return true;
    }


    function transfer(address _to, uint256 _value) public returns(bool) {
        return _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns(bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[_from]);
        require(_value &amp;gt; 0);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns(bool) {
        require((_value == 0) || (allowances[msg.sender][_spender] == 0));
        allowances[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns(bool) {
        if (approve(_spender, _value)) {
            TokenRecipient spender = TokenRecipient(_spender);
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
        return false;
    }

  function transferForMultiAddresses(address[] _addresses, uint256[] _amounts)  public returns (bool) {
    for (uint256 i = 0; i &amp;lt; _addresses.length; i++) {
      require(_addresses[i] != address(0));
      require(_amounts[i] &amp;lt;= balances[msg.sender]);
      require(_amounts[i] &amp;gt; 0);

      // SafeMath.sub will throw if there is not enough balance.
      balances[msg.sender] = balances[msg.sender].sub(_amounts[i]);
      balances[_addresses[i]] = balances[_addresses[i]].add(_amounts[i]);
      Transfer(msg.sender, _addresses[i], _amounts[i]);
    }
    return true;
  }

    function burn(uint256 _value) public returns(bool) {
        require(balances[msg.sender] &amp;gt;= _value);   // Check if the sender has enough
        balances[msg.sender] = balances[msg.sender].sub(_value);            // Subtract from the sender
        totalSupply = totalSupply.sub(_value);                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns(bool) {
        require(balances[_from] &amp;gt;= _value);                // Check if the targeted balance is enough
        require(_value &amp;lt;= allowances[_from][msg.sender]);    // Check allowance
        balances[_from] = balances[_from].sub(_value);                         // Subtract from the targeted balance
        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);             // Subtract from the sender&amp;#39;s allowance
        totalSupply = totalSupply.sub(_value);                                 // Update totalSupply
        Burn(_from, _value);
        return true;
    }


    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        // Check for overflows
        require(allowances[msg.sender][_spender].add(_addedValue) &amp;gt; allowances[msg.sender][_spender]);

        allowances[msg.sender][_spender] =allowances[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowances[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowances[msg.sender][_spender];
        if (_subtractedValue &amp;gt; oldValue) {
            allowances[msg.sender][_spender] = 0;
        } else {
            allowances[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        Approval(msg.sender, _spender, allowances[msg.sender][_spender]);
        return true;
    }


}


contract PowerToken is TokenERC20 {

    function PowerToken() TokenERC20(1000000000, &amp;quot;WangZeCheng Token&amp;quot;, &amp;quot;WZC&amp;quot;, 18) public {

    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xcadbdd55d5c7ae3bc199c64163369fd50477b73e.sol" target="_blank" title="show github file">0xcadbdd55d5c7ae3bc199c64163369fd50477b73e.sol</a>
        </div>
        <div class="path">solidity-files/0xcadbdd55d5c7ae3bc199c64163369fd50477b73e.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

contract IGold {
    function balanceOf(address _owner) constant returns (uint256);
    function issueTokens(address _who, uint _tokens);
    function burnTokens(address _who, uint _tokens);
}

// StdToken inheritance is commented, because no &amp;#39;totalSupply&amp;#39; needed
contract IMNTP { /*is StdToken */
    function balanceOf(address _owner) constant returns (uint256);

    // Additional methods that MNTP contract provides
    function lockTransfer(bool _lock);
    function issueTokens(address _who, uint _tokens);
    function burnTokens(address _who, uint _tokens);
}

contract SafeMath {
    function safeAdd(uint a, uint b) internal returns (uint) {
        uint c = a + b;
        assert(c&amp;gt;=a &amp;amp;&amp;amp; c&amp;gt;=b);
        return c;
     }

    function safeSub(uint a, uint b) internal returns (uint) {
        assert(b &amp;lt;= a);
        return a - b;
    }
}

contract CreatorEnabled {
    address public creator = 0x0;

    modifier onlyCreator() { require(msg.sender == creator); _; }

    function changeCreator(address _to) public onlyCreator {
        creator = _to;
    }
}

contract StringMover {
    function stringToBytes32(string s) constant returns(bytes32){
        bytes32 out;
        assembly {
             out := mload(add(s, 32))
        }
        return out;
    }

    function stringToBytes64(string s) constant returns(bytes32,bytes32){
        bytes32 out;
        bytes32 out2;

        assembly {
             out := mload(add(s, 32))
             out2 := mload(add(s, 64))
        }
        return (out,out2);
    }

    function bytes32ToString(bytes32 x) constant returns (string) {
        bytes memory bytesString = new bytes(32);
        uint charCount = 0;
        for (uint j = 0; j &amp;lt; 32; j++) {
             byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
             if (char != 0) {
                  bytesString[charCount] = char;
                  charCount++;
             }
        }
        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (j = 0; j &amp;lt; charCount; j++) {
             bytesStringTrimmed[j] = bytesString[j];
        }
        return string(bytesStringTrimmed);
    }

    function bytes64ToString(bytes32 x, bytes32 y) constant returns (string) {
        bytes memory bytesString = new bytes(64);
        uint charCount = 0;

        for (uint j = 0; j &amp;lt; 32; j++) {
             byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
             if (char != 0) {
                  bytesString[charCount] = char;
                  charCount++;
             }
        }
        for (j = 0; j &amp;lt; 32; j++) {
             char = byte(bytes32(uint(y) * 2 ** (8 * j)));
             if (char != 0) {
                  bytesString[charCount] = char;
                  charCount++;
             }
        }

        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (j = 0; j &amp;lt; charCount; j++) {
             bytesStringTrimmed[j] = bytesString[j];
        }
        return string(bytesStringTrimmed);
    }
}


contract Storage is SafeMath, StringMover {
    function Storage() public {
        controllerAddress = msg.sender;
    }

    address public controllerAddress = 0x0;
    modifier onlyController() { require(msg.sender==controllerAddress); _; }

    function setControllerAddress(address _newController) onlyController {
        controllerAddress = _newController;
    }

    address public hotWalletAddress = 0x0;

    function setHotWalletAddress(address _address) onlyController {
       hotWalletAddress = _address;
    }


    // Fields - 1
    mapping(uint =&amp;gt; string) docs;
    uint public docCount = 0;

    // Fields - 2
    mapping(string =&amp;gt; mapping(uint =&amp;gt; int)) fiatTxs;
    mapping(string =&amp;gt; uint) fiatBalancesCents;
    mapping(string =&amp;gt; uint) fiatTxCounts;
    uint fiatTxTotal = 0;

    // Fields - 3
    mapping(string =&amp;gt; mapping(uint =&amp;gt; int)) goldTxs;
    mapping(string =&amp;gt; uint) goldHotBalances;
    mapping(string =&amp;gt; uint) goldTxCounts;
    uint goldTxTotal = 0;

    // Fields - 4
    struct Request {
        address sender;
        string userId;
        string requestHash;
        bool buyRequest;         // otherwise - sell

        // 0 - init
        // 1 - processed
        // 2 - cancelled
        uint8 state;
    }

    mapping (uint=&amp;gt;Request) requests;
    uint public requestsCount = 0;

    ///////
    function addDoc(string _ipfsDocLink) public onlyController returns(uint) {
        docs[docCount] = _ipfsDocLink;
        uint out = docCount;
        docCount++;

        return out;
    }

    function getDocCount() public constant returns (uint) {
        return docCount;
    }

    function getDocAsBytes64(uint _index) public constant returns (bytes32,bytes32) {
        require(_index &amp;lt; docCount);
        return stringToBytes64(docs[_index]);
    }

    function addFiatTransaction(string _userId, int _amountCents) public onlyController returns(uint) {
        require(0 != _amountCents);

        uint c = fiatTxCounts[_userId];

        fiatTxs[_userId][c] = _amountCents;

        if (_amountCents &amp;gt; 0) {
            fiatBalancesCents[_userId] = safeAdd(fiatBalancesCents[_userId], uint(_amountCents));
        } else {
            fiatBalancesCents[_userId] = safeSub(fiatBalancesCents[_userId], uint(-_amountCents));
        }

        fiatTxCounts[_userId] = safeAdd(fiatTxCounts[_userId], 1);

        fiatTxTotal++;
        return c;
    }

    function getFiatTransactionsCount(string _userId) public constant returns (uint) {
        return fiatTxCounts[_userId];
    }

    function getAllFiatTransactionsCount() public constant returns (uint) {
        return fiatTxTotal;
    }

    function getFiatTransaction(string _userId, uint _index) public constant returns(int) {
        require(_index &amp;lt; fiatTxCounts[_userId]);
        return fiatTxs[_userId][_index];
    }

    function getUserFiatBalance(string _userId) public constant returns(uint) {
        return fiatBalancesCents[_userId];
    }

    function addGoldTransaction(string _userId, int _amount) public onlyController returns(uint) {
        require(0 != _amount);

        uint c = goldTxCounts[_userId];

        goldTxs[_userId][c] = _amount;

        if (_amount &amp;gt; 0) {
            goldHotBalances[_userId] = safeAdd(goldHotBalances[_userId], uint(_amount));
        } else {
            goldHotBalances[_userId] = safeSub(goldHotBalances[_userId], uint(-_amount));
        }

        goldTxCounts[_userId] = safeAdd(goldTxCounts[_userId], 1);

        goldTxTotal++;
        return c;
    }

    function getGoldTransactionsCount(string _userId) public constant returns (uint) {
        return goldTxCounts[_userId];
    }

    function getAllGoldTransactionsCount() public constant returns (uint) {
        return goldTxTotal;
    }

    function getGoldTransaction(string _userId, uint _index) public constant returns(int) {
        require(_index &amp;lt; goldTxCounts[_userId]);
        return goldTxs[_userId][_index];
    }

    function getUserHotGoldBalance(string _userId) public constant returns(uint) {
        return goldHotBalances[_userId];
    }

    function addBuyTokensRequest(address _who, string _userId, string _requestHash) public onlyController returns(uint) {
        Request memory r;
        r.sender = _who;
        r.userId = _userId;
        r.requestHash = _requestHash;
        r.buyRequest = true;
        r.state = 0;

        requests[requestsCount] = r;
        uint out = requestsCount;
        requestsCount++;
        return out;
    }

    function addSellTokensRequest(address _who, string _userId, string _requestHash) onlyController returns(uint) {
        Request memory r;
        r.sender = _who;
        r.userId = _userId;
        r.requestHash = _requestHash;
        r.buyRequest = false;
        r.state = 0;

        requests[requestsCount] = r;
        uint out = requestsCount;
        requestsCount++;
        return out;
    }

    function getRequestsCount() public constant returns(uint) {
        return requestsCount;
    }

    function getRequest(uint _index) public constant returns(
        address a,
        bytes32 userId,
        bytes32 hashA, bytes32 hashB,
        bool buy, uint8 state)
    {
        require(_index &amp;lt; requestsCount);

        Request memory r = requests[_index];

        bytes32 userBytes = stringToBytes32(r.userId);
        var (out1, out2) = stringToBytes64(r.requestHash);

        return (r.sender, userBytes, out1, out2, r.buyRequest, r.state);
    }

    function cancelRequest(uint _index) onlyController public {
        require(_index &amp;lt; requestsCount);
        require(0==requests[_index].state);

        requests[_index].state = 2;
    }

    function setRequestProcessed(uint _index) onlyController public {
        requests[_index].state = 1;
    }
}

contract GoldFiatFee is CreatorEnabled, StringMover {
    string gmUserId = &amp;quot;&amp;quot;;

    // Functions:
    function GoldFiatFee(string _gmUserId) {
        creator = msg.sender;
        gmUserId = _gmUserId;
    }

    function getGoldmintFeeAccount() public constant returns(bytes32) {
        bytes32 userBytes = stringToBytes32(gmUserId);
        return userBytes;
    }

    function setGoldmintFeeAccount(string _gmUserId) public onlyCreator {
        gmUserId = _gmUserId;
    }

    function calculateBuyGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint) {
        return 0;
    }

    function calculateSellGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint) {
        // If the sender holds 0 MNTP, then the transaction fee is 3% fiat,
        // If the sender holds at least 10 MNTP, then the transaction fee is 2% fiat,
        // If the sender holds at least 1000 MNTP, then the transaction fee is 1.5% fiat,
        // If the sender holds at least 10000 MNTP, then the transaction fee is 1% fiat,
        if (_mntpBalance &amp;gt;= (10000 * 1 ether)) {
             return (75 * _goldValue / 10000);
        }

        if (_mntpBalance &amp;gt;= (1000 * 1 ether)) {
             return (15 * _goldValue / 1000);
        }

        if (_mntpBalance &amp;gt;= (10 * 1 ether)) {
             return (25 * _goldValue / 1000);
        }

        // 3%
        return (3 * _goldValue / 100);
    }
}

contract IGoldFiatFee {
    function getGoldmintFeeAccount()public constant returns(bytes32);
    function calculateBuyGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint);
    function calculateSellGoldFee(uint _mntpBalance, uint _goldValue) public constant returns(uint);
}

contract StorageController is SafeMath, CreatorEnabled, StringMover {
    Storage public stor;
    IMNTP public mntpToken;
    IGold public goldToken;
    IGoldFiatFee public fiatFee;

    address public ethDepositAddress = 0x0;
    address public managerAddress = 0x0;

    event NewTokenBuyRequest(address indexed _from, string indexed _userId);
    event NewTokenSellRequest(address indexed _from, string indexed _userId);
    event RequestCancelled(uint indexed _reqId);
    event RequestProcessed(uint indexed _reqId);
    event EthDeposited(uint indexed _requestId, address indexed _address, uint _ethValue);

    modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }

    function StorageController(address _mntpContractAddress, address _goldContractAddress, address _storageAddress, address _fiatFeeContract) {
        creator = msg.sender;

        if (0 != _storageAddress) {
             // use existing storage
             stor = Storage(_storageAddress);
        } else {
             stor = new Storage();
        }

        require(0x0!=_mntpContractAddress);
        require(0x0!=_goldContractAddress);
        require(0x0!=_fiatFeeContract);

        mntpToken = IMNTP(_mntpContractAddress);
        goldToken = IGold(_goldContractAddress);
        fiatFee = IGoldFiatFee(_fiatFeeContract);
    }

    function setEthDepositAddress(address _address) public onlyCreator {
       ethDepositAddress = _address;
    }

    function setManagerAddress(address _address) public onlyCreator {
       managerAddress = _address;
    }

    function getEthDepositAddress() public constant returns (address) {
       return ethDepositAddress;
    }

    // Only old controller can call setControllerAddress
    function changeController(address _newController) public onlyCreator {
        stor.setControllerAddress(_newController);
    }

    function setHotWalletAddress(address _hotWalletAddress) public onlyCreator {
       stor.setHotWalletAddress(_hotWalletAddress);
    }

    function getHotWalletAddress() public constant returns (address) {
        return stor.hotWalletAddress();
    }

    function changeFiatFeeContract(address _newFiatFee) public onlyCreator {
        fiatFee = IGoldFiatFee(_newFiatFee);
    }

    function addDoc(string _ipfsDocLink) public onlyCreator returns(uint) {
        return stor.addDoc(_ipfsDocLink);
    }

    function getDocCount() public constant returns (uint) {
        return stor.docCount();
    }

    function getDoc(uint _index) public constant returns (string) {
        var (x, y) = stor.getDocAsBytes64(_index);
        return bytes64ToString(x,y);
    }


    // _amountCents can be negative
    // returns index in user array
    function addFiatTransaction(string _userId, int _amountCents) public onlyManagerOrCreator returns(uint) {
        return stor.addFiatTransaction(_userId, _amountCents);
    }

    function getFiatTransactionsCount(string _userId) public constant returns (uint) {
        return stor.getFiatTransactionsCount(_userId);
    }

    function getAllFiatTransactionsCount() public constant returns (uint) {
        return stor.getAllFiatTransactionsCount();
    }

    function getFiatTransaction(string _userId, uint _index) public constant returns(int) {
        return stor.getFiatTransaction(_userId, _index);
    }

    function getUserFiatBalance(string _userId) public constant returns(uint) {
        return stor.getUserFiatBalance(_userId);
    }

    function addGoldTransaction(string _userId, int _amount) public onlyManagerOrCreator returns(uint) {
        return stor.addGoldTransaction(_userId, _amount);
    }

    function getGoldTransactionsCount(string _userId) public constant returns (uint) {
        return stor.getGoldTransactionsCount(_userId);
    }

    function getAllGoldTransactionsCount() public constant returns (uint) {
        return stor.getAllGoldTransactionsCount();
    }

    function getGoldTransaction(string _userId, uint _index) public constant returns(int) {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        return stor.getGoldTransaction(_userId, _index);
    }

    function getUserHotGoldBalance(string _userId) public constant returns(uint) {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        return stor.getUserHotGoldBalance(_userId);
    }


    function addBuyTokensRequest(string _userId, string _requestHash) public returns(uint) {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        NewTokenBuyRequest(msg.sender, _userId);
        return stor.addBuyTokensRequest(msg.sender, _userId, _requestHash);
    }

    function addSellTokensRequest(string _userId, string _requestHash) public returns(uint) {
      require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

      NewTokenSellRequest(msg.sender, _userId);

    return stor.addSellTokensRequest(msg.sender, _userId, _requestHash);
    }

    function getRequestsCount() public constant returns(uint) {
        return stor.getRequestsCount();
    }

    function getRequest(uint _index) public constant returns(address, string, string, bool, uint8) {
        var (sender, userIdBytes, hashA, hashB, buy, state) = stor.getRequest(_index);

        string memory userId = bytes32ToString(userIdBytes);
        string memory hash = bytes64ToString(hashA, hashB);

        return (sender, userId, hash, buy, state);
    }

    function cancelRequest(uint _index) onlyManagerOrCreator public {
        RequestCancelled(_index);
        stor.cancelRequest(_index);
    }

    function processRequest(uint _index, uint _amountCents, uint _centsPerGold) onlyManagerOrCreator public {
        require(_index &amp;lt; getRequestsCount());

        var (sender, userId, hash, isBuy, state) = getRequest(_index);
        require(0 == state);

        if (isBuy) {
             processBuyRequest(userId, sender, _amountCents, _centsPerGold);
        } else {
             processSellRequest(userId, sender, _amountCents, _centsPerGold);
        }

        // 3 - update state
        stor.setRequestProcessed(_index);

        // 4 - send event
        RequestProcessed(_index);
    }

    function processBuyRequest(string _userId, address _userAddress, uint _amountCents, uint _centsPerGold) internal {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        uint userFiatBalance = getUserFiatBalance(_userId);
        require(userFiatBalance &amp;gt; 0);

        if (_amountCents &amp;gt; userFiatBalance) {
             _amountCents = userFiatBalance;
        }

        uint userMntpBalance = mntpToken.balanceOf(_userAddress);
        uint fee = fiatFee.calculateBuyGoldFee(userMntpBalance, _amountCents);
        require(_amountCents &amp;gt; fee);

        // 1 - issue tokens minus fee
        uint amountMinusFee = _amountCents;
        if (fee &amp;gt; 0) {
             amountMinusFee = safeSub(_amountCents, fee);
        }

        require(amountMinusFee &amp;gt; 0);

        uint tokens = (uint(amountMinusFee) * 1 ether) / _centsPerGold;
        issueGoldTokens(_userAddress, tokens);

        // request from hot wallet
        if (isHotWallet(_userAddress)) {
          addGoldTransaction(_userId, int(tokens));
        }

        // 2 - add fiat tx
        // negative for buy (total amount including fee!)
        addFiatTransaction(_userId, - int(_amountCents));

        // 3 - send fee to Goldmint
        // positive for sell
        if (fee &amp;gt; 0) {
             string memory gmAccount = bytes32ToString(fiatFee.getGoldmintFeeAccount());
             addFiatTransaction(gmAccount, int(fee));
        }
    }

    function processSellRequest(string _userId, address _userAddress, uint _amountCents, uint _centsPerGold) internal {
        require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

        uint tokens = (uint(_amountCents) * 1 ether) / _centsPerGold;
        uint tokenBalance = goldToken.balanceOf(_userAddress);

        if (isHotWallet(_userAddress)) {
            tokenBalance = getUserHotGoldBalance(_userId);
        }

        if (tokenBalance &amp;lt; tokens) {
             tokens = tokenBalance;
             _amountCents = uint((tokens * _centsPerGold) / 1 ether);
        }

        burnGoldTokens(_userAddress, tokens);

        // request from hot wallet
        if (isHotWallet(_userAddress)) {
          addGoldTransaction(_userId, - int(tokens));
        }

        // 2 - add fiat tx
        uint userMntpBalance = mntpToken.balanceOf(_userAddress);
        uint fee = fiatFee.calculateSellGoldFee(userMntpBalance, _amountCents);
        require(_amountCents &amp;gt; fee);

        uint amountMinusFee = _amountCents;

        if (fee &amp;gt; 0) {
             amountMinusFee = safeSub(_amountCents, fee);
        }

        require(amountMinusFee &amp;gt; 0);
        // positive for sell
        addFiatTransaction(_userId, int(amountMinusFee));

        // 3 - send fee to Goldmint
        if (fee &amp;gt; 0) {
             string memory gmAccount = bytes32ToString(fiatFee.getGoldmintFeeAccount());
             addFiatTransaction(gmAccount, int(fee));
        }
    }

    //////// INTERNAL REQUESTS FROM HOT WALLET
    function processInternalRequest(string _userId, bool _isBuy, uint _amountCents, uint _centsPerGold) onlyManagerOrCreator public {
      if (_isBuy) {
          processBuyRequest(_userId, getHotWalletAddress(), _amountCents, _centsPerGold);
      } else {
          processSellRequest(_userId, getHotWalletAddress(), _amountCents, _centsPerGold);
      }
    }

    function transferGoldFromHotWallet(address _to, uint _value, string _userId) onlyManagerOrCreator public {
      require(keccak256(_userId) != keccak256(&amp;quot;&amp;quot;));

      uint balance = getUserHotGoldBalance(_userId);
      require(balance &amp;gt;= _value);

      goldToken.burnTokens(getHotWalletAddress(), _value);
      goldToken.issueTokens(_to, _value);

      addGoldTransaction(_userId, -int(_value));
    }

    ////////
    function issueGoldTokens(address _userAddress, uint _tokenAmount) internal {
        require(0!=_tokenAmount);
        goldToken.issueTokens(_userAddress, _tokenAmount);
    }

    function burnGoldTokens(address _userAddress, uint _tokenAmount) internal {
        require(0!=_tokenAmount);
        goldToken.burnTokens(_userAddress, _tokenAmount);
    }

    function isHotWallet(address _address) internal returns(bool) {
       return _address == getHotWalletAddress();
    }

    ///////
    function depositEth(uint _requestId) public payable {
      require(ethDepositAddress != 0x0);
      //min deposit is 0.01 ETH
      require(msg.value &amp;gt;= 0.01 * 1 ether);

      ethDepositAddress.transfer(msg.value);

      EthDeposited(_requestId, msg.sender, msg.value);
    }

    // do not allow to send money to this contract...
    function() external payable {
      revert();
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xa2f1b3a623d26a3a234222b4a9c6be3fbdffe5e0.sol" target="_blank" title="show github file">0xa2f1b3a623d26a3a234222b4a9c6be3fbdffe5e0.sol</a>
        </div>
        <div class="path">solidity-files/0xa2f1b3a623d26a3a234222b4a9c6be3fbdffe5e0.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.11;



/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {

  function mul(uint256 a, uint256 b) internal constant returns (uint256) {

    uint256 c = a * b;

    assert(a == 0 || c / a == b);

    return c;

  }



  function div(uint256 a, uint256 b) internal constant returns (uint256) {

    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0

    uint256 c = a / b;

    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold

    return c;

  }



  function sub(uint256 a, uint256 b) internal constant returns (uint256) {

    assert(b &amp;lt;= a);

    return a - b;

  }



  function add(uint256 a, uint256 b) internal constant returns (uint256) {

    uint256 c = a + b;

    assert(c &amp;gt;= a);

    return c;

  }

}



/**

 * @title Crowdsale

 * @dev Crowdsale is a base contract for managing a token crowdsale.

 * Crowdsales have a start and end timestamps, where investors can make

 * token purchases and the crowdsale will assign them tokens based

 * on a token per ETH rate. Funds collected are forwarded to a wallet

 * as they arrive.

 */

contract token { function transfer(address receiver, uint amount){  } }

contract Crowdsale {

  using SafeMath for uint256;



  // uint256 durationInMinutes;

  // address where funds are collected

  address public wallet;

  // token address

  address addressOfTokenUsedAsReward;



  token tokenReward;







  // start and end timestamps where investments are allowed (both inclusive)

  uint256 public startTime;

  uint256 public endTime;

  // amount of raised money in wei

  uint256 public weiRaised;



  /**

   * event for token purchase logging

   * @param purchaser who paid for the tokens

   * @param beneficiary who got the tokens

   * @param value weis paid for purchase

   * @param amount amount of tokens purchased

   */

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);





  function Crowdsale() {

    wallet = 0xF7aD11BF346851d09EAA53Ca8Dd020b61925dca5;

    // durationInMinutes = _durationInMinutes;

    addressOfTokenUsedAsReward = 0x82B99C8a12B6Ee50191B9B2a03B9c7AEF663D527;





    tokenReward = token(addressOfTokenUsedAsReward);

  }



  bool started = false;



  function startSale(uint256 delay){

    if (msg.sender != wallet || started) throw;

    startTime = now + delay * 1 minutes;

    endTime = startTime + 20 * 24 * 60 * 1 minutes;

    started = true;

  }



  // fallback function can be used to buy tokens

  function () payable {

    buyTokens(msg.sender);

  }



  // low level token purchase function

  function buyTokens(address beneficiary) payable {

    require(beneficiary != 0x0);

    require(validPurchase());



    uint256 weiAmount = msg.value;



    // calculate token amount to be sent

    uint256 tokens = (weiAmount/10**10) * 490;



    if(now &amp;lt; startTime + 1*7*24*60* 1 minutes){

      tokens += (tokens * 20) / 100;

    }else if(now &amp;lt; startTime + 2*7*24*60* 1 minutes){

      tokens += (tokens * 10) / 100;

    }else{

      tokens += (tokens * 5) / 100;

    }



    // update state

    weiRaised = weiRaised.add(weiAmount);



    tokenReward.transfer(beneficiary, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();

  }



  // send ether to the fund collection wallet

  // override to create custom fund forwarding mechanisms

  function forwardFunds() internal {

    // wallet.transfer(msg.value);

    if (!wallet.send(msg.value)) {

      throw;

    }

  }



  // @return true if the transaction can buy tokens

  function validPurchase() internal constant returns (bool) {

    bool withinPeriod = now &amp;gt;= startTime &amp;amp;&amp;amp; now &amp;lt;= endTime;

    bool nonZeroPurchase = msg.value != 0;

    return withinPeriod &amp;amp;&amp;amp; nonZeroPurchase;

  }



  // @return true if crowdsale event has ended

  function hasEnded() public constant returns (bool) {

    return now &amp;gt; endTime;

  }



  function withdrawTokens(uint256 _amount) {

    if(msg.sender!=wallet) throw;

    tokenReward.transfer(wallet,_amount);

  }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xbf3883dfcc9323ba8c7fe43a1f21ac1fd41e2aa0.sol" target="_blank" title="show github file">0xbf3883dfcc9323ba8c7fe43a1f21ac1fd41e2aa0.sol</a>
        </div>
        <div class="path">solidity-files/0xbf3883dfcc9323ba8c7fe43a1f21ac1fd41e2aa0.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

interface ERC20 {
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
}

interface TokenConfigInterface {
    function admin() public returns(address);
    function claimAdmin() public;
    function transferAdminQuickly(address newAdmin) public;

    // network
    function listPairForReserve(address reserve, address src, address dest, bool add) public;
}


contract TokenAdder {
    TokenConfigInterface public network = TokenConfigInterface(0xD2D21FdeF0D054D2864ce328cc56D1238d6b239e);
    address public reserve = address(0xE1213e46EfCb8785B47AE0620a51F490F747F1Da);

    address public ETH = 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;
    ERC20 public ADX = ERC20(0x4470BB87d77b963A013DB939BE332f927f2b992e);
    ERC20 public AST = ERC20(0x27054b13b1b798b345b591a4d22e6562d47ea75a);
    ERC20 public RCN = ERC20(0xf970b8e36e23f7fc3fd752eea86f8be8d83375a6);
    ERC20 public RDN = ERC20(0x255aa6df07540cb5d3d297f0d0d4d84cb52bc8e6);
    ERC20 public OMG = ERC20(0xd26114cd6EE289AccF82350c8d8487fedB8A0C07);
    ERC20 public KNC = ERC20(0xdd974D5C2e2928deA5F71b9825b8b646686BD200);
    ERC20 public EOS = ERC20(0x86Fa049857E0209aa7D9e616F7eb3b3B78ECfdb0);
    ERC20 public SNT = ERC20(0x744d70fdbe2ba4cf95131626614a1763df805b9e);
    ERC20 public ELF = ERC20(0xbf2179859fc6d5bee9bf9158632dc51678a4100e);
    ERC20 public POWR = ERC20(0x595832f8fc6bf59c85c527fec3740a1b7a361269);
    ERC20 public MANA = ERC20(0x0f5d2fb29fb7d3cfee444a200298f468908cc942);
    ERC20 public BAT = ERC20(0x0d8775f648430679a709e98d2b0cb6250d2887ef);
    ERC20 public REQ = ERC20(0x8f8221afbb33998d8584a2b05749ba73c37a938a);
    ERC20 public GTO = ERC20(0xc5bbae50781be1669306b9e001eff57a2957b09d);
    ERC20 public ENG = ERC20(0xf0ee6b27b759c9893ce4f094b49ad28fd15a23e4);

    address[] public newTokens = [
        REQ,
        ENG,
        ADX,
        AST,
        RCN];

    function TokenAdder(TokenConfigInterface _network, address _reserve, address _admin) public {
        network = _network;
        reserve = _reserve;
    }

    function listPairs() public {
        address orgAdmin = network.admin();
        network.claimAdmin();

        for (uint i = 0; i &amp;lt; newTokens.length; i++) {
            network.listPairForReserve(reserve, ETH, newTokens[i], true);
            network.listPairForReserve(reserve, newTokens[i], ETH, true);
        }

        network.transferAdminQuickly(orgAdmin);
        require(orgAdmin == network.admin());
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xD6B6a6258a521036dFa4b2C1b8B633ae89BB8F53.sol" target="_blank" title="show github file">0xD6B6a6258a521036dFa4b2C1b8B633ae89BB8F53.sol</a>
        </div>
        <div class="path">solidity-files/0xD6B6a6258a521036dFa4b2C1b8B633ae89BB8F53.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity 0.4.15;

contract ERC20Interface {
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approved(address indexed _owner, address indexed _spender, uint256 _value);

    function totalSupply() constant returns (uint256 supply);
    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
    function approve(address _spender, uint256 _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
}

contract UBTFreeze {
    address constant public RECEIVER = 0xa814147abAB7B7C4AE0914F9aF9EeaE201454219;
    uint constant public DEADLINE = 1554912000; // April 10th 2019, 2pm CET
    ERC20Interface constant UBT = ERC20Interface(0x8400D94A5cb0fa0D041a3788e395285d61c9ee5e);

    function transferAfterDeadline() returns(bool) {
        require(now &amp;gt; DEADLINE);
        require(UBT.transfer(RECEIVER, UBT.balanceOf(this)));
        return true;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x6171c17ed30be5b63cff75c002fb98f7cf689d1f.sol" target="_blank" title="show github file">0x6171c17ed30be5b63cff75c002fb98f7cf689d1f.sol</a>
        </div>
        <div class="path">solidity-files/0x6171c17ed30be5b63cff75c002fb98f7cf689d1f.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.16;

contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }

contract AOMcoinERC20 is owned {
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address =&amp;gt; uint256) public balanceOf;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);

    /**
     * Constrctor function
     */
    function AOMcoinERC20(
    ) public {
        totalSupply = 17500000 * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;               
        name = &amp;quot;AOM Coin&amp;quot;;                                  
        symbol = &amp;quot;A0M&amp;quot;;                             
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] &amp;gt;= _value);
        // Check for overflows
        require(balanceOf[_to] + _value &amp;gt; balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` on behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value &amp;lt;= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] &amp;gt;= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] &amp;gt;= _value);                // Check if the targeted balance is enough
        require(_value &amp;lt;= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender&amp;#39;s allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x61bb1aebd701245644302b1cd515a216328c0589.sol" target="_blank" title="show github file">0x61bb1aebd701245644302b1cd515a216328c0589.sol</a>
        </div>
        <div class="path">solidity-files/0x61bb1aebd701245644302b1cd515a216328c0589.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;ACT246906&amp;#39; token contract
//
// Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
// Symbol      : ACT246906
// Name        : ADZbuzz Unexplained-mysteries.com Community Token
// Total supply: 2000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function ADZbuzzCommunityToken() public {
        symbol = &amp;quot;ACT246906&amp;quot;;
        name = &amp;quot;ADZbuzz Unexplained-mysteries.com Community Token&amp;quot;;
        decimals = 8;
        _totalSupply = 200000000000000;
        balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
        emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x8a3f56e30fbca174a1910a63b8113e62d1a54668.sol" target="_blank" title="show github file">0x8a3f56e30fbca174a1910a63b8113e62d1a54668.sol</a>
        </div>
        <div class="path">solidity-files/0x8a3f56e30fbca174a1910a63b8113e62d1a54668.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT123728&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT123728
    // Name        : ADZbuzz Megaworldcorp.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT123728&amp;quot;;
            name = &amp;quot;ADZbuzz Megaworldcorp.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x6f91e584f4c150951386b133e21aa769c8b7d060.sol" target="_blank" title="show github file">0x6f91e584f4c150951386b133e21aa769c8b7d060.sol</a>
        </div>
        <div class="path">solidity-files/0x6f91e584f4c150951386b133e21aa769c8b7d060.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  
  event Transfer(address indexed _from, address indexed _to, uint _value);
  //event Transfer(address indexed from, address indexed to, uint256 value);
}


/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  
  event Approval(address indexed _owner, address indexed _spender, uint _value);
  //event Approval(address indexed owner, address indexed spender, uint256 value);
}




/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances. 
 */
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address =&amp;gt; uint256) balances;

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of. 
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }

}


/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

  mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amout of tokens to be transfered
   */
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value &amp;lt;= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    //balances[_from] = balances[_from].sub(_value); // this was removed
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifing the amount of tokens still avaible for the spender.
   */
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

}


/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}

contract BigbomContributorWhiteList is Ownable {
    mapping(address=&amp;gt;uint) public addressMinCap;
    mapping(address=&amp;gt;uint) public addressMaxCap;

    function BigbomContributorWhiteList() public  {}

    event ListAddress( address _user, uint _mincap, uint _maxcap, uint _time );

    // Owner can delist by setting cap = 0.
    // Onwer can also change it at any time
    function listAddress( address _user, uint _mincap, uint _maxcap ) public onlyOwner {
        require(_mincap &amp;lt;= _maxcap);
        require(_user != address(0x0));

        addressMinCap[_user] = _mincap;
        addressMaxCap[_user] = _maxcap;
        ListAddress( _user, _mincap, _maxcap, now );
    }

    // an optimization in case of network congestion
    function listAddresses( address[] _users, uint[] _mincap, uint[] _maxcap ) public  onlyOwner {
        require(_users.length == _mincap.length );
        require(_users.length == _maxcap.length );
        for( uint i = 0 ; i &amp;lt; _users.length ; i++ ) {
            listAddress( _users[i], _mincap[i], _maxcap[i] );
        }
    }

    function getMinCap( address _user ) public constant returns(uint) {
        return addressMinCap[_user];
    }
    function getMaxCap( address _user ) public constant returns(uint) {
        return addressMaxCap[_user];
    }

}

contract BigbomPrivateSaleList is Ownable {
    mapping(address=&amp;gt;uint) public addressCap;

    function BigbomPrivateSaleList() public  {}

    event ListAddress( address _user, uint _amount, uint _time );

    // Owner can delist by setting amount = 0.
    // Onwer can also change it at any time
    function listAddress( address _user, uint _amount ) public onlyOwner {
        require(_user != address(0x0));

        addressCap[_user] = _amount;
        ListAddress( _user, _amount, now );
    }

    // an optimization in case of network congestion
    function listAddresses( address[] _users, uint[] _amount ) public onlyOwner {
        require(_users.length == _amount.length );
        for( uint i = 0 ; i &amp;lt; _users.length ; i++ ) {
            listAddress( _users[i], _amount[i] );
        }
    }

    function getCap( address _user ) public constant returns(uint) {
        return addressCap[_user];
    }

}

contract BigbomToken is StandardToken, Ownable {
    
    string  public  constant name = &amp;quot;Bigbom&amp;quot;;
    string  public  constant symbol = &amp;quot;BBO&amp;quot;;
    uint    public  constant decimals = 18;
    uint    public   totalSupply = 2000000000 * 1e18; //2,000,000,000

    uint    public  constant founderAmount = 200000000 * 1e18; // 200,000,000
    uint    public  constant coreStaffAmount = 60000000 * 1e18; // 60,000,000
    uint    public  constant advisorAmount = 140000000 * 1e18; // 140,000,000
    uint    public  constant networkGrowthAmount = 600000000 * 1e18; //600,000,000
    uint    public  constant reserveAmount = 635000000 * 1e18; // 635,000,000
    uint    public  constant bountyAmount = 40000000 * 1e18; // 40,000,000
    uint    public  constant publicSaleAmount = 275000000 * 1e18; // 275,000,000

    address public   bbFounderCoreStaffWallet ;
    address public   bbAdvisorWallet;
    address public   bbAirdropWallet;
    address public   bbNetworkGrowthWallet;
    address public   bbReserveWallet;
    address public   bbPublicSaleWallet;

    uint    public  saleStartTime;
    uint    public  saleEndTime;

    address public  tokenSaleContract;
    BigbomPrivateSaleList public privateSaleList;

    mapping (address =&amp;gt; bool) public frozenAccount;
    mapping (address =&amp;gt; uint) public frozenTime;
    mapping (address =&amp;gt; uint) public maxAllowedAmount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen, uint _seconds);
   

    function checkMaxAllowed(address target)  public constant  returns (uint) {
        var maxAmount  = balances[target];
        if(target == bbFounderCoreStaffWallet){
            maxAmount = 10000000 * 1e18;
        }
        if(target == bbAdvisorWallet){
            maxAmount = 10000000 * 1e18;
        }
        if(target == bbAirdropWallet){
            maxAmount = 40000000 * 1e18;
        }
        if(target == bbNetworkGrowthWallet){
            maxAmount = 20000000 * 1e18;
        }
        if(target == bbReserveWallet){
            maxAmount = 6350000 * 1e18;
        }
        return maxAmount;
    }

    function selfFreeze(bool freeze, uint _seconds) public {
        // selfFreeze cannot more than 7 days
        require(_seconds &amp;lt;= 7 * 24 * 3600);
        // if unfreeze
        if(!freeze){
            // get End time of frozenAccount
            var frozenEndTime = frozenTime[msg.sender];
            // if now &amp;gt; frozenEndTime
            require (now &amp;gt;= frozenEndTime);
            // unfreeze account
            frozenAccount[msg.sender] = freeze;
            // set time to 0
            _seconds = 0;           
        }else{
            frozenAccount[msg.sender] = freeze;
            
        }
        // set endTime = now + _seconds to freeze
        frozenTime[msg.sender] = now + _seconds;
        FrozenFunds(msg.sender, freeze, _seconds);
        
    }

    function freezeAccount(address target, bool freeze, uint _seconds) onlyOwner public {
        
        // if unfreeze
        if(!freeze){
            // get End time of frozenAccount
            var frozenEndTime = frozenTime[target];
            // if now &amp;gt; frozenEndTime
            require (now &amp;gt;= frozenEndTime);
            // unfreeze account
            frozenAccount[target] = freeze;
            // set time to 0
            _seconds = 0;           
        }else{
            frozenAccount[target] = freeze;
            
        }
        // set endTime = now + _seconds to freeze
        frozenTime[target] = now + _seconds;
        FrozenFunds(target, freeze, _seconds);
        
    }

    modifier validDestination( address to ) {
        require(to != address(0x0));
        require(to != address(this) );
        require(!frozenAccount[to]);                       // Check if recipient is frozen
        _;
    }
    modifier validFrom(address from){
        require(!frozenAccount[from]);                     // Check if sender is frozen
        _;
    }
    modifier onlyWhenTransferEnabled() {
        if( now &amp;lt;= saleEndTime &amp;amp;&amp;amp; now &amp;gt;= saleStartTime ) {
            require( msg.sender == tokenSaleContract );
        }
        _;
    }
    modifier onlyPrivateListEnabled(address _to){
        require(now &amp;lt;= saleStartTime);
        uint allowcap = privateSaleList.getCap(_to);
        require (allowcap &amp;gt; 0);
        _;
    }
    function setPrivateList(BigbomPrivateSaleList _privateSaleList)   onlyOwner public {
        require(_privateSaleList != address(0x0));
        privateSaleList = _privateSaleList;

    }
    
    function BigbomToken(uint startTime, uint endTime, address admin, address _bbFounderCoreStaffWallet, address _bbAdvisorWallet,
        address _bbAirdropWallet,
        address _bbNetworkGrowthWallet,
        address _bbReserveWallet, 
        address _bbPublicSaleWallet
        ) public {

        require(admin!=address(0x0));
        require(_bbAirdropWallet!=address(0x0));
        require(_bbAdvisorWallet!=address(0x0));
        require(_bbReserveWallet!=address(0x0));
        require(_bbNetworkGrowthWallet!=address(0x0));
        require(_bbFounderCoreStaffWallet!=address(0x0));
        require(_bbPublicSaleWallet!=address(0x0));

        // Mint all tokens. Then disable minting forever.
        balances[msg.sender] = totalSupply;
        Transfer(address(0x0), msg.sender, totalSupply);
        // init internal amount limit
        // set address when deploy
        bbAirdropWallet = _bbAirdropWallet;
        bbAdvisorWallet = _bbAdvisorWallet;
        bbReserveWallet = _bbReserveWallet;
        bbNetworkGrowthWallet = _bbNetworkGrowthWallet;
        bbFounderCoreStaffWallet = _bbFounderCoreStaffWallet;
        bbPublicSaleWallet = _bbPublicSaleWallet;
        
        saleStartTime = startTime;
        saleEndTime = endTime;
        transferOwnership(admin); // admin could drain tokens that were sent here by mistake
    }

    function setTimeSale(uint startTime, uint endTime) onlyOwner public {
        require (now &amp;lt; saleStartTime || now &amp;gt; saleEndTime);
        require (now &amp;lt; startTime);
        require ( startTime &amp;lt; endTime);
        saleStartTime = startTime;
        saleEndTime = endTime;
    }

    function setTokenSaleContract(address _tokenSaleContract) onlyOwner public {
        // check address ! 0
        require(_tokenSaleContract != address(0x0));
        // do not allow run when saleStartTime &amp;lt;= now &amp;lt;= saleEndTime
        require (now &amp;lt; saleStartTime || now &amp;gt; saleEndTime);

        tokenSaleContract = _tokenSaleContract;
    }
    function transfer(address _to, uint _value)
        onlyWhenTransferEnabled
        validDestination(_to)
        validFrom(msg.sender)
        public 
        returns (bool) {
        if (msg.sender == bbFounderCoreStaffWallet || msg.sender == bbAdvisorWallet|| 
            msg.sender == bbAirdropWallet|| msg.sender == bbNetworkGrowthWallet|| msg.sender == bbReserveWallet){

            // check maxAllowedAmount
            var withdrawAmount =  maxAllowedAmount[msg.sender]; 
            var defaultAllowAmount = checkMaxAllowed(msg.sender);
            var maxAmount = defaultAllowAmount - withdrawAmount;
            // _value transfer must &amp;lt;= maxAmount
            require(maxAmount &amp;gt;= _value); // 

            // if maxAmount = 0, need to block this msg.sender
            if(maxAmount==_value){
               
                var isTransfer = super.transfer(_to, _value);
                 // freeze account
                selfFreeze(true, 24 * 3600); // temp freeze account 24h
                maxAllowedAmount[msg.sender] = 0;
                return isTransfer;
            }else{
                // set max withdrawAmount
                maxAllowedAmount[msg.sender] = maxAllowedAmount[msg.sender].add(_value); // 
                
            }
        }
        return  super.transfer(_to, _value);
            
    }

    function transferPrivateSale(address _to, uint _value)
        onlyOwner
        onlyPrivateListEnabled(_to) 
        public 
        returns (bool) {
         return transfer( _to,  _value);
    }

    function transferFrom(address _from, address _to, uint _value)
        onlyWhenTransferEnabled
        validDestination(_to)
        validFrom(_from)
        public 
        returns (bool) {
            if (_from == bbFounderCoreStaffWallet || _from == bbAdvisorWallet|| 
                _from == bbAirdropWallet|| _from == bbNetworkGrowthWallet|| _from == bbReserveWallet){

                  // check maxAllowedAmount
                var withdrawAmount =  maxAllowedAmount[_from]; 
                var defaultAllowAmount = checkMaxAllowed(_from);
                var maxAmount = defaultAllowAmount - withdrawAmount; 
                // _value transfer must &amp;lt;= maxAmount
                require(maxAmount &amp;gt;= _value); 

                // if maxAmount = 0, need to block this _from
                if(maxAmount==_value){
                   
                    var isTransfer = super.transfer(_to, _value);
                     // freeze account
                    selfFreeze(true, 24 * 3600); 
                    maxAllowedAmount[_from] = 0;
                    return isTransfer;
                }else{
                    // set max withdrawAmount
                    maxAllowedAmount[_from] = maxAllowedAmount[_from].add(_value); 
                    
                }
            }
            return super.transferFrom(_from, _to, _value);
    }

    event Burn(address indexed _burner, uint _value);

    function burn(uint _value) onlyWhenTransferEnabled
        public 
        returns (bool){
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(msg.sender, _value);
        Transfer(msg.sender, address(0x0), _value);
        return true;
    }

    // save some gas by making only one contract call
    function burnFrom(address _from, uint256 _value) onlyWhenTransferEnabled
        public 
        returns (bool) {
        assert( transferFrom( _from, msg.sender, _value ) );
        return burn(_value);
    }

    function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner public {
        token.transfer( owner, amount );
    }
}

contract BigbomTokenSale {
    address             public admin;
    address             public bigbomMultiSigWallet;
    BigbomToken         public token;
    uint                public raisedWei;
    bool                public haltSale;
    uint                      public openSaleStartTime;
    uint                      public openSaleEndTime;
    BigbomContributorWhiteList public list;

    mapping(address=&amp;gt;uint)    public participated;

    using SafeMath for uint;

    function BigbomTokenSale( address _admin,
                              address _bigbomMultiSigWallet,
                              BigbomContributorWhiteList _whilteListContract,
                              uint _publicSaleStartTime,
                              uint _publicSaleEndTime,
                              BigbomToken _token) public       
    {
        require (_publicSaleStartTime &amp;lt; _publicSaleEndTime);
        require (_admin != address(0x0));
        require (_bigbomMultiSigWallet != address(0x0));
        require (_whilteListContract != address(0x0));
        require (_token != address(0x0));

        admin = _admin;
        bigbomMultiSigWallet = _bigbomMultiSigWallet;
        list = _whilteListContract;
        openSaleStartTime = _publicSaleStartTime;
        openSaleEndTime = _publicSaleEndTime;
        token = _token;
    }
    
    function saleEnded() public constant returns(bool) {
        return now &amp;gt; openSaleEndTime;
    }

    function saleStarted() public constant returns(bool) {
        return now &amp;gt;= openSaleStartTime;
    }

    function setHaltSale( bool halt ) public {
        require( msg.sender == admin );
        haltSale = halt;
    }
    // this is a seperate function so user could query it before crowdsale starts
    function contributorMinCap( address contributor ) public constant returns(uint) {
        return list.getMinCap( contributor );
    }
    function contributorMaxCap( address contributor, uint amountInWei ) public constant returns(uint) {
        uint cap = list.getMaxCap( contributor );
        if( cap == 0 ) return 0;
        uint remainedCap = cap.sub( participated[ contributor ] );

        if( remainedCap &amp;gt; amountInWei ) return amountInWei;
        else return remainedCap;
    }

    function checkMaxCap( address contributor, uint amountInWei ) internal returns(uint) {
        uint result = contributorMaxCap( contributor, amountInWei );
        participated[contributor] = participated[contributor].add( result );
        return result;
    }

    function() payable public {
        buy( msg.sender );
    }



    function getBonus(uint _tokens) public view returns (uint){
        if (now &amp;gt; openSaleStartTime &amp;amp;&amp;amp; now &amp;lt;= (openSaleStartTime+3 days)){
            return _tokens.mul(25).div(100);
        }
        else
        {
            return 0;
        }
    }

    event Buy( address _buyer, uint _tokens, uint _payedWei, uint _bonus );
    function buy( address recipient ) payable public returns(uint){
        //require( tx.gasprice &amp;lt;= 50000000000 wei );

        require( ! haltSale );
        require( saleStarted() );
        require( ! saleEnded() );

        uint mincap = contributorMinCap(recipient);

        uint maxcap = checkMaxCap(recipient, msg.value );
        uint allowValue = msg.value;
        require( mincap &amp;gt; 0 );
        require( maxcap &amp;gt; 0 );
        // fail if msg.value &amp;lt; mincap
        require (msg.value &amp;gt;= mincap);
        // send to msg.sender, not to recipient if value &amp;gt; maxcap
        if( msg.value &amp;gt; maxcap  ) {
            allowValue = maxcap;
            //require (allowValue &amp;gt;= mincap);
            msg.sender.transfer( msg.value.sub( maxcap ) );
        }

        // send payment to wallet
        sendETHToMultiSig(allowValue);
        raisedWei = raisedWei.add( allowValue );
        // 1ETH = 20000 BBO
        uint recievedTokens = allowValue.mul( 20000 );
        // TODO bounce
        uint bonus = getBonus(recievedTokens);
        
        recievedTokens = recievedTokens.add(bonus);
        assert( token.transfer( recipient, recievedTokens ) );
        //

        Buy( recipient, recievedTokens, allowValue, bonus );

        return msg.value;
    }

    function sendETHToMultiSig( uint value ) internal {
        bigbomMultiSigWallet.transfer( value );
    }

    event FinalizeSale();
    // function is callable by everyone
    function finalizeSale() public {
        require( saleEnded() );
        //require( msg.sender == admin );

        // burn remaining tokens
        token.burn(token.balanceOf(this));

        FinalizeSale();
    }

    // ETH balance is always expected to be 0.
    // but in case something went wrong, we use this function to extract the eth.
    function emergencyDrain(ERC20 anyToken) public returns(bool){
        require( msg.sender == admin );
        require( saleEnded() );

        if( this.balance &amp;gt; 0 ) {
            sendETHToMultiSig( this.balance );
        }

        if( anyToken != address(0x0) ) {
            assert( anyToken.transfer(bigbomMultiSigWallet, anyToken.balanceOf(this)) );
        }

        return true;
    }

    // just to check that funds goes to the right place
    // tokens are not given in return
    function debugBuy() payable public {
        require( msg.value &amp;gt; 0 );
        sendETHToMultiSig( msg.value );
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x2b48d0f08d4db22fba7259bc67e6c920509813b9.sol" target="_blank" title="show github file">0x2b48d0f08d4db22fba7259bc67e6c920509813b9.sol</a>
        </div>
        <div class="path">solidity-files/0x2b48d0f08d4db22fba7259bc67e6c920509813b9.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

// File: contracts/BdpBaseData.sol

contract BdpBaseData {

	address public ownerAddress;

	address public managerAddress;

	address[16] public contracts;

	bool public paused = false;

	bool public setupCompleted = false;

	bytes8 public version;

}

// File: contracts/libraries/BdpContracts.sol

library BdpContracts {

	function getBdpEntryPoint(address[16] _contracts) pure internal returns (address) {
		return _contracts[0];
	}

	function getBdpController(address[16] _contracts) pure internal returns (address) {
		return _contracts[1];
	}

	function getBdpControllerHelper(address[16] _contracts) pure internal returns (address) {
		return _contracts[3];
	}

	function getBdpDataStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[4];
	}

	function getBdpImageStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[5];
	}

	function getBdpOwnershipStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[6];
	}

	function getBdpPriceStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[7];
	}

}

// File: contracts/BdpBase.sol

contract BdpBase is BdpBaseData {

	modifier onlyOwner() {
		require(msg.sender == ownerAddress);
		_;
	}

	modifier onlyAuthorized() {
		require(msg.sender == ownerAddress || msg.sender == managerAddress);
		_;
	}

	modifier whileContractIsActive() {
		require(!paused &amp;amp;&amp;amp; setupCompleted);
		_;
	}

	modifier storageAccessControl() {
		require(
			(! setupCompleted &amp;amp;&amp;amp; (msg.sender == ownerAddress || msg.sender == managerAddress))
			|| (setupCompleted &amp;amp;&amp;amp; !paused &amp;amp;&amp;amp; (msg.sender == BdpContracts.getBdpEntryPoint(contracts)))
		);
		_;
	}

	function setOwner(address _newOwner) external onlyOwner {
		require(_newOwner != address(0));
		ownerAddress = _newOwner;
	}

	function setManager(address _newManager) external onlyOwner {
		require(_newManager != address(0));
		managerAddress = _newManager;
	}

	function setContracts(address[16] _contracts) external onlyOwner {
		contracts = _contracts;
	}

	function pause() external onlyAuthorized {
		paused = true;
	}

	function unpause() external onlyOwner {
		paused = false;
	}

	function setSetupCompleted() external onlyOwner {
		setupCompleted = true;
	}

	function kill() public onlyOwner {
		selfdestruct(ownerAddress);
	}

}

// File: contracts/libraries/SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

	/**
	* @dev Multiplies two numbers, throws on overflow.
	*/
	function mul(uint256 a, uint256 b) internal pure returns (uint256) {
		if (a == 0) {
			return 0;
		}
		uint256 c = a * b;
		assert(c / a == b);
		return c;
	}

	/**
	* @dev Integer division of two numbers, truncating the quotient.
	*/
	function div(uint256 a, uint256 b) internal pure returns (uint256) {
		// assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
		uint256 c = a / b;
		// assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
		return c;
	}

	/**
	* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
	*/
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
		assert(b &amp;lt;= a);
		return a - b;
	}

	/**
	* @dev Adds two numbers, throws on overflow.
	*/
	function add(uint256 a, uint256 b) internal pure returns (uint256) {
		uint256 c = a + b;
		assert(c &amp;gt;= a);
		return c;
	}
}

// File: contracts/storage/BdpDataStorage.sol

contract BdpDataStorage is BdpBase {

	using SafeMath for uint256;

	struct Region {
		uint256 x1;
		uint256 y1;
		uint256 x2;
		uint256 y2;
		uint256 currentImageId;
		uint256 nextImageId;
		uint8[128] url;
		uint256 currentPixelPrice;
		uint256 blockUpdatedAt;
		uint256 updatedAt;
		uint256 purchasedAt;
		uint256 purchasedPixelPrice;
	}

	uint256 public lastRegionId = 0;

	mapping (uint256 =&amp;gt; Region) public data;


	function getLastRegionId() view public returns (uint256) {
		return lastRegionId;
	}

	function getNextRegionId() public storageAccessControl returns (uint256) {
		lastRegionId = lastRegionId.add(1);
		return lastRegionId;
	}

	function deleteRegionData(uint256 _id) public storageAccessControl {
		delete data[_id];
	}

	function getRegionCoordinates(uint256 _id) view public returns (uint256, uint256, uint256, uint256) {
		return (data[_id].x1, data[_id].y1, data[_id].x2, data[_id].y2);
	}

	function setRegionCoordinates(uint256 _id, uint256 _x1, uint256 _y1, uint256 _x2, uint256 _y2) public storageAccessControl {
		data[_id].x1 = _x1;
		data[_id].y1 = _y1;
		data[_id].x2 = _x2;
		data[_id].y2 = _y2;
	}

	function getRegionCurrentImageId(uint256 _id) view public returns (uint256) {
		return data[_id].currentImageId;
	}

	function setRegionCurrentImageId(uint256 _id, uint256 _currentImageId) public storageAccessControl {
		data[_id].currentImageId = _currentImageId;
	}

	function getRegionNextImageId(uint256 _id) view public returns (uint256) {
		return data[_id].nextImageId;
	}

	function setRegionNextImageId(uint256 _id, uint256 _nextImageId) public storageAccessControl {
		data[_id].nextImageId = _nextImageId;
	}

	function getRegionUrl(uint256 _id) view public returns (uint8[128]) {
		return data[_id].url;
	}

	function setRegionUrl(uint256 _id, uint8[128] _url) public storageAccessControl {
		data[_id].url = _url;
	}

	function getRegionCurrentPixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].currentPixelPrice;
	}

	function setRegionCurrentPixelPrice(uint256 _id, uint256 _currentPixelPrice) public storageAccessControl {
		data[_id].currentPixelPrice = _currentPixelPrice;
	}

	function getRegionBlockUpdatedAt(uint256 _id) view public returns (uint256) {
		return data[_id].blockUpdatedAt;
	}

	function setRegionBlockUpdatedAt(uint256 _id, uint256 _blockUpdatedAt) public storageAccessControl {
		data[_id].blockUpdatedAt = _blockUpdatedAt;
	}

	function getRegionUpdatedAt(uint256 _id) view public returns (uint256) {
		return data[_id].updatedAt;
	}

	function setRegionUpdatedAt(uint256 _id, uint256 _updatedAt) public storageAccessControl {
		data[_id].updatedAt = _updatedAt;
	}

	function getRegionPurchasedAt(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedAt;
	}

	function setRegionPurchasedAt(uint256 _id, uint256 _purchasedAt) public storageAccessControl {
		data[_id].purchasedAt = _purchasedAt;
	}

	function getRegionUpdatedAtPurchasedAt(uint256 _id) view public returns (uint256 _updatedAt, uint256 _purchasedAt) {
		return (data[_id].updatedAt, data[_id].purchasedAt);
	}

	function getRegionPurchasePixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedPixelPrice;
	}

	function setRegionPurchasedPixelPrice(uint256 _id, uint256 _purchasedPixelPrice) public storageAccessControl {
		data[_id].purchasedPixelPrice = _purchasedPixelPrice;
	}

	function BdpDataStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/storage/BdpPriceStorage.sol

contract BdpPriceStorage is BdpBase {

	uint64[1001] public pricePoints;

	uint256 public pricePointsLength = 0;

	address public forwardPurchaseFeesTo = address(0);

	address public forwardUpdateFeesTo = address(0);


	function getPricePointsLength() view public returns (uint256) {
		return pricePointsLength;
	}

	function getPricePoint(uint256 _i) view public returns (uint256) {
		return pricePoints[_i];
	}

	function setPricePoints(uint64[] _pricePoints) public storageAccessControl {
		pricePointsLength = 0;
		appendPricePoints(_pricePoints);
	}

	function appendPricePoints(uint64[] _pricePoints) public storageAccessControl {
		for (uint i = 0; i &amp;lt; _pricePoints.length; i++) {
			pricePoints[pricePointsLength++] = _pricePoints[i];
		}
	}

	function getForwardPurchaseFeesTo() view public returns (address) {
		return forwardPurchaseFeesTo;
	}

	function setForwardPurchaseFeesTo(address _forwardPurchaseFeesTo) public storageAccessControl {
		forwardPurchaseFeesTo = _forwardPurchaseFeesTo;
	}

	function getForwardUpdateFeesTo() view public returns (address) {
		return forwardUpdateFeesTo;
	}

	function setForwardUpdateFeesTo(address _forwardUpdateFeesTo) public storageAccessControl {
		forwardUpdateFeesTo = _forwardUpdateFeesTo;
	}

	function BdpPriceStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/libraries/BdpCalculator.sol

library BdpCalculator {

	using SafeMath for uint256;

	function calculateArea(address[16] _contracts, uint256 _regionId) view public returns (uint256 _area, uint256 _width, uint256 _height) {
		var (x1, y1, x2, y2) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCoordinates(_regionId);
		_width = x2 - x1 + 1;
		_height = y2 - y1 + 1;
		_area = _width * _height;
	}

	function countPurchasedPixels(address[16] _contracts) view public returns (uint256 _count) {
		var lastRegionId = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getLastRegionId();
		for (uint256 i = 0; i &amp;lt;= lastRegionId; i++) {
			if(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionPurchasedAt(i) &amp;gt; 0) { // region is purchased
				var (area,,) = calculateArea(_contracts, i);
				_count += area;
			}
		}
	}

	function calculateCurrentMarketPixelPrice(address[16] _contracts) view public returns(uint) {
		return calculateMarketPixelPrice(_contracts, countPurchasedPixels(_contracts));
	}

	function calculateMarketPixelPrice(address[16] _contracts, uint _pixelsSold) view public returns(uint) {
		var pricePointsLength = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePointsLength();
		uint mod = _pixelsSold % (1000000 / (pricePointsLength - 1));
		uint div = _pixelsSold * (pricePointsLength - 1) / 1000000;
		var divPoint = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div);
		if(mod == 0) return divPoint;
		return divPoint + mod * (BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div+1) - divPoint) * (pricePointsLength - 1) / 1000000;
	}

	function calculateAveragePixelPrice(address[16] _contracts, uint _a, uint _b) view public returns (uint _price) {
		_price = (calculateMarketPixelPrice(_contracts, _a) + calculateMarketPixelPrice(_contracts, _b)) / 2;
	}

	/** Current market price per pixel for this region if it is the first sale of this region
	  */
	function calculateRegionInitialSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		require(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAt(_regionId) &amp;gt; 0); // region exists
		var purchasedPixels = countPurchasedPixels(_contracts);
		var (area,,) = calculateArea(_contracts, _regionId);
		return calculateAveragePixelPrice(_contracts, purchasedPixels, purchasedPixels + area);
	}

	/** Current market price or (Current market price)*3 if the region was sold
	  */
	function calculateRegionSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		var pixelPrice = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCurrentPixelPrice(_regionId);
		if(pixelPrice &amp;gt; 0) {
			return pixelPrice * 3;
		} else {
			return calculateRegionInitialSalePixelPrice(_contracts, _regionId);
		}
	}

	/** Setup is allowed one whithin one day after purchase
	  */
	function calculateSetupAllowedUntil(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		var (updatedAt, purchasedAt) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAtPurchasedAt(_regionId);
		if(updatedAt != purchasedAt) {
			return 0;
		} else {
			return purchasedAt + 1 days;
		}
	}

}

// File: contracts/storage/BdpImageStorage.sol

contract BdpImageStorage is BdpBase {

	using SafeMath for uint256;

	struct Image {
		address owner;
		uint256 regionId;
		uint256 currentRegionId;
		mapping(uint16 =&amp;gt; uint256[1000]) data;
		mapping(uint16 =&amp;gt; uint16) dataLength;
		uint16 partsCount;
		uint16 width;
		uint16 height;
		uint16 imageDescriptor;
		uint256 blurredAt;
	}

	uint256 public lastImageId = 0;

	mapping(uint256 =&amp;gt; Image) public images;


	function getLastImageId() view public returns (uint256) {
		return lastImageId;
	}

	function getNextImageId() public storageAccessControl returns (uint256) {
		lastImageId = lastImageId.add(1);
		return lastImageId;
	}

	function createImage(address _owner, uint256 _regionId, uint16 _width, uint16 _height, uint16 _partsCount, uint16 _imageDescriptor) public storageAccessControl returns (uint256) {
		require(_owner != address(0) &amp;amp;&amp;amp; _width &amp;gt; 0 &amp;amp;&amp;amp; _height &amp;gt; 0 &amp;amp;&amp;amp; _partsCount &amp;gt; 0 &amp;amp;&amp;amp; _imageDescriptor &amp;gt; 0);
		uint256 id = getNextImageId();
		images[id].owner = _owner;
		images[id].regionId = _regionId;
		images[id].width = _width;
		images[id].height = _height;
		images[id].partsCount = _partsCount;
		images[id].imageDescriptor = _imageDescriptor;
		return id;
	}

	function imageExists(uint256 _imageId) view public returns (bool) {
		return _imageId &amp;gt; 0 &amp;amp;&amp;amp; images[_imageId].owner != address(0);
	}

	function deleteImage(uint256 _imageId) public storageAccessControl {
		require(imageExists(_imageId));
		delete images[_imageId];
	}

	function getImageOwner(uint256 _imageId) public view returns (address) {
		require(imageExists(_imageId));
		return images[_imageId].owner;
	}

	function setImageOwner(uint256 _imageId, address _owner) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].owner = _owner;
	}

	function getImageRegionId(uint256 _imageId) public view returns (uint256) {
		require(imageExists(_imageId));
		return images[_imageId].regionId;
	}

	function setImageRegionId(uint256 _imageId, uint256 _regionId) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].regionId = _regionId;
	}

	function getImageCurrentRegionId(uint256 _imageId) public view returns (uint256) {
		require(imageExists(_imageId));
		return images[_imageId].currentRegionId;
	}

	function setImageCurrentRegionId(uint256 _imageId, uint256 _currentRegionId) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].currentRegionId = _currentRegionId;
	}

	function getImageData(uint256 _imageId, uint16 _part) view public returns (uint256[1000]) {
		require(imageExists(_imageId));
		return images[_imageId].data[_part];
	}

	function setImageData(uint256 _imageId, uint16 _part, uint256[] _data) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].dataLength[_part] = uint16(_data.length);
		for (uint256 i = 0; i &amp;lt; _data.length; i++) {
			images[_imageId].data[_part][i] = _data[i];
		}
	}

	function getImageDataLength(uint256 _imageId, uint16 _part) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].dataLength[_part];
	}

	function setImageDataLength(uint256 _imageId, uint16 _part, uint16 _dataLength) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].dataLength[_part] = _dataLength;
	}

	function getImagePartsCount(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].partsCount;
	}

	function setImagePartsCount(uint256 _imageId, uint16 _partsCount) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].partsCount = _partsCount;
	}

	function getImageWidth(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].width;
	}

	function setImageWidth(uint256 _imageId, uint16 _width) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].width = _width;
	}

	function getImageHeight(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].height;
	}

	function setImageHeight(uint256 _imageId, uint16 _height) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].height = _height;
	}

	function getImageDescriptor(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].imageDescriptor;
	}

	function setImageDescriptor(uint256 _imageId, uint16 _imageDescriptor) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].imageDescriptor = _imageDescriptor;
	}

	function getImageBlurredAt(uint256 _imageId) view public returns (uint256) {
		return images[_imageId].blurredAt;
	}

	function setImageBlurredAt(uint256 _imageId, uint256 _blurredAt) public storageAccessControl {
		images[_imageId].blurredAt = _blurredAt;
	}

	function imageUploadComplete(uint256 _imageId) view public returns (bool) {
		require(imageExists(_imageId));
		for (uint16 i = 1; i &amp;lt;= images[_imageId].partsCount; i++) {
			if(images[_imageId].data[i].length == 0) {
				return false;
			}
		}
		return true;
	}

	function BdpImageStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/storage/BdpOwnershipStorage.sol

contract BdpOwnershipStorage is BdpBase {

	using SafeMath for uint256;

	// Mapping from token ID to owner
	mapping (uint256 =&amp;gt; address) public tokenOwner;

	// Mapping from token ID to approved address
	mapping (uint256 =&amp;gt; address) public tokenApprovals;

	// Mapping from owner to the sum of owned area
	mapping (address =&amp;gt; uint256) public ownedArea;

	// Mapping from owner to list of owned token IDs
	mapping (address =&amp;gt; uint256[]) public ownedTokens;

	// Mapping from token ID to index of the owner tokens list
	mapping(uint256 =&amp;gt; uint256) public ownedTokensIndex;

	// All tokens list tokens ids
	uint256[] public tokenIds;

	// Mapping from tokenId to index of the tokens list
	mapping (uint256 =&amp;gt; uint256) public tokenIdsIndex;


	function getTokenOwner(uint256 _tokenId) view public returns (address) {
		return tokenOwner[_tokenId];
	}

	function setTokenOwner(uint256 _tokenId, address _owner) public storageAccessControl {
		tokenOwner[_tokenId] = _owner;
	}

	function getTokenApproval(uint256 _tokenId) view public returns (address) {
		return tokenApprovals[_tokenId];
	}

	function setTokenApproval(uint256 _tokenId, address _to) public storageAccessControl {
		tokenApprovals[_tokenId] = _to;
	}

	function getOwnedArea(address _owner) view public returns (uint256) {
		return ownedArea[_owner];
	}

	function setOwnedArea(address _owner, uint256 _area) public storageAccessControl {
		ownedArea[_owner] = _area;
	}

	function incrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].add(_area);
		return ownedArea[_owner];
	}

	function decrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].sub(_area);
		return ownedArea[_owner];
	}

	function getOwnedTokensLength(address _owner) view public returns (uint256) {
		return ownedTokens[_owner].length;
	}

	function getOwnedToken(address _owner, uint256 _index) view public returns (uint256) {
		return ownedTokens[_owner][_index];
	}

	function setOwnedToken(address _owner, uint256 _index, uint256 _tokenId) public storageAccessControl {
		ownedTokens[_owner][_index] = _tokenId;
	}

	function pushOwnedToken(address _owner, uint256 _tokenId) public storageAccessControl returns (uint256) {
		ownedTokens[_owner].push(_tokenId);
		return ownedTokens[_owner].length;
	}

	function decrementOwnedTokensLength(address _owner) public storageAccessControl {
		ownedTokens[_owner].length--;
	}

	function getOwnedTokensIndex(uint256 _tokenId) view public returns (uint256) {
		return ownedTokensIndex[_tokenId];
	}

	function setOwnedTokensIndex(uint256 _tokenId, uint256 _tokenIndex) public storageAccessControl {
		ownedTokensIndex[_tokenId] = _tokenIndex;
	}

	function getTokenIdsLength() view public returns (uint256) {
		return tokenIds.length;
	}

	function getTokenIdByIndex(uint256 _index) view public returns (uint256) {
		return tokenIds[_index];
	}

	function setTokenIdByIndex(uint256 _index, uint256 _tokenId) public storageAccessControl {
		tokenIds[_index] = _tokenId;
	}

	function pushTokenId(uint256 _tokenId) public storageAccessControl returns (uint256) {
		tokenIds.push(_tokenId);
		return tokenIds.length;
	}

	function decrementTokenIdsLength() public storageAccessControl {
		tokenIds.length--;
	}

	function getTokenIdsIndex(uint256 _tokenId) view public returns (uint256) {
		return tokenIdsIndex[_tokenId];
	}

	function setTokenIdsIndex(uint256 _tokenId, uint256 _tokenIdIndex) public storageAccessControl {
		tokenIdsIndex[_tokenId] = _tokenIdIndex;
	}

	function BdpOwnershipStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/libraries/BdpOwnership.sol

/**
 * Ownership manager
 * Does not check if the caller is allowed to call functions
 * State changing methods are not intended to be called from controller
 */
library BdpOwnership {

	using SafeMath for uint256;

	event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

	event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

	function ownerOf(address[16] _contracts, uint256 _tokenId) public view returns (address) {
		var owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);
		require(owner != address(0));
		return owner;
	}

	function balanceOf(address[16] _contracts, address _owner) public view returns (uint256) {
		return BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getOwnedTokensLength(_owner);
	}

	function approve(address[16] _contracts, address _to, uint256 _tokenId) public {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		address owner = ownerOf(_contracts, _tokenId);
		require(_to != owner);
		if (ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0) {
			ownStorage.setTokenApproval(_tokenId, _to);
			Approval(owner, _to, _tokenId);
		}
	}

	/**
	 * @dev Clear current approval of a given token ID
	 * @param _tokenId uint256 ID of the token to be transferred
	 */
	function clearApproval(address[16] _contracts, address _owner, uint256 _tokenId) public {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownerOf(_contracts, _tokenId) == _owner);
		if (ownStorage.getTokenApproval(_tokenId) != 0) {
			BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).setTokenApproval(_tokenId, 0);
			Approval(_owner, 0, _tokenId);
		}
	}

	/**
	 * @dev Clear current approval and transfer the ownership of a given token ID
	 * @param _from address which you want to send tokens from
	 * @param _to address which you want to transfer the token to
	 * @param _tokenId uint256 ID of the token to be transferred
	 */
	function clearApprovalAndTransfer(address[16] _contracts, address _from, address _to, uint256 _tokenId) public {
		require(_to != address(0));
		require(_to != ownerOf(_contracts, _tokenId));
		require(ownerOf(_contracts, _tokenId) == _from);

		clearApproval(_contracts, _from, _tokenId);
		removeToken(_contracts, _from, _tokenId);
		addToken(_contracts, _to, _tokenId);
		Transfer(_from, _to, _tokenId);
	}

	/**
	 * @dev Internal function to add a token ID to the list of a given address
	 * @param _to address representing the new owner of the given token ID
	 * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address
	 */
	function addToken(address[16] _contracts, address _to, uint256 _tokenId) private {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownStorage.getTokenOwner(_tokenId) == address(0));

		// Set token owner
		ownStorage.setTokenOwner(_tokenId, _to);

		// Add token to tokenIds list
		var tokenIdsLength = ownStorage.pushTokenId(_tokenId);
		ownStorage.setTokenIdsIndex(_tokenId, tokenIdsLength.sub(1));

		uint256 ownedTokensLength = ownStorage.getOwnedTokensLength(_to);

		// Add token to ownedTokens list
		ownStorage.pushOwnedToken(_to, _tokenId);
		ownStorage.setOwnedTokensIndex(_tokenId, ownedTokensLength);

		// Increment total owned area
		var (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);
		ownStorage.incrementOwnedArea(_to, area);
	}

	/**
	 * @dev Internal function to remove a token ID from the list of a given address
	 * @param _from address representing the previous owner of the given token ID
	 * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address
	 */
	function removeToken(address[16] _contracts, address _from, uint256 _tokenId) private {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownerOf(_contracts, _tokenId) == _from);

		// Clear token owner
		ownStorage.setTokenOwner(_tokenId, 0);

		removeFromTokenIds(ownStorage, _tokenId);
		removeFromOwnedToken(ownStorage, _from, _tokenId);

		// Decrement total owned area
		var (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);
		ownStorage.decrementOwnedArea(_from, area);
	}

	/**
	 * @dev Remove token from ownedTokens list
	 * Note that this will handle single-element arrays. In that case, both ownedTokenIndex and lastOwnedTokenIndex are going to
	 * be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping
	 * the lastOwnedToken to the first position, and then dropping the element placed in the last position of the list
	 */
	function removeFromOwnedToken(BdpOwnershipStorage _ownStorage, address _from, uint256 _tokenId) private {
		var ownedTokenIndex = _ownStorage.getOwnedTokensIndex(_tokenId);
		var lastOwnedTokenIndex = _ownStorage.getOwnedTokensLength(_from).sub(1);
		var lastOwnedToken = _ownStorage.getOwnedToken(_from, lastOwnedTokenIndex);
		_ownStorage.setOwnedToken(_from, ownedTokenIndex, lastOwnedToken);
		_ownStorage.setOwnedToken(_from, lastOwnedTokenIndex, 0);
		_ownStorage.decrementOwnedTokensLength(_from);
		_ownStorage.setOwnedTokensIndex(_tokenId, 0);
		_ownStorage.setOwnedTokensIndex(lastOwnedToken, ownedTokenIndex);
	}

	/**
	 * @dev Remove token from tokenIds list
	 */
	function removeFromTokenIds(BdpOwnershipStorage _ownStorage, uint256 _tokenId) private {
		var tokenIndex = _ownStorage.getTokenIdsIndex(_tokenId);
		var lastTokenIdIndex = _ownStorage.getTokenIdsLength().sub(1);
		var lastTokenId = _ownStorage.getTokenIdByIndex(lastTokenIdIndex);
		_ownStorage.setTokenIdByIndex(tokenIndex, lastTokenId);
		_ownStorage.setTokenIdByIndex(lastTokenIdIndex, 0);
		_ownStorage.decrementTokenIdsLength();
		_ownStorage.setTokenIdsIndex(_tokenId, 0);
		_ownStorage.setTokenIdsIndex(lastTokenId, tokenIndex);
	}

	/**
	 * @dev Mint token function
	 * @param _to The address that will own the minted token
	 * @param _tokenId uint256 ID of the token to be minted by the msg.sender
	 */
	function mint(address[16] _contracts, address _to, uint256 _tokenId) public {
		require(_to != address(0));
		addToken(_contracts, _to, _tokenId);
		Transfer(address(0), _to, _tokenId);
	}

	/**
	 * @dev Burns a specific token
	 * @param _tokenId uint256 ID of the token being burned
	 */
	function burn(address[16] _contracts, uint256 _tokenId) public {
		address owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);
		clearApproval(_contracts, owner, _tokenId);
		removeToken(_contracts, owner, _tokenId);
		Transfer(owner, address(0), _tokenId);
	}

}

// File: contracts/libraries/BdpImage.sol

library BdpImage {

	function checkImageInput(address[16] _contracts, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, bool _clearImage) view public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));

		require( (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage) // Only one way to change image can be specified
			|| (_imageId != 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage) // If image has to be changed
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length != 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage)
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; _swapImages &amp;amp;&amp;amp; !_clearImage)
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; _clearImage) );

		require(_imageId == 0 || // Can use only own images not used by other regions
			( (msg.sender == imageStorage.getImageOwner(_imageId)) &amp;amp;&amp;amp; (imageStorage.getImageCurrentRegionId(_imageId) == 0) ) );

		var nextImageId = dataStorage.getRegionNextImageId(_regionId);
		require(!_swapImages || imageUploadComplete(_contracts, nextImageId)); // Can swap images if next image upload is complete
	}

	function setNextImagePart(address[16] _contracts, uint256 _regionId, uint16 _part, uint16 _partsCount, uint16 _imageDescriptor, uint256[] _imageData) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));

		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		require(_imageData.length != 0);
		require(_part &amp;gt; 0);
		require(_part &amp;lt;= _partsCount);

		var nextImageId = dataStorage.getRegionNextImageId(_regionId);
		if(nextImageId == 0 || _imageDescriptor != imageStorage.getImageDescriptor(nextImageId)) {
			var (, width, height) = BdpCalculator.calculateArea(_contracts, _regionId);
			nextImageId = imageStorage.createImage(msg.sender, _regionId, uint16(width), uint16(height), _partsCount, _imageDescriptor);
			dataStorage.setRegionNextImageId(_regionId, nextImageId);
		}

		imageStorage.setImageData(nextImageId, _part, _imageData);
	}

	function setImageOwner(address[16] _contracts, uint256 _imageId, address _owner) public {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		require(imageStorage.getImageOwner(_imageId) == msg.sender);
		require(_owner != address(0));

		imageStorage.setImageOwner(_imageId, _owner);
	}

	function setImageData(address[16] _contracts, uint256 _imageId, uint16 _part, uint256[] _imageData) public returns (address) {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		require(imageStorage.getImageOwner(_imageId) == msg.sender);
		require(imageStorage.getImageCurrentRegionId(_imageId) == 0);
		require(_imageData.length != 0);
		require(_part &amp;gt; 0);
		require(_part &amp;lt;= imageStorage.getImagePartsCount(_imageId));

		imageStorage.setImageData(_imageId, _part, _imageData);
	}

	function imageUploadComplete(address[16] _contracts, uint256 _imageId) view public returns (bool) {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		var partsCount = imageStorage.getImagePartsCount(_imageId);
		for (uint16 i = 1; i &amp;lt;= partsCount; i++) {
			if(imageStorage.getImageDataLength(_imageId, i) == 0) {
				return false;
			}
		}
		return true;
	}

}

// File: contracts/controller/BdpControllerHelper.sol

contract BdpControllerHelper is BdpBase {

	// BdpCalculator

	function calculateArea(uint256 _regionId) view public returns (uint256 _area, uint256 _width, uint256 _height) {
		return BdpCalculator.calculateArea(contracts, _regionId);
	}

	function countPurchasedPixels() view public returns (uint256 _count) {
		return BdpCalculator.countPurchasedPixels(contracts);
	}

	function calculateCurrentMarketPixelPrice() view public returns(uint) {
		return BdpCalculator.calculateCurrentMarketPixelPrice(contracts);
	}

	function calculateMarketPixelPrice(uint _pixelsSold) view public returns(uint) {
		return BdpCalculator.calculateMarketPixelPrice(contracts, _pixelsSold);
	}

	function calculateAveragePixelPrice(uint _a, uint _b) view public returns (uint _price) {
		return BdpCalculator.calculateAveragePixelPrice(contracts, _a, _b);
	}

	function calculateRegionInitialSalePixelPrice(uint256 _regionId) view public returns (uint256) {
		return BdpCalculator.calculateRegionInitialSalePixelPrice(contracts, _regionId);
	}

	function calculateRegionSalePixelPrice(uint256 _regionId) view public returns (uint256) {
		return BdpCalculator.calculateRegionSalePixelPrice(contracts, _regionId);
	}

	function calculateSetupAllowedUntil(uint256 _regionId) view public returns (uint256) {
		return BdpCalculator.calculateSetupAllowedUntil(contracts, _regionId);
	}


	// BdpDataStorage

	function getLastRegionId() view public returns (uint256) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getLastRegionId();
	}

	function getRegionCoordinates(uint256 _regionId) view public returns (uint256, uint256, uint256, uint256) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionCoordinates(_regionId);
	}

	function getRegionCurrentImageId(uint256 _regionId) view public returns (uint256) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionCurrentImageId(_regionId);
	}

	function getRegionNextImageId(uint256 _regionId) view public returns (uint256) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionNextImageId(_regionId);
	}

	function getRegionUrl(uint256 _regionId) view public returns (uint8[128]) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionUrl(_regionId);
	}

	function getRegionCurrentPixelPrice(uint256 _regionId) view public returns (uint256) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionCurrentPixelPrice(_regionId);
	}

	function getRegionBlockUpdatedAt(uint256 _regionId) view public returns (uint256) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionBlockUpdatedAt(_regionId);
	}

	function getRegionUpdatedAt(uint256 _regionId) view public returns (uint256) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionUpdatedAt(_regionId);
	}

	function getRegionPurchasedAt(uint256 _regionId) view public returns (uint256) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionPurchasedAt(_regionId);
	}

	function getRegionPurchasePixelPrice(uint256 _regionId) view public returns (uint256) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionPurchasePixelPrice(_regionId);
	}

	function regionExists(uint _regionId) view public returns (bool) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionUpdatedAt(_regionId) &amp;gt; 0;
	}

	function regionsIsPurchased(uint _regionId) view public returns (bool) {
		return BdpDataStorage(BdpContracts.getBdpDataStorage(contracts)).getRegionPurchasedAt(_regionId) &amp;gt; 0;
	}


	// BdpImageStorage

	function createImage(address _owner, uint256 _regionId, uint16 _width, uint16 _height, uint16 _partsCount, uint16 _imageDescriptor) public onlyAuthorized returns (uint256) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).createImage(_owner, _regionId, _width, _height, _partsCount, _imageDescriptor);
	}

	function getImageRegionId(uint256 _imageId) view public returns (uint256) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageRegionId(_imageId);
	}

	function getImageCurrentRegionId(uint256 _imageId) view public returns (uint256) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageCurrentRegionId(_imageId);
	}

	function getImageOwner(uint256 _imageId) view public returns (address) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageOwner(_imageId);
	}

	function setImageOwner(uint256 _imageId, address _owner) public {
		BdpImage.setImageOwner(contracts, _imageId, _owner);
	}

	function getImageData(uint256 _imageId, uint16 _part) view public returns (uint256[1000]) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageData(_imageId, _part);
	}

	function setImageData(uint256 _imageId, uint16 _part, uint256[] _imageData) public returns (address) {
		BdpImage.setImageData(contracts, _imageId, _part, _imageData);
	}

	function getImageDataLength(uint256 _imageId, uint16 _part) view public returns (uint16) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageDataLength(_imageId, _part);
	}

	function getImagePartsCount(uint256 _imageId) view public returns (uint16) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImagePartsCount(_imageId);
	}

	function getImageWidth(uint256 _imageId) view public returns (uint16) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageWidth(_imageId);
	}

	function getImageHeight(uint256 _imageId) view public returns (uint16) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageHeight(_imageId);
	}

	function getImageDescriptor(uint256 _imageId) view public returns (uint16) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageDescriptor(_imageId);
	}

	function getImageBlurredAt(uint256 _imageId) view public returns (uint256) {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).getImageBlurredAt(_imageId);
	}

	function setImageBlurredAt(uint256 _imageId, uint256 _blurredAt) public onlyAuthorized {
		return BdpImageStorage(BdpContracts.getBdpImageStorage(contracts)).setImageBlurredAt(_imageId, _blurredAt);
	}

	function imageUploadComplete(uint256 _imageId) view public returns (bool) {
		return BdpImage.imageUploadComplete(contracts, _imageId);
	}


	// BdpPriceStorage

	function getForwardPurchaseFeesTo() view public returns (address) {
		return BdpPriceStorage(BdpContracts.getBdpPriceStorage(contracts)).getForwardPurchaseFeesTo();
	}

	function setForwardPurchaseFeesTo(address _forwardPurchaseFeesTo) public onlyOwner {
		BdpPriceStorage(BdpContracts.getBdpPriceStorage(contracts)).setForwardPurchaseFeesTo(_forwardPurchaseFeesTo);
	}

	function getForwardUpdateFeesTo() view public returns (address) {
		return BdpPriceStorage(BdpContracts.getBdpPriceStorage(contracts)).getForwardUpdateFeesTo();
	}

	function setForwardUpdateFeesTo(address _forwardUpdateFeesTo) public onlyOwner {
		BdpPriceStorage(BdpContracts.getBdpPriceStorage(contracts)).setForwardUpdateFeesTo(_forwardUpdateFeesTo);
	}

	function BdpControllerHelper(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xdf41d02dd21865d7d651aad3663de4186c8b763b.sol" target="_blank" title="show github file">0xdf41d02dd21865d7d651aad3663de4186c8b763b.sol</a>
        </div>
        <div class="path">solidity-files/0xdf41d02dd21865d7d651aad3663de4186c8b763b.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
    uint256 public totalSupply;
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b &amp;lt;= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c &amp;gt;= a);
        return c;
    }
}



/**
 * @title Basic contracts
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {
    using SafeMath for uint256;

    mapping(address =&amp;gt; uint256) balances;

    /**
    * @dev transfer contracts for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

}


/**
 * @title Burnable Token
 * @dev Token that can be irreversibly burned (destroyed).
 */
contract BurnableToken is BasicToken {

    event Burn(address indexed burner, uint256 value);

    /**
     * @dev Burns a specific amount of tokens.
     * @param _value The amount of contracts to be burned.
     */
    function burn(uint256 _value) public {
        require(_value &amp;lt;= balances[msg.sender]);
        // no need to require value &amp;lt;= totalSupply, since that would imply the
        // sender&amp;#39;s balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(burner, _value);
    }
}


/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}



/**
 * @title Standard ERC20 contracts
 *
 * @dev Implementation of the basic standard contracts.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;


    /**
     * @dev Transfer tokens from one address to another
     * @param _from address The address which you want to send tokens from
     * @param _to address The address which you want to transfer to
     * @param _value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[_from]);
        require(_value &amp;lt;= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     *
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param _spender The address which will spend the funds.
     * @param _value The amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }

    /**
     * @dev Increase the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _addedValue The amount of tokens to increase the allowance by.
     */
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    /**
     * @dev Decrease the amount of tokens that an owner allowed to a spender.
     *
     * approve should be called when allowed[_spender] == 0. To decrement
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     * @param _spender The address which will spend the funds.
     * @param _subtractedValue The amount of tokens to decrease the allowance by.
     */
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue &amp;gt; oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

}

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
    address public owner;


    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


    /**
     * @dev The Ownable constructor sets the original `owner` of the contract to the sender
     * account.
     */
    function Ownable() public {
        owner = msg.sender;
    }


    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }


    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

}



/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
    event Pause();
    event Unpause();

    bool public paused = false;


    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
        require(!paused);
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     */
    modifier whenPaused() {
        require(paused);
        _;
    }

    /**
     * @dev called by the owner to pause, triggers stopped state
     */
    function pause() onlyOwner whenNotPaused public {
        paused = true;
        emit Pause();
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() onlyOwner whenPaused public {
        paused = false;
        emit Unpause();
    }
}


/**
 * @title Pausable token
 *
 * @dev StandardToken modified with pausable transfers.
 **/

contract PausableToken is StandardToken, Pausable {

    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
        return super.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }

    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
        return super.approve(_spender, _value);
    }

    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
        return super.increaseApproval(_spender, _addedValue);
    }

    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
        return super.decreaseApproval(_spender, _subtractedValue);
    }

}

contract PAXToken is BurnableToken, PausableToken {

    using SafeMath for uint;

    string public constant name = &amp;quot;Pax Token&amp;quot;;

    string public constant symbol = &amp;quot;PAX&amp;quot;;

    uint32 public constant decimals = 10;

    uint256 public constant INITIAL_SUPPLY = 999500000 * (10 ** uint256(decimals));

    /**
     * @dev Constructor that gives msg.sender all of existing tokens.
     * @param _isPause bool (pause === true)
     */
    function PAXToken(bool _isPause) public {
        paused = _isPause;
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        emit Transfer(0x0, msg.sender, balances[msg.sender]);

    }

    /**
    * @dev transfer contracts for a specified address, despite the pause state
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function ownersTransfer(address _to, uint256 _value) public onlyOwner returns (bool) {
        return BasicToken.transfer(_to, _value);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x09966b580911448c5b0683ce9853aa951603ef50.sol" target="_blank" title="show github file">0x09966b580911448c5b0683ce9853aa951603ef50.sol</a>
        </div>
        <div class="path">solidity-files/0x09966b580911448c5b0683ce9853aa951603ef50.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT336781&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT336781
    // Name        : ADZbuzz Starwars.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT336781&amp;quot;;
            name = &amp;quot;ADZbuzz Starwars.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x872dd0a1141bb2ed4736d7af89495a07fb497b2b.sol" target="_blank" title="show github file">0x872dd0a1141bb2ed4736d7af89495a07fb497b2b.sol</a>
        </div>
        <div class="path">solidity-files/0x872dd0a1141bb2ed4736d7af89495a07fb497b2b.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT105263&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT105263
    // Name        : ADZbuzz Tripleclicks.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT105263&amp;quot;;
            name = &amp;quot;ADZbuzz Tripleclicks.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xa1b10d33f04b43c90b8af52a3c4ce3d92397727b.sol" target="_blank" title="show github file">0xa1b10d33f04b43c90b8af52a3c4ce3d92397727b.sol</a>
        </div>
        <div class="path">solidity-files/0xa1b10d33f04b43c90b8af52a3c4ce3d92397727b.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT239075&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT239075
    // Name        : ADZbuzz Gulfnews.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT239075&amp;quot;;
            name = &amp;quot;ADZbuzz Gulfnews.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x061269f5e74aa1c61618c8d332dd5b1ca7d7feed.sol" target="_blank" title="show github file">0x061269f5e74aa1c61618c8d332dd5b1ca7d7feed.sol</a>
        </div>
        <div class="path">solidity-files/0x061269f5e74aa1c61618c8d332dd5b1ca7d7feed.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;ACT232540&amp;#39; token contract
//
// Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
// Symbol      : ACT232540
// Name        : ADZbuzz Smithsonianmag.com Community Token
// Total supply: 2000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function ADZbuzzCommunityToken() public {
        symbol = &amp;quot;ACT232540&amp;quot;;
        name = &amp;quot;ADZbuzz Smithsonianmag.com Community Token&amp;quot;;
        decimals = 8;
        _totalSupply = 200000000000000;
        balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
        emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x00A4B757cB0B7cff002fCF075D896a77daC533D4.sol" target="_blank" title="show github file">0x00A4B757cB0B7cff002fCF075D896a77daC533D4.sol</a>
        </div>
        <div class="path">solidity-files/0x00A4B757cB0B7cff002fCF075D896a77daC533D4.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network 
// Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin

pragma solidity ^0.4.8;


/**
 * Math operations with safety checks
 */
contract SafeMath {
  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b &amp;gt; 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c&amp;gt;=a &amp;amp;&amp;amp; c&amp;gt;=b);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a &amp;gt;= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a &amp;lt; b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a &amp;gt;= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a &amp;lt; b ? a : b;
  }

}



/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}



/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * Safe unsigned safe math.
 *
 * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli
 *
 * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol
 *
 * Maintained here until merged to mainline zeppelin-solidity.
 *
 */
library SafeMathLibExt {

  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
    assert(b &amp;gt; 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c&amp;gt;=a);
    return c;
  }

}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */





/*
 * Haltable
 *
 * Abstract contract that allows children to implement an
 * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.
 *
 *
 * Originally envisioned in FirstBlood ICO contract.
 */
contract Haltable is Ownable {
  bool public halted;

  modifier stopInEmergency {
    if (halted) throw;
    _;
  }

  modifier stopNonOwnersInEmergency {
    if (halted &amp;amp;&amp;amp; msg.sender != owner) throw;
    _;
  }

  modifier onlyInEmergency {
    if (!halted) throw;
    _;
  }

  // called by the owner on emergency, triggers stopped state
  function halt() external onlyOwner {
    halted = true;
  }

  // called by the owner on end of emergency, returns to normal state
  function unhalt() external onlyOwner onlyInEmergency {
    halted = false;
  }

}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * Interface for defining crowdsale pricing.
 */
contract PricingStrategy {

  address public tier;

  /** Interface declaration. */
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  /** Self check if all references are correctly set.
   *
   * Checks that pricing strategy matches crowdsale parameters.
   */
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  /**
   * @dev Pricing tells if this is a presale purchase or not.
     @param purchaser Address of the purchaser
     @return False by default, true if a presale purchaser
   */
  function isPresalePurchase(address purchaser) public constant returns (bool) {
    return false;
  }

  /* How many weis one token costs */
  function updateRate(uint newOneTokenInWei) public;

  /**
   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.
   *
   *
   * @param value - What is the value of the transaction send in as wei
   * @param tokensSold - how much tokens have been sold this far
   * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale
   * @param msgSender - who is the investor of this transaction
   * @param decimals - how many decimal units the token has
   * @return Amount of tokens the investor receives
   */
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * Finalize agent defines what happens at the end of succeseful crowdsale.
 *
 * - Allocate tokens for founders, bounties and community
 * - Make tokens transferable
 * - etc.
 */
contract FinalizeAgent {

  bool public reservedTokensAreDistributed = false;

  function isFinalizeAgent() public constant returns(bool) {
    return true;
  }

  /** Return true if we can run finalizeCrowdsale() properly.
   *
   * This is a safety check function that doesn&amp;#39;t allow crowdsale to begin
   * unless the finalizer has been set up properly.
   */
  function isSane() public constant returns (bool);

  function distributeReservedTokens(uint reservedTokensDistributionBatch);

  /** Called once by crowdsale finalize() if the sale was success. */
  function finalizeCrowdsale();

}
/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */









/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}


/**
 * A token that defines fractional units as decimals.
 */
contract FractionalERC20Ext is ERC20 {

  uint public decimals;
  uint public minCap;

}



/**
 * Abstract base contract for token sales.
 *
 * Handle
 * - start and end dates
 * - accepting investments
 * - minimum funding goal and refund
 * - various statistics during the crowdfund
 * - different pricing strategies
 * - different investment policies (require server side customer id, allow only whitelisted addresses)
 *
 */
contract CrowdsaleExt is Haltable {

  /* Max investment count when we are still allowed to change the multisig address */
  uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;

  using SafeMathLibExt for uint;

  /* The token we are selling */
  FractionalERC20Ext public token;

  /* How we are going to price our offering */
  PricingStrategy public pricingStrategy;

  /* Post-success callback */
  FinalizeAgent public finalizeAgent;

  /* name of the crowdsale tier */
  string public name;

  /* tokens will be transfered from this address */
  address public multisigWallet;

  /* if the funding goal is not reached, investors may withdraw their funds */
  uint public minimumFundingGoal;

  /* the UNIX timestamp start date of the crowdsale */
  uint public startsAt;

  /* the UNIX timestamp end date of the crowdsale */
  uint public endsAt;

  /* the number of tokens already sold through this contract*/
  uint public tokensSold = 0;

  /* How many wei of funding we have raised */
  uint public weiRaised = 0;

  /* How many distinct addresses have invested */
  uint public investorCount = 0;

  /* Has this crowdsale been finalized */
  bool public finalized;

  bool public isWhiteListed;

  address[] public joinedCrowdsales;
  uint8 public joinedCrowdsalesLen = 0;
  uint8 public joinedCrowdsalesLenMax = 50;
  struct JoinedCrowdsaleStatus {
    bool isJoined;
    uint8 position;
  }
  mapping (address =&amp;gt; JoinedCrowdsaleStatus) joinedCrowdsaleState;

  /** How much ETH each address has invested to this crowdsale */
  mapping (address =&amp;gt; uint256) public investedAmountOf;

  /** How much tokens this crowdsale has credited for each investor address */
  mapping (address =&amp;gt; uint256) public tokenAmountOf;

  struct WhiteListData {
    bool status;
    uint minCap;
    uint maxCap;
  }

  //is crowdsale updatable
  bool public isUpdatable;

  /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */
  mapping (address =&amp;gt; WhiteListData) public earlyParticipantWhitelist;

  /** List of whitelisted addresses */
  address[] public whitelistedParticipants;

  /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */
  uint public ownerTestValue;

  /** State machine
   *
   * - Preparing: All contract initialization calls and variables have not been set yet
   * - Prefunding: We have not passed start time yet
   * - Funding: Active crowdsale
   * - Success: Minimum funding goal reached
   * - Failure: Minimum funding goal not reached before ending time
   * - Finalized: The finalized has been called and succesfully executed
   */
  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}

  // A new investment was made
  event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);

  // Address early participation whitelist status changed
  event Whitelisted(address addr, bool status, uint minCap, uint maxCap);
  event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);

  // Crowdsale start time has been changed
  event StartsAtChanged(uint newStartsAt);

  // Crowdsale end time has been changed
  event EndsAtChanged(uint newEndsAt);

  function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {

    owner = msg.sender;

    name = _name;

    token = FractionalERC20Ext(_token);

    setPricingStrategy(_pricingStrategy);

    multisigWallet = _multisigWallet;
    if(multisigWallet == 0) {
        throw;
    }

    if(_start == 0) {
        throw;
    }

    startsAt = _start;

    if(_end == 0) {
        throw;
    }

    endsAt = _end;

    // Don&amp;#39;t mess the dates
    if(startsAt &amp;gt;= endsAt) {
        throw;
    }

    // Minimum funding goal can be zero
    minimumFundingGoal = _minimumFundingGoal;

    isUpdatable = _isUpdatable;

    isWhiteListed = _isWhiteListed;
  }

  /**
   * Don&amp;#39;t expect to just send in money and get tokens.
   */
  function() payable {
    throw;
  }

  /**
   * Make an investment.
   *
   * Crowdsale must be running for one to invest.
   * We must have not pressed the emergency brake.
   *
   * @param receiver The Ethereum address who receives the tokens
   * @param customerId (optional) UUID v4 to track the successful payments on the server side
   *
   */
  function investInternal(address receiver, uint128 customerId) stopInEmergency private {

    // Determine if it&amp;#39;s a good time to accept investment from this participant
    if(getState() == State.PreFunding) {
      // Are we whitelisted for early deposit
      throw;
    } else if(getState() == State.Funding) {
      // Retail participants can only come in when the crowdsale is running
      // pass
      if(isWhiteListed) {
        if(!earlyParticipantWhitelist[receiver].status) {
          throw;
        }
      }
    } else {
      // Unwanted state
      throw;
    }

    uint weiAmount = msg.value;

    // Account presale sales separately, so that they do not count against pricing tranches
    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());

    if(tokenAmount == 0) {
      // Dust transaction
      throw;
    }

    if(isWhiteListed) {
      if(tokenAmount &amp;lt; earlyParticipantWhitelist[receiver].minCap &amp;amp;&amp;amp; tokenAmountOf[receiver] == 0) {
        // tokenAmount &amp;lt; minCap for investor
        throw;
      }

      // Check that we did not bust the investor&amp;#39;s cap
      if (isBreakingInvestorCap(receiver, tokenAmount)) {
        throw;
      }

      updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);
    } else {
      if(tokenAmount &amp;lt; token.minCap() &amp;amp;&amp;amp; tokenAmountOf[receiver] == 0) {
        throw;
      }
    }

    if(investedAmountOf[receiver] == 0) {
       // A new investor
       investorCount++;
    }

    // Update investor
    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);
    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);

    // Update totals
    weiRaised = weiRaised.plus(weiAmount);
    tokensSold = tokensSold.plus(tokenAmount);

    // Check that we did not bust the cap
    if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {
      throw;
    }

    assignTokens(receiver, tokenAmount);

    // Pocket the money
    if(!multisigWallet.send(weiAmount)) throw;

    // Tell us invest was success
    Invested(receiver, weiAmount, tokenAmount, customerId);
  }

  /**
   * Allow anonymous contributions to this crowdsale.
   */
  function invest(address addr) public payable {
    investInternal(addr, 0);
  }

  /**
   * The basic entry point to participate the crowdsale process.
   *
   * Pay for funding, get invested tokens back in the sender address.
   */
  function buy() public payable {
    invest(msg.sender);
  }

  function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {
    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != address(0)) {
      finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);
    }
  }

  function areReservedTokensDistributed() public constant returns (bool) {
    return finalizeAgent.reservedTokensAreDistributed();
  }

  function canDistributeReservedTokens() public constant returns(bool) {
    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if ((lastTierCntrct.getState() == State.Success) &amp;amp;&amp;amp; !lastTierCntrct.halted() &amp;amp;&amp;amp; !lastTierCntrct.finalized() &amp;amp;&amp;amp; !lastTierCntrct.areReservedTokensDistributed()) return true;
    return false;
  }

  /**
   * Finalize a succcesful crowdsale.
   *
   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.
   */
  function finalize() public inState(State.Success) onlyOwner stopInEmergency {

    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != address(0)) {
      finalizeAgent.finalizeCrowdsale();
    }

    finalized = true;
  }

  /**
   * Allow to (re)set finalize agent.
   *
   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.
   */
  function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {
    assert(address(addr) != address(0));
    assert(address(finalizeAgent) == address(0));
    finalizeAgent = addr;

    // Don&amp;#39;t allow setting bad agent
    if(!finalizeAgent.isFinalizeAgent()) {
      throw;
    }
  }

  /**
   * Allow addresses to do early participation.
   */
  function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {
    if (!isWhiteListed) throw;
    assert(addr != address(0));
    assert(maxCap &amp;gt; 0);
    assert(minCap &amp;lt;= maxCap);
    assert(now &amp;lt;= endsAt);

    if (!isAddressWhitelisted(addr)) {
      whitelistedParticipants.push(addr);
      Whitelisted(addr, status, minCap, maxCap);
    } else {
      WhitelistItemChanged(addr, status, minCap, maxCap);
    }

    earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});
  }

  function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {
    if (!isWhiteListed) throw;
    assert(now &amp;lt;= endsAt);
    assert(addrs.length == statuses.length);
    assert(statuses.length == minCaps.length);
    assert(minCaps.length == maxCaps.length);
    for (uint iterator = 0; iterator &amp;lt; addrs.length; iterator++) {
      setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);
    }
  }

  function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {
    if (!isWhiteListed) throw;
    if (tokensBought &amp;lt; earlyParticipantWhitelist[reciever].minCap &amp;amp;&amp;amp; tokenAmountOf[reciever] == 0) throw;

    uint8 tierPosition = getTierPosition(this);

    for (uint8 j = tierPosition + 1; j &amp;lt; joinedCrowdsalesLen; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);
    }
  }

  function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {
    if (!isWhiteListed) throw;
    assert(addr != address(0));
    assert(now &amp;lt;= endsAt);
    assert(isTierJoined(msg.sender));
    if (tokensBought &amp;lt; earlyParticipantWhitelist[addr].minCap &amp;amp;&amp;amp; tokenAmountOf[addr] == 0) throw;
    //if (addr != msg.sender &amp;amp;&amp;amp; contractAddr != msg.sender) throw;
    uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;
    newMaxCap = newMaxCap.minus(tokensBought);
    earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});
  }

  function isAddressWhitelisted(address addr) public constant returns(bool) {
    for (uint i = 0; i &amp;lt; whitelistedParticipants.length; i++) {
      if (whitelistedParticipants[i] == addr) {
        return true;
        break;
      }
    }

    return false;
  }

  function whitelistedParticipantsLength() public constant returns (uint) {
    return whitelistedParticipants.length;
  }

  function isTierJoined(address addr) public constant returns(bool) {
    return joinedCrowdsaleState[addr].isJoined;
  }

  function getTierPosition(address addr) public constant returns(uint8) {
    return joinedCrowdsaleState[addr].position;
  }

  function getLastTier() public constant returns(address) {
    if (joinedCrowdsalesLen &amp;gt; 0)
      return joinedCrowdsales[joinedCrowdsalesLen - 1];
    else
      return address(0);
  }

  function setJoinedCrowdsales(address addr) private onlyOwner {
    assert(addr != address(0));
    assert(joinedCrowdsalesLen &amp;lt;= joinedCrowdsalesLenMax);
    assert(!isTierJoined(addr));
    joinedCrowdsales.push(addr);
    joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({
      isJoined: true,
      position: joinedCrowdsalesLen
    });
    joinedCrowdsalesLen++;
  }

  function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {
    assert(addrs.length &amp;gt; 0);
    assert(joinedCrowdsalesLen == 0);
    assert(addrs.length &amp;lt;= joinedCrowdsalesLenMax);
    for (uint8 iter = 0; iter &amp;lt; addrs.length; iter++) {
      setJoinedCrowdsales(addrs[iter]);
    }
  }

  function setStartsAt(uint time) onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now &amp;lt;= time); // Don&amp;#39;t change past
    assert(time &amp;lt;= endsAt);
    assert(now &amp;lt;= startsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if (lastTierCntrct.finalized()) throw;

    uint8 tierPosition = getTierPosition(this);

    //start time should be greater then end time of previous tiers
    for (uint8 j = 0; j &amp;lt; tierPosition; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      assert(time &amp;gt;= crowdsale.endsAt());
    }

    startsAt = time;
    StartsAtChanged(startsAt);
  }

  /**
   * Allow crowdsale owner to close early or extend the crowdsale.
   *
   * This is useful e.g. for a manual soft cap implementation:
   * - after X amount is reached determine manual closing
   *
   * This may put the crowdsale to an invalid state,
   * but we trust owners know what they are doing.
   *
   */
  function setEndsAt(uint time) public onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now &amp;lt;= time);// Don&amp;#39;t change past
    assert(startsAt &amp;lt;= time);
    assert(now &amp;lt;= endsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if (lastTierCntrct.finalized()) throw;


    uint8 tierPosition = getTierPosition(this);

    for (uint8 j = tierPosition + 1; j &amp;lt; joinedCrowdsalesLen; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      assert(time &amp;lt;= crowdsale.startsAt());
    }

    endsAt = time;
    EndsAtChanged(endsAt);
  }

  /**
   * Allow to (re)set pricing strategy.
   *
   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.
   */
  function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {
    assert(address(_pricingStrategy) != address(0));
    assert(address(pricingStrategy) == address(0));
    pricingStrategy = _pricingStrategy;

    // Don&amp;#39;t allow setting bad agent
    if(!pricingStrategy.isPricingStrategy()) {
      throw;
    }
  }

  /**
   * Allow to change the team multisig address in the case of emergency.
   *
   * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun
   * (we have done only few test transactions). After the crowdsale is going
   * then multisig address stays locked for the safety reasons.
   */
  function setMultisig(address addr) public onlyOwner {

    // Change
    if(investorCount &amp;gt; MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {
      throw;
    }

    multisigWallet = addr;
  }

  /**
   * @return true if the crowdsale has raised enough money to be a successful.
   */
  function isMinimumGoalReached() public constant returns (bool reached) {
    return weiRaised &amp;gt;= minimumFundingGoal;
  }

  /**
   * Check if the contract relationship looks good.
   */
  function isFinalizerSane() public constant returns (bool sane) {
    return finalizeAgent.isSane();
  }

  /**
   * Check if the contract relationship looks good.
   */
  function isPricingSane() public constant returns (bool sane) {
    return pricingStrategy.isSane(address(this));
  }

  /**
   * Crowdfund state machine management.
   *
   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.
   */
  function getState() public constant returns (State) {
    if(finalized) return State.Finalized;
    else if (address(finalizeAgent) == 0) return State.Preparing;
    else if (!finalizeAgent.isSane()) return State.Preparing;
    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;
    else if (block.timestamp &amp;lt; startsAt) return State.PreFunding;
    else if (block.timestamp &amp;lt;= endsAt &amp;amp;&amp;amp; !isCrowdsaleFull()) return State.Funding;
    else if (isMinimumGoalReached()) return State.Success;
    else return State.Failure;
  }

  /** Interface marker. */
  function isCrowdsale() public constant returns (bool) {
    return true;
  }

  //
  // Modifiers
  //

  /** Modified allowing execution only if the crowdsale is currently running.  */
  modifier inState(State state) {
    if(getState() != state) throw;
    _;
  }


  //
  // Abstract functions
  //

  /**
   * Check if the current invested breaks our cap rules.
   *
   *
   * The child contract must define their own cap setting rules.
   * We allow a lot of flexibility through different capping strategies (ETH, token count)
   * Called from invest().
   *
   * @param weiAmount The amount of wei the investor tries to invest in the current transaction
   * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction
   * @param weiRaisedTotal What would be our total raised balance after this transaction
   * @param tokensSoldTotal What would be our total sold tokens count after this transaction
   *
   * @return true if taking this investment would break our cap rules
   */
  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);

  function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);

  /**
   * Check if the current crowdsale is full and we can no longer sell any tokens.
   */
  function isCrowdsaleFull() public constant returns (bool);

  /**
   * Create new tokens or transfer issued tokens to the investor depending on the cap model.
   */
  function assignTokens(address receiver, uint tokenAmount) private;
}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */








/**
 * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.
 *
 * Based on code by FirstBlood:
 * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, SafeMath {

  /* Token supply got increased and a new owner received these tokens */
  event Minted(address receiver, uint amount);

  /* Actual balances of token holders */
  mapping(address =&amp;gt; uint) balances;

  /* approve() allowances */
  mapping (address =&amp;gt; mapping (address =&amp;gt; uint)) allowed;

  /* Interface declaration */
  function isToken() public constant returns (bool weAre) {
    return true;
  }

  function transfer(address _to, uint _value) returns (bool success) {
    balances[msg.sender] = safeSub(balances[msg.sender], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
    uint _allowance = allowed[_from][msg.sender];

    balances[_to] = safeAdd(balances[_to], _value);
    balances[_from] = safeSub(balances[_from], _value);
    allowed[_from][msg.sender] = safeSub(_allowance, _value);
    Transfer(_from, _to, _value);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint _value) returns (bool success) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    if ((_value != 0) &amp;amp;&amp;amp; (allowed[msg.sender][_spender] != 0)) throw;

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }

}





/**
 * A token that can increase its supply by another contract.
 *
 * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.
 * Only mint agents, contracts whitelisted by owner, can mint new tokens.
 *
 */
contract MintableTokenExt is StandardToken, Ownable {

  using SafeMathLibExt for uint;

  bool public mintingFinished = false;

  /** List of agents that are allowed to create new tokens */
  mapping (address =&amp;gt; bool) public mintAgents;

  event MintingAgentChanged(address addr, bool state  );

  /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals.
  * For example, for reserved tokens in percents 2.54%
  * inPercentageUnit = 254
  * inPercentageDecimals = 2
  */
  struct ReservedTokensData {
    uint inTokens;
    uint inPercentageUnit;
    uint inPercentageDecimals;
    bool isReserved;
    bool isDistributed;
  }

  mapping (address =&amp;gt; ReservedTokensData) public reservedTokensList;
  address[] public reservedTokensDestinations;
  uint public reservedTokensDestinationsLen = 0;
  bool reservedTokensDestinationsAreSet = false;

  modifier onlyMintAgent() {
    // Only crowdsale contracts are allowed to mint new tokens
    if(!mintAgents[msg.sender]) {
        throw;
    }
    _;
  }

  /** Make sure we are not done yet. */
  modifier canMint() {
    if(mintingFinished) throw;
    _;
  }

  function finalizeReservedAddress(address addr) public onlyMintAgent canMint {
    ReservedTokensData storage reservedTokensData = reservedTokensList[addr];
    reservedTokensData.isDistributed = true;
  }

  function isAddressReserved(address addr) public constant returns (bool isReserved) {
    return reservedTokensList[addr].isReserved;
  }

  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
    return reservedTokensList[addr].isDistributed;
  }

  function getReservedTokens(address addr) public constant returns (uint inTokens) {
    return reservedTokensList[addr].inTokens;
  }

  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
    return reservedTokensList[addr].inPercentageUnit;
  }

  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
    return reservedTokensList[addr].inPercentageDecimals;
  }

  function setReservedTokensListMultiple(
    address[] addrs, 
    uint[] inTokens, 
    uint[] inPercentageUnit, 
    uint[] inPercentageDecimals
  ) public canMint onlyOwner {
    assert(!reservedTokensDestinationsAreSet);
    assert(addrs.length == inTokens.length);
    assert(inTokens.length == inPercentageUnit.length);
    assert(inPercentageUnit.length == inPercentageDecimals.length);
    for (uint iterator = 0; iterator &amp;lt; addrs.length; iterator++) {
      if (addrs[iterator] != address(0)) {
        setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);
      }
    }
    reservedTokensDestinationsAreSet = true;
  }

  /**
   * Create new tokens and allocate them to an address..
   *
   * Only callably by a crowdsale contract (mint agent).
   */
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
    totalSupply = totalSupply.plus(amount);
    balances[receiver] = balances[receiver].plus(amount);

    // This will make the mint transaction apper in EtherScan.io
    // We can remove this after there is a standardized minting event
    Transfer(0, receiver, amount);
  }

  /**
   * Owner can allow a crowdsale contract to mint new tokens.
   */
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
    mintAgents[addr] = state;
    MintingAgentChanged(addr, state);
  }

  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
    assert(addr != address(0));
    if (!isAddressReserved(addr)) {
      reservedTokensDestinations.push(addr);
      reservedTokensDestinationsLen++;
    }

    reservedTokensList[addr] = ReservedTokensData({
      inTokens: inTokens, 
      inPercentageUnit: inPercentageUnit, 
      inPercentageDecimals: inPercentageDecimals,
      isReserved: true,
      isDistributed: false
    });
  }
}

/**
 * ICO crowdsale contract that is capped by amout of tokens.
 *
 * - Tokens are dynamically created during the crowdsale
 *
 *
 */
contract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {

  /* Maximum amount of tokens this crowdsale can sell. */
  uint public maximumSellableTokens;

  function MintedTokenCappedCrowdsaleExt(
    string _name, 
    address _token, 
    PricingStrategy _pricingStrategy, 
    address _multisigWallet, 
    uint _start, uint _end, 
    uint _minimumFundingGoal, 
    uint _maximumSellableTokens, 
    bool _isUpdatable, 
    bool _isWhiteListed
  ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {
    maximumSellableTokens = _maximumSellableTokens;
  }

  // Crowdsale maximumSellableTokens has been changed
  event MaximumSellableTokensChanged(uint newMaximumSellableTokens);

  /**
   * Called from invest() to confirm if the curret investment does not break our cap rule.
   */
  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {
    return tokensSoldTotal &amp;gt; maximumSellableTokens;
  }

  function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {
    assert(isWhiteListed);
    uint maxCap = earlyParticipantWhitelist[addr].maxCap;
    return (tokenAmountOf[addr].plus(tokenAmount)) &amp;gt; maxCap;
  }

  function isCrowdsaleFull() public constant returns (bool) {
    return tokensSold &amp;gt;= maximumSellableTokens;
  }

  function setMaximumSellableTokens(uint tokens) public onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now &amp;lt;= startsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    assert(!lastTierCntrct.finalized());

    maximumSellableTokens = tokens;
    MaximumSellableTokensChanged(maximumSellableTokens);
  }

  function updateRate(uint newOneTokenInWei) public onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now &amp;lt;= startsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    assert(!lastTierCntrct.finalized());

    pricingStrategy.updateRate(newOneTokenInWei);
  }

  /**
   * Dynamically create tokens and assign them to the investor.
   */
  function assignTokens(address receiver, uint tokenAmount) private {
    MintableTokenExt mintableToken = MintableTokenExt(token);
    mintableToken.mint(receiver, tokenAmount);
  }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xf4284843dbd2ad16420c444b99d1b5b88eee854e.sol" target="_blank" title="show github file">0xf4284843dbd2ad16420c444b99d1b5b88eee854e.sol</a>
        </div>
        <div class="path">solidity-files/0xf4284843dbd2ad16420c444b99d1b5b88eee854e.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;ACT129137&amp;#39; token contract
//
// Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
// Symbol      : ACT129137
// Name        : ADZbuzz Digg.com Community Token
// Total supply: 2000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function ADZbuzzCommunityToken() public {
        symbol = &amp;quot;ACT129137&amp;quot;;
        name = &amp;quot;ADZbuzz Digg.com Community Token&amp;quot;;
        decimals = 8;
        _totalSupply = 200000000000000;
        balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
        emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xf40e0e575ec07c18595d23bd6d19cedef2bf7953.sol" target="_blank" title="show github file">0xf40e0e575ec07c18595d23bd6d19cedef2bf7953.sol</a>
        </div>
        <div class="path">solidity-files/0xf40e0e575ec07c18595d23bd6d19cedef2bf7953.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT107287&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT107287
    // Name        : ADZbuzz Autoweek.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT107287&amp;quot;;
            name = &amp;quot;ADZbuzz Autoweek.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xeec6a70b7916bcfd776b8a8952b67919bceb595f.sol" target="_blank" title="show github file">0xeec6a70b7916bcfd776b8a8952b67919bceb595f.sol</a>
        </div>
        <div class="path">solidity-files/0xeec6a70b7916bcfd776b8a8952b67919bceb595f.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;ACT257039&amp;#39; token contract
//
// Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
// Symbol      : ACT257039
// Name        : ADZbuzz Ancientpages.com Community Token
// Total supply: 2000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function ADZbuzzCommunityToken() public {
        symbol = &amp;quot;ACT257039&amp;quot;;
        name = &amp;quot;ADZbuzz Ancientpages.com Community Token&amp;quot;;
        decimals = 8;
        _totalSupply = 200000000000000;
        balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
        emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x61d40b844ea5b68c9c504fccdb05b68c2d7ae965.sol" target="_blank" title="show github file">0x61d40b844ea5b68c9c504fccdb05b68c2d7ae965.sol</a>
        </div>
        <div class="path">solidity-files/0x61d40b844ea5b68c9c504fccdb05b68c2d7ae965.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

// Turn the usage of callcode
contract SafeMath {
    function safeMul(uint a, uint b) internal returns (uint) {
        uint c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function safeSub(uint a, uint b) internal returns (uint) {
        assert(b &amp;lt;= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) internal returns (uint) {
        uint c = a + b;
        assert(c&amp;gt;=a &amp;amp;&amp;amp; c&amp;gt;=b);
        return c;
    }
}

contract CreatorEnabled {
    address public creator = 0x0;

    modifier onlyCreator() { require(msg.sender==creator); _; }

    function changeCreator(address _to) public onlyCreator {
        creator = _to;
    }
}

// ERC20 standard
contract StdToken is SafeMath {

    mapping(address =&amp;gt; uint256) public balances;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;
    uint public totalSupply = 0;


    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);


    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns(bool) {
      require(0x0!=_to);

      balances[msg.sender] = safeSub(balances[msg.sender],_value);
      balances[_to] = safeAdd(balances[_to],_value);

      Transfer(msg.sender, _to, _value);
      return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns(bool) {
      require(0x0!=_to);

      balances[_to] = safeAdd(balances[_to],_value);
      balances[_from] = safeSub(balances[_from],_value);
      allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);

      Transfer(_from, _to, _value);
      return true;
    }

    function balanceOf(address _owner) constant returns (uint256) {
      return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool) {
      // To change the approve amount you first have to reduce the addresses`
      //  allowance to zero by calling `approve(_spender, 0)` if it is not
      //  already 0 to mitigate the race condition described here:
      //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
      require((_value == 0) || (allowed[msg.sender][_spender] == 0));

      allowed[msg.sender][_spender] = _value;
      Approval(msg.sender, _spender, _value);
      return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256) {
      return allowed[_owner][_spender];
    }

    modifier onlyPayloadSize(uint _size) {
      require(msg.data.length &amp;gt;= _size + 4);
      _;
    }
}

contract IGoldFee {
    function calculateFee(address _sender, bool _isMigrationStarted, bool _isMigrationFinished, uint _mntpBalance, uint _value) public constant returns(uint);
}

contract GoldFee is CreatorEnabled {

    mapping(address =&amp;gt; bool) exceptAddresses;

    function GoldFee() {
        creator = msg.sender;
    }

    function getMin(uint out)returns (uint) {
        // 0.002 GOLD is min fee
        uint minFee = (2 * 1 ether) / 1000;
        if (out &amp;lt; minFee) {
             return minFee;
        }
        return out;
    }

    function getMax(uint out)returns (uint) {
        // 0.02 GOLD is max fee
        uint maxFee = (2 * 1 ether) / 100;
        if (out &amp;gt;= maxFee) {
             return maxFee;
        }
        return out;
    }

    function calculateFee(address _sender, bool _isMigrationStarted, bool _isMigrationFinished, uint _mntpBalance, uint _value) public constant returns(uint)
    {
       //if this is an excaptional address
       if (exceptAddresses[_sender]) {
            return 0;
       }

        // When migration process is finished (1 year from Goldmint blockchain launch), then transaction fee is 1% GOLD.
        if (_isMigrationFinished) {
             return (_value / 100);
        }

        // If the sender holds 0 MNTP, then the transaction fee is 1% GOLD.

        // If the sender holds at least 10 MNTP, then the transaction fee is 0.333333% GOLD,
        // but not less than 0.002 MNTP

        // If the sender holds at least 1000 MNTP, then the transaction fee is 0.033333% GOLD,
        // but not less than 0.002 MNTP

        // If the sender holds at least 10000 MNTP, then the transaction fee is 0.0333333% GOLD,
        // but not more than 0.02 MNTP
        if (_mntpBalance &amp;gt;= (10000 * 1 ether)) {
             return getMax((_value / 100) / 30);
        }
        if (_mntpBalance &amp;gt;= (1000 * 1 ether)) {
             return getMin((_value / 100) / 30);
        }
        if (_mntpBalance &amp;gt;= (10 * 1 ether)) {
             return getMin((_value / 100) / 3);
        }

        // 1%
        return getMin(_value / 100);
    }

    function addExceptAddress(address _address) public onlyCreator {
        exceptAddresses[_address] = true;
    }

    function removeExceptAddress(address _address) public onlyCreator {
        exceptAddresses[_address] = false;
    }

    function isAddressExcept(address _address) public constant returns(bool) {
        return exceptAddresses[_address];
    }
}

contract Gold is StdToken, CreatorEnabled {

    string public constant name = &amp;quot;GoldMint GOLD cryptoasset&amp;quot;;
    string public constant symbol = &amp;quot;GOLD&amp;quot;;
    uint8 public constant decimals = 18;

    // this is used to send fees (that is then distributed as rewards)
    address public migrationAddress = 0x0;
    address public storageControllerAddress = 0x0;

    address public goldmintTeamAddress = 0x0;
    IMNTP public mntpToken;
    IGoldFee public goldFee;


    bool public transfersLocked = false;
    bool public contractLocked = false;
    bool public migrationStarted = false;
    bool public migrationFinished = false;

    uint public totalIssued = 0;
    uint public totalBurnt = 0;

    // Modifiers:
    modifier onlyMigration() { require(msg.sender == migrationAddress); _; }
    modifier onlyMigrationOrStorageController() { require(msg.sender == migrationAddress || msg.sender == storageControllerAddress); _; }
    modifier onlyCreatorOrStorageController() { require(msg.sender == creator || msg.sender == storageControllerAddress); _; }
    modifier onlyIfUnlocked() { require(!transfersLocked); _; }

    // Functions:
    function Gold(address _mntpContractAddress, address _goldmintTeamAddress, address _goldFeeAddress) public {
        creator = msg.sender;

        mntpToken = IMNTP(_mntpContractAddress);
        goldmintTeamAddress = _goldmintTeamAddress;
        goldFee = IGoldFee(_goldFeeAddress);
    }

    function setCreator(address _address) public onlyCreator {
       creator = _address;
    }

    function lockContract(bool _contractLocked) public onlyCreator {
       contractLocked = _contractLocked;
    }

    function setStorageControllerContractAddress(address _address) public onlyCreator {
        storageControllerAddress = _address;
    }

    function setMigrationContractAddress(address _migrationAddress) public onlyCreator {
        migrationAddress = _migrationAddress;
    }

    function setGoldmintTeamAddress(address _teamAddress) public onlyCreator {
        goldmintTeamAddress = _teamAddress;
    }

    function setGoldFeeAddress(address _goldFeeAddress) public onlyCreator {
        goldFee = IGoldFee(_goldFeeAddress);
    }

    function issueTokens(address _who, uint _tokens) public onlyCreatorOrStorageController {
        require(!contractLocked);

        balances[_who] = safeAdd(balances[_who],_tokens);
        totalSupply = safeAdd(totalSupply,_tokens);
        totalIssued = safeAdd(totalIssued,_tokens);

        Transfer(0x0, _who, _tokens);
    }

    function burnTokens(address _who, uint _tokens) public onlyMigrationOrStorageController {
        require(!contractLocked);
        balances[_who] = safeSub(balances[_who],_tokens);
        totalSupply = safeSub(totalSupply,_tokens);
        totalBurnt = safeAdd(totalBurnt,_tokens);
    }

    // there is no way to revert that
    function startMigration() public onlyMigration {
        require(false == migrationStarted);
        migrationStarted = true;
    }

    // there is no way to revert that
    function finishMigration() public onlyMigration {
        require(true == migrationStarted);

        migrationFinished = true;
    }

    function lockTransfer(bool _lock) public onlyMigration {
        transfersLocked = _lock;
    }

    function transfer(address _to, uint256 _value) public onlyIfUnlocked onlyPayloadSize(2 * 32) returns(bool) {

        uint yourCurrentMntpBalance = mntpToken.balanceOf(msg.sender);

        // you can transfer if fee is ZERO
        uint fee = goldFee.calculateFee(msg.sender, migrationStarted, migrationFinished, yourCurrentMntpBalance, _value);
        uint sendThis = _value;
        if (0 != fee) {
             sendThis = safeSub(_value,fee);

             // 1.Transfer fee
             // A -&amp;gt; rewards account
             //
             // Each GOLD token transfer should send transaction fee to
             // GoldmintMigration contract if Migration process is not started.
             // Goldmint team if Migration process is started.
             if (migrationStarted) {
                  super.transfer(goldmintTeamAddress, fee);
             } else {
                  super.transfer(migrationAddress, fee);
             }
        }

        // 2.Transfer
        // A -&amp;gt; B
        return super.transfer(_to, sendThis);
    }

    function transferFrom(address _from, address _to, uint256 _value) public onlyIfUnlocked returns(bool) {

        uint yourCurrentMntpBalance = mntpToken.balanceOf(_from);

        uint fee = goldFee.calculateFee(msg.sender, migrationStarted, migrationFinished, yourCurrentMntpBalance, _value);
        if (0 != fee) {
             // 1.Transfer fee
             // A -&amp;gt; rewards account
             //
             // Each GOLD token transfer should send transaction fee to
             // GoldmintMigration contract if Migration process is not started.
             // Goldmint team if Migration process is started.
             if (migrationStarted) {
                  super.transferFrom(_from, goldmintTeamAddress, fee);
             } else {
                  super.transferFrom(_from, migrationAddress, fee);
             }
        }

        // 2.Transfer
        // A -&amp;gt; B
        uint sendThis = safeSub(_value,fee);
        return super.transferFrom(_from, _to, sendThis);
    }

    // Used to send rewards)
    function transferRewardWithoutFee(address _to, uint _value) public onlyMigration onlyPayloadSize(2*32) {
        require(0x0!=_to);

        balances[migrationAddress] = safeSub(balances[migrationAddress],_value);
        balances[_to] = safeAdd(balances[_to],_value);

        Transfer(migrationAddress, _to, _value);
    }

    // This is an emergency function that can be called by Creator only
    function rescueAllRewards(address _to) public onlyCreator {
        require(0x0!=_to);

        uint totalReward = balances[migrationAddress];

        balances[_to] = safeAdd(balances[_to],totalReward);
        balances[migrationAddress] = 0;

        Transfer(migrationAddress, _to, totalReward);
    }


    function getTotalIssued() public constant returns (uint) {
        return totalIssued;
    }

    function getTotalBurnt() public constant returns (uint) {
        return totalBurnt;
    }
}

contract IMNTP is StdToken {
    // Additional methods that MNTP contract provides
    function lockTransfer(bool _lock);
    function issueTokens(address _who, uint _tokens);
    function burnTokens(address _who, uint _tokens);
}

contract GoldmintMigration is CreatorEnabled {
    // Fields:
    IMNTP public mntpToken;
    Gold public goldToken;

    enum State {
        Init,
        MigrationStarted,
        MigrationPaused,
        MigrationFinished
    }

    State public state = State.Init;

    // this is total collected GOLD rewards (launch to migration start)
    uint public mntpToMigrateTotal = 0;
    uint public migrationRewardTotal = 0;
    uint64 public migrationStartedTime = 0;
    uint64 public migrationFinishedTime = 0;

    struct Migration {
        address ethAddress;
        string gmAddress;
        uint tokensCount;
        bool migrated;
        uint64 date;
        string comment;
    }

    mapping (uint=&amp;gt;Migration) public mntpMigrations;
    mapping (address=&amp;gt;uint) public mntpMigrationIndexes;
    uint public mntpMigrationsCount = 0;

    mapping (uint=&amp;gt;Migration) public goldMigrations;
    mapping (address=&amp;gt;uint) public goldMigrationIndexes;
    uint public goldMigrationsCount = 0;

    event MntpMigrateWanted(address _ethAddress, string _gmAddress, uint256 _value);
    event MntpMigrated(address _ethAddress, string _gmAddress, uint256 _value);

    event GoldMigrateWanted(address _ethAddress, string _gmAddress, uint256 _value);
    event GoldMigrated(address _ethAddress, string _gmAddress, uint256 _value);

    // Access methods
    function getMntpMigration(uint index) public constant returns(address,string,uint,bool,uint64,string){
        Migration memory mig = mntpMigrations[index];
        return (mig.ethAddress, mig.gmAddress, mig.tokensCount, mig.migrated, mig.date, mig.comment);
    }

    function getGoldMigration(uint index) public constant returns(address,string,uint,bool,uint64,string){
        Migration memory mig = goldMigrations[index];
        return (mig.ethAddress, mig.gmAddress, mig.tokensCount, mig.migrated, mig.date, mig.comment);
    }

    // Functions:
    // Constructor
    function GoldmintMigration(address _mntpContractAddress, address _goldContractAddress) public {
        creator = msg.sender;

        require(_mntpContractAddress != 0);
        require(_goldContractAddress != 0);

        mntpMigrationIndexes[address(0x0)] = 0;
        goldMigrationIndexes[address(0x0)] = 0;

        mntpToken = IMNTP(_mntpContractAddress);
        goldToken = Gold(_goldContractAddress);
    }

    function lockMntpTransfers(bool _lock) public onlyCreator {
        mntpToken.lockTransfer(_lock);
    }

    function lockGoldTransfers(bool _lock) public onlyCreator {
        goldToken.lockTransfer(_lock);
    }

    // This method is called when migration to Goldmint&amp;#39;s blockchain
    // process is started...
    function startMigration() public onlyCreator {
        require((State.Init == state) || (State.MigrationPaused == state));

        if (State.Init == state) {
             // 1 - change fees
             goldToken.startMigration();

             // 2 - store the current values
             migrationRewardTotal = goldToken.balanceOf(this);
             migrationStartedTime = uint64(now);
             mntpToMigrateTotal = mntpToken.totalSupply();
        }

        state = State.MigrationStarted;
    }

    function pauseMigration() public onlyCreator {
        require((state == State.MigrationStarted) || (state == State.MigrationFinished));

        state = State.MigrationPaused;
    }

    // that doesn&amp;#39;t mean that you cant migrate from Ethereum -&amp;gt; Goldmint blockchain
    // that means that you will get no reward
    function finishMigration() public onlyCreator {
        require((State.MigrationStarted == state) || (State.MigrationPaused == state));

        if (State.MigrationStarted == state) {
             goldToken.finishMigration();
             migrationFinishedTime = uint64(now);
        }

        state = State.MigrationFinished;
    }

    function destroyMe() public onlyCreator {
        selfdestruct(msg.sender);
    }

    // MNTP
    // Call this to migrate your MNTP tokens to Goldmint MNT
    // (this is one-way only)
    // _gmAddress is something like that - &amp;quot;BTS7yRXCkBjKxho57RCbqYE3nEiprWXXESw3Hxs5CKRnft8x7mdGi&amp;quot;
    //
    // !!! WARNING: will not allow anyone to migrate tokens partly
    // !!! DISCLAIMER: check goldmint blockchain address format. You will not be able to change that!
    function migrateMntp(string _gmAddress) public {
        require((state==State.MigrationStarted) || (state==State.MigrationFinished));

        // 1 - calculate current reward
        uint myBalance = mntpToken.balanceOf(msg.sender);
        require(0!=myBalance);

        uint myRewardMax = calculateMyRewardMax(msg.sender);
        uint myReward = calculateMyReward(myRewardMax);

        // 2 - pay the reward to our user
        goldToken.transferRewardWithoutFee(msg.sender, myReward);

        // 3 - burn tokens
        // WARNING: burn will reduce totalSupply
        //
        // WARNING: creator must call
        // setIcoContractAddress(migrationContractAddress)
        // of the mntpToken
        mntpToken.burnTokens(msg.sender,myBalance);

        // save tuple
        Migration memory mig;
        mig.ethAddress = msg.sender;
        mig.gmAddress = _gmAddress;
        mig.tokensCount = myBalance;
        mig.migrated = false;
        mig.date = uint64(now);
        mig.comment = &amp;#39;&amp;#39;;

        mntpMigrations[mntpMigrationsCount + 1] = mig;
        mntpMigrationIndexes[msg.sender] = mntpMigrationsCount + 1;
        mntpMigrationsCount++;

        // send an event
        MntpMigrateWanted(msg.sender, _gmAddress, myBalance);
    }

    function isMntpMigrated(address _who) public constant returns(bool) {
        uint index = mntpMigrationIndexes[_who];

        Migration memory mig = mntpMigrations[index];
        return mig.migrated;
    }

    function setMntpMigrated(address _who, bool _isMigrated, string _comment) public onlyCreator {
        uint index = mntpMigrationIndexes[_who];
        require(index &amp;gt; 0);

        mntpMigrations[index].migrated = _isMigrated;
        mntpMigrations[index].comment = _comment;

        // send an event
        if (_isMigrated) {
             MntpMigrated(  mntpMigrations[index].ethAddress,
                            mntpMigrations[index].gmAddress,
                            mntpMigrations[index].tokensCount);
        }
    }

    // GOLD
    function migrateGold(string _gmAddress) public {
        require((state==State.MigrationStarted) || (state==State.MigrationFinished));

        // 1 - get balance
        uint myBalance = goldToken.balanceOf(msg.sender);
        require(0!=myBalance);

        // 2 - burn tokens
        // WARNING: burn will reduce totalSupply
        //
        goldToken.burnTokens(msg.sender,myBalance);

        // save tuple
        Migration memory mig;
        mig.ethAddress = msg.sender;
        mig.gmAddress = _gmAddress;
        mig.tokensCount = myBalance;
        mig.migrated = false;
        mig.date = uint64(now);
        mig.comment = &amp;#39;&amp;#39;;

        goldMigrations[goldMigrationsCount + 1] = mig;
        goldMigrationIndexes[msg.sender] = goldMigrationsCount + 1;
        goldMigrationsCount++;

        // send an event
        GoldMigrateWanted(msg.sender, _gmAddress, myBalance);
    }

    function isGoldMigrated(address _who) public constant returns(bool) {
        uint index = goldMigrationIndexes[_who];

        Migration memory mig = goldMigrations[index];
        return mig.migrated;
    }

    function setGoldMigrated(address _who, bool _isMigrated, string _comment) public onlyCreator {
        uint index = goldMigrationIndexes[_who];
        require(index &amp;gt; 0);

        goldMigrations[index].migrated = _isMigrated;
        goldMigrations[index].comment = _comment;

        // send an event
        if (_isMigrated) {
             GoldMigrated(  goldMigrations[index].ethAddress,
                            goldMigrations[index].gmAddress,
                            goldMigrations[index].tokensCount);
        }
    }

    // Each MNTP token holder gets a GOLD reward as a percent of all rewards
    // proportional to his MNTP token stake
    function calculateMyRewardMax(address _of) public constant returns(uint){
        if (0 == mntpToMigrateTotal) {
             return 0;
        }

        uint myCurrentMntpBalance = mntpToken.balanceOf(_of);
        if (0 == myCurrentMntpBalance) {
             return 0;
        }

        return (migrationRewardTotal * myCurrentMntpBalance) / mntpToMigrateTotal;
    }

    //emergency function. used in case of a mistake to transfer all the reward to a new migraiton smart contract.
    function transferReward(address _newContractAddress) public onlyCreator {
      goldToken.transferRewardWithoutFee(_newContractAddress, goldToken.balanceOf(this));
    }

    // Migration rewards decreased linearly.
    //
    // The formula is: rewardPercents = max(100 - 100 * day / 365, 0)
    //
    // On 1st day of migration, you will get: 100 - 100 * 0/365 = 100% of your rewards
    // On 2nd day of migration, you will get: 100 - 100 * 1/365 = 99.7261% of your rewards
    // On 365th day of migration, you will get: 100 - 100 * 364/365 = 0.274%
    function calculateMyRewardDecreased(uint _day, uint _myRewardMax) public constant returns(uint){
        if (_day &amp;gt;= 365) {
             return 0;
        }

        uint x = ((100 * 1000000000 * _day) / 365);
        return (_myRewardMax * ((100 * 1000000000) - x)) / (100 * 1000000000);
    }

    function calculateMyReward(uint _myRewardMax) public constant returns(uint){
        // day starts from 0
        uint day = (uint64(now) - migrationStartedTime) / uint64(1 days);
        return calculateMyRewardDecreased(day, _myRewardMax);
    }

    // do not allow to send money to this contract...
    function() external payable {
        revert();
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xd004840fe39ee0db86e86000f44625ab8f0f6587.sol" target="_blank" title="show github file">0xd004840fe39ee0db86e86000f44625ab8f0f6587.sol</a>
        </div>
        <div class="path">solidity-files/0xd004840fe39ee0db86e86000f44625ab8f0f6587.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT112538&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT112538
    // Name        : ADZbuzz Naturallyhealthybloodroot.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT112538&amp;quot;;
            name = &amp;quot;ADZbuzz Naturallyhealthybloodroot.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xf442cd93307678df57e7e879608cfa2bd4542030.sol" target="_blank" title="show github file">0xf442cd93307678df57e7e879608cfa2bd4542030.sol</a>
        </div>
        <div class="path">solidity-files/0xf442cd93307678df57e7e879608cfa2bd4542030.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

// File: contracts/BdpBaseData.sol

contract BdpBaseData {

	address public ownerAddress;

	address public managerAddress;

	address[16] public contracts;

	bool public paused = false;

	bool public setupCompleted = false;

	bytes8 public version;

}

// File: contracts/libraries/BdpContracts.sol

library BdpContracts {

	function getBdpEntryPoint(address[16] _contracts) pure internal returns (address) {
		return _contracts[0];
	}

	function getBdpController(address[16] _contracts) pure internal returns (address) {
		return _contracts[1];
	}

	function getBdpControllerHelper(address[16] _contracts) pure internal returns (address) {
		return _contracts[3];
	}

	function getBdpDataStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[4];
	}

	function getBdpImageStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[5];
	}

	function getBdpOwnershipStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[6];
	}

	function getBdpPriceStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[7];
	}

}

// File: contracts/BdpBase.sol

contract BdpBase is BdpBaseData {

	modifier onlyOwner() {
		require(msg.sender == ownerAddress);
		_;
	}

	modifier onlyAuthorized() {
		require(msg.sender == ownerAddress || msg.sender == managerAddress);
		_;
	}

	modifier whileContractIsActive() {
		require(!paused &amp;amp;&amp;amp; setupCompleted);
		_;
	}

	modifier storageAccessControl() {
		require(
			(! setupCompleted &amp;amp;&amp;amp; (msg.sender == ownerAddress || msg.sender == managerAddress))
			|| (setupCompleted &amp;amp;&amp;amp; !paused &amp;amp;&amp;amp; (msg.sender == BdpContracts.getBdpEntryPoint(contracts)))
		);
		_;
	}

	function setOwner(address _newOwner) external onlyOwner {
		require(_newOwner != address(0));
		ownerAddress = _newOwner;
	}

	function setManager(address _newManager) external onlyOwner {
		require(_newManager != address(0));
		managerAddress = _newManager;
	}

	function setContracts(address[16] _contracts) external onlyOwner {
		contracts = _contracts;
	}

	function pause() external onlyAuthorized {
		paused = true;
	}

	function unpause() external onlyOwner {
		paused = false;
	}

	function setSetupCompleted() external onlyOwner {
		setupCompleted = true;
	}

	function kill() public onlyOwner {
		selfdestruct(ownerAddress);
	}

}

// File: contracts/libraries/SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

	/**
	* @dev Multiplies two numbers, throws on overflow.
	*/
	function mul(uint256 a, uint256 b) internal pure returns (uint256) {
		if (a == 0) {
			return 0;
		}
		uint256 c = a * b;
		assert(c / a == b);
		return c;
	}

	/**
	* @dev Integer division of two numbers, truncating the quotient.
	*/
	function div(uint256 a, uint256 b) internal pure returns (uint256) {
		// assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
		uint256 c = a / b;
		// assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
		return c;
	}

	/**
	* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
	*/
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
		assert(b &amp;lt;= a);
		return a - b;
	}

	/**
	* @dev Adds two numbers, throws on overflow.
	*/
	function add(uint256 a, uint256 b) internal pure returns (uint256) {
		uint256 c = a + b;
		assert(c &amp;gt;= a);
		return c;
	}
}

// File: contracts/storage/BdpDataStorage.sol

contract BdpDataStorage is BdpBase {

	using SafeMath for uint256;

	struct Region {
		uint256 x1;
		uint256 y1;
		uint256 x2;
		uint256 y2;
		uint256 currentImageId;
		uint256 nextImageId;
		uint8[128] url;
		uint256 currentPixelPrice;
		uint256 blockUpdatedAt;
		uint256 updatedAt;
		uint256 purchasedAt;
		uint256 purchasedPixelPrice;
	}

	uint256 public lastRegionId = 0;

	mapping (uint256 =&amp;gt; Region) public data;


	function getLastRegionId() view public returns (uint256) {
		return lastRegionId;
	}

	function getNextRegionId() public storageAccessControl returns (uint256) {
		lastRegionId = lastRegionId.add(1);
		return lastRegionId;
	}

	function deleteRegionData(uint256 _id) public storageAccessControl {
		delete data[_id];
	}

	function getRegionCoordinates(uint256 _id) view public returns (uint256, uint256, uint256, uint256) {
		return (data[_id].x1, data[_id].y1, data[_id].x2, data[_id].y2);
	}

	function setRegionCoordinates(uint256 _id, uint256 _x1, uint256 _y1, uint256 _x2, uint256 _y2) public storageAccessControl {
		data[_id].x1 = _x1;
		data[_id].y1 = _y1;
		data[_id].x2 = _x2;
		data[_id].y2 = _y2;
	}

	function getRegionCurrentImageId(uint256 _id) view public returns (uint256) {
		return data[_id].currentImageId;
	}

	function setRegionCurrentImageId(uint256 _id, uint256 _currentImageId) public storageAccessControl {
		data[_id].currentImageId = _currentImageId;
	}

	function getRegionNextImageId(uint256 _id) view public returns (uint256) {
		return data[_id].nextImageId;
	}

	function setRegionNextImageId(uint256 _id, uint256 _nextImageId) public storageAccessControl {
		data[_id].nextImageId = _nextImageId;
	}

	function getRegionUrl(uint256 _id) view public returns (uint8[128]) {
		return data[_id].url;
	}

	function setRegionUrl(uint256 _id, uint8[128] _url) public storageAccessControl {
		data[_id].url = _url;
	}

	function getRegionCurrentPixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].currentPixelPrice;
	}

	function setRegionCurrentPixelPrice(uint256 _id, uint256 _currentPixelPrice) public storageAccessControl {
		data[_id].currentPixelPrice = _currentPixelPrice;
	}

	function getRegionBlockUpdatedAt(uint256 _id) view public returns (uint256) {
		return data[_id].blockUpdatedAt;
	}

	function setRegionBlockUpdatedAt(uint256 _id, uint256 _blockUpdatedAt) public storageAccessControl {
		data[_id].blockUpdatedAt = _blockUpdatedAt;
	}

	function getRegionUpdatedAt(uint256 _id) view public returns (uint256) {
		return data[_id].updatedAt;
	}

	function setRegionUpdatedAt(uint256 _id, uint256 _updatedAt) public storageAccessControl {
		data[_id].updatedAt = _updatedAt;
	}

	function getRegionPurchasedAt(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedAt;
	}

	function setRegionPurchasedAt(uint256 _id, uint256 _purchasedAt) public storageAccessControl {
		data[_id].purchasedAt = _purchasedAt;
	}

	function getRegionUpdatedAtPurchasedAt(uint256 _id) view public returns (uint256 _updatedAt, uint256 _purchasedAt) {
		return (data[_id].updatedAt, data[_id].purchasedAt);
	}

	function getRegionPurchasePixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedPixelPrice;
	}

	function setRegionPurchasedPixelPrice(uint256 _id, uint256 _purchasedPixelPrice) public storageAccessControl {
		data[_id].purchasedPixelPrice = _purchasedPixelPrice;
	}

	function BdpDataStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/storage/BdpPriceStorage.sol

contract BdpPriceStorage is BdpBase {

	uint64[1001] public pricePoints;

	uint256 public pricePointsLength = 0;

	address public forwardPurchaseFeesTo = address(0);

	address public forwardUpdateFeesTo = address(0);


	function getPricePointsLength() view public returns (uint256) {
		return pricePointsLength;
	}

	function getPricePoint(uint256 _i) view public returns (uint256) {
		return pricePoints[_i];
	}

	function setPricePoints(uint64[] _pricePoints) public storageAccessControl {
		pricePointsLength = 0;
		appendPricePoints(_pricePoints);
	}

	function appendPricePoints(uint64[] _pricePoints) public storageAccessControl {
		for (uint i = 0; i &amp;lt; _pricePoints.length; i++) {
			pricePoints[pricePointsLength++] = _pricePoints[i];
		}
	}

	function getForwardPurchaseFeesTo() view public returns (address) {
		return forwardPurchaseFeesTo;
	}

	function setForwardPurchaseFeesTo(address _forwardPurchaseFeesTo) public storageAccessControl {
		forwardPurchaseFeesTo = _forwardPurchaseFeesTo;
	}

	function getForwardUpdateFeesTo() view public returns (address) {
		return forwardUpdateFeesTo;
	}

	function setForwardUpdateFeesTo(address _forwardUpdateFeesTo) public storageAccessControl {
		forwardUpdateFeesTo = _forwardUpdateFeesTo;
	}

	function BdpPriceStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/libraries/BdpCalculator.sol

library BdpCalculator {

	using SafeMath for uint256;

	function calculateArea(address[16] _contracts, uint256 _regionId) view public returns (uint256 _area, uint256 _width, uint256 _height) {
		var (x1, y1, x2, y2) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCoordinates(_regionId);
		_width = x2 - x1 + 1;
		_height = y2 - y1 + 1;
		_area = _width * _height;
	}

	function countPurchasedPixels(address[16] _contracts) view public returns (uint256 _count) {
		var lastRegionId = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getLastRegionId();
		for (uint256 i = 0; i &amp;lt;= lastRegionId; i++) {
			if(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionPurchasedAt(i) &amp;gt; 0) { // region is purchased
				var (area,,) = calculateArea(_contracts, i);
				_count += area;
			}
		}
	}

	function calculateCurrentMarketPixelPrice(address[16] _contracts) view public returns(uint) {
		return calculateMarketPixelPrice(_contracts, countPurchasedPixels(_contracts));
	}

	function calculateMarketPixelPrice(address[16] _contracts, uint _pixelsSold) view public returns(uint) {
		var pricePointsLength = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePointsLength();
		uint mod = _pixelsSold % (1000000 / (pricePointsLength - 1));
		uint div = _pixelsSold * (pricePointsLength - 1) / 1000000;
		var divPoint = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div);
		if(mod == 0) return divPoint;
		return divPoint + mod * (BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div+1) - divPoint) * (pricePointsLength - 1) / 1000000;
	}

	function calculateAveragePixelPrice(address[16] _contracts, uint _a, uint _b) view public returns (uint _price) {
		_price = (calculateMarketPixelPrice(_contracts, _a) + calculateMarketPixelPrice(_contracts, _b)) / 2;
	}

	/** Current market price per pixel for this region if it is the first sale of this region
	  */
	function calculateRegionInitialSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		require(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAt(_regionId) &amp;gt; 0); // region exists
		var purchasedPixels = countPurchasedPixels(_contracts);
		var (area,,) = calculateArea(_contracts, _regionId);
		return calculateAveragePixelPrice(_contracts, purchasedPixels, purchasedPixels + area);
	}

	/** Current market price or (Current market price)*3 if the region was sold
	  */
	function calculateRegionSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		var pixelPrice = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCurrentPixelPrice(_regionId);
		if(pixelPrice &amp;gt; 0) {
			return pixelPrice * 3;
		} else {
			return calculateRegionInitialSalePixelPrice(_contracts, _regionId);
		}
	}

	/** Setup is allowed one whithin one day after purchase
	  */
	function calculateSetupAllowedUntil(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		var (updatedAt, purchasedAt) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAtPurchasedAt(_regionId);
		if(updatedAt != purchasedAt) {
			return 0;
		} else {
			return purchasedAt + 1 days;
		}
	}

}

// File: contracts/storage/BdpImageStorage.sol

contract BdpImageStorage is BdpBase {

	using SafeMath for uint256;

	struct Image {
		address owner;
		uint256 regionId;
		uint256 currentRegionId;
		mapping(uint16 =&amp;gt; uint256[1000]) data;
		mapping(uint16 =&amp;gt; uint16) dataLength;
		uint16 partsCount;
		uint16 width;
		uint16 height;
		uint16 imageDescriptor;
		uint256 blurredAt;
	}

	uint256 public lastImageId = 0;

	mapping(uint256 =&amp;gt; Image) public images;


	function getLastImageId() view public returns (uint256) {
		return lastImageId;
	}

	function getNextImageId() public storageAccessControl returns (uint256) {
		lastImageId = lastImageId.add(1);
		return lastImageId;
	}

	function createImage(address _owner, uint256 _regionId, uint16 _width, uint16 _height, uint16 _partsCount, uint16 _imageDescriptor) public storageAccessControl returns (uint256) {
		require(_owner != address(0) &amp;amp;&amp;amp; _width &amp;gt; 0 &amp;amp;&amp;amp; _height &amp;gt; 0 &amp;amp;&amp;amp; _partsCount &amp;gt; 0 &amp;amp;&amp;amp; _imageDescriptor &amp;gt; 0);
		uint256 id = getNextImageId();
		images[id].owner = _owner;
		images[id].regionId = _regionId;
		images[id].width = _width;
		images[id].height = _height;
		images[id].partsCount = _partsCount;
		images[id].imageDescriptor = _imageDescriptor;
		return id;
	}

	function imageExists(uint256 _imageId) view public returns (bool) {
		return _imageId &amp;gt; 0 &amp;amp;&amp;amp; images[_imageId].owner != address(0);
	}

	function deleteImage(uint256 _imageId) public storageAccessControl {
		require(imageExists(_imageId));
		delete images[_imageId];
	}

	function getImageOwner(uint256 _imageId) public view returns (address) {
		require(imageExists(_imageId));
		return images[_imageId].owner;
	}

	function setImageOwner(uint256 _imageId, address _owner) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].owner = _owner;
	}

	function getImageRegionId(uint256 _imageId) public view returns (uint256) {
		require(imageExists(_imageId));
		return images[_imageId].regionId;
	}

	function setImageRegionId(uint256 _imageId, uint256 _regionId) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].regionId = _regionId;
	}

	function getImageCurrentRegionId(uint256 _imageId) public view returns (uint256) {
		require(imageExists(_imageId));
		return images[_imageId].currentRegionId;
	}

	function setImageCurrentRegionId(uint256 _imageId, uint256 _currentRegionId) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].currentRegionId = _currentRegionId;
	}

	function getImageData(uint256 _imageId, uint16 _part) view public returns (uint256[1000]) {
		require(imageExists(_imageId));
		return images[_imageId].data[_part];
	}

	function setImageData(uint256 _imageId, uint16 _part, uint256[] _data) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].dataLength[_part] = uint16(_data.length);
		for (uint256 i = 0; i &amp;lt; _data.length; i++) {
			images[_imageId].data[_part][i] = _data[i];
		}
	}

	function getImageDataLength(uint256 _imageId, uint16 _part) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].dataLength[_part];
	}

	function setImageDataLength(uint256 _imageId, uint16 _part, uint16 _dataLength) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].dataLength[_part] = _dataLength;
	}

	function getImagePartsCount(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].partsCount;
	}

	function setImagePartsCount(uint256 _imageId, uint16 _partsCount) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].partsCount = _partsCount;
	}

	function getImageWidth(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].width;
	}

	function setImageWidth(uint256 _imageId, uint16 _width) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].width = _width;
	}

	function getImageHeight(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].height;
	}

	function setImageHeight(uint256 _imageId, uint16 _height) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].height = _height;
	}

	function getImageDescriptor(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].imageDescriptor;
	}

	function setImageDescriptor(uint256 _imageId, uint16 _imageDescriptor) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].imageDescriptor = _imageDescriptor;
	}

	function getImageBlurredAt(uint256 _imageId) view public returns (uint256) {
		return images[_imageId].blurredAt;
	}

	function setImageBlurredAt(uint256 _imageId, uint256 _blurredAt) public storageAccessControl {
		images[_imageId].blurredAt = _blurredAt;
	}

	function imageUploadComplete(uint256 _imageId) view public returns (bool) {
		require(imageExists(_imageId));
		for (uint16 i = 1; i &amp;lt;= images[_imageId].partsCount; i++) {
			if(images[_imageId].data[i].length == 0) {
				return false;
			}
		}
		return true;
	}

	function BdpImageStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/storage/BdpOwnershipStorage.sol

contract BdpOwnershipStorage is BdpBase {

	using SafeMath for uint256;

	// Mapping from token ID to owner
	mapping (uint256 =&amp;gt; address) public tokenOwner;

	// Mapping from token ID to approved address
	mapping (uint256 =&amp;gt; address) public tokenApprovals;

	// Mapping from owner to the sum of owned area
	mapping (address =&amp;gt; uint256) public ownedArea;

	// Mapping from owner to list of owned token IDs
	mapping (address =&amp;gt; uint256[]) public ownedTokens;

	// Mapping from token ID to index of the owner tokens list
	mapping(uint256 =&amp;gt; uint256) public ownedTokensIndex;

	// All tokens list tokens ids
	uint256[] public tokenIds;

	// Mapping from tokenId to index of the tokens list
	mapping (uint256 =&amp;gt; uint256) public tokenIdsIndex;


	function getTokenOwner(uint256 _tokenId) view public returns (address) {
		return tokenOwner[_tokenId];
	}

	function setTokenOwner(uint256 _tokenId, address _owner) public storageAccessControl {
		tokenOwner[_tokenId] = _owner;
	}

	function getTokenApproval(uint256 _tokenId) view public returns (address) {
		return tokenApprovals[_tokenId];
	}

	function setTokenApproval(uint256 _tokenId, address _to) public storageAccessControl {
		tokenApprovals[_tokenId] = _to;
	}

	function getOwnedArea(address _owner) view public returns (uint256) {
		return ownedArea[_owner];
	}

	function setOwnedArea(address _owner, uint256 _area) public storageAccessControl {
		ownedArea[_owner] = _area;
	}

	function incrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].add(_area);
		return ownedArea[_owner];
	}

	function decrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].sub(_area);
		return ownedArea[_owner];
	}

	function getOwnedTokensLength(address _owner) view public returns (uint256) {
		return ownedTokens[_owner].length;
	}

	function getOwnedToken(address _owner, uint256 _index) view public returns (uint256) {
		return ownedTokens[_owner][_index];
	}

	function setOwnedToken(address _owner, uint256 _index, uint256 _tokenId) public storageAccessControl {
		ownedTokens[_owner][_index] = _tokenId;
	}

	function pushOwnedToken(address _owner, uint256 _tokenId) public storageAccessControl returns (uint256) {
		ownedTokens[_owner].push(_tokenId);
		return ownedTokens[_owner].length;
	}

	function decrementOwnedTokensLength(address _owner) public storageAccessControl {
		ownedTokens[_owner].length--;
	}

	function getOwnedTokensIndex(uint256 _tokenId) view public returns (uint256) {
		return ownedTokensIndex[_tokenId];
	}

	function setOwnedTokensIndex(uint256 _tokenId, uint256 _tokenIndex) public storageAccessControl {
		ownedTokensIndex[_tokenId] = _tokenIndex;
	}

	function getTokenIdsLength() view public returns (uint256) {
		return tokenIds.length;
	}

	function getTokenIdByIndex(uint256 _index) view public returns (uint256) {
		return tokenIds[_index];
	}

	function setTokenIdByIndex(uint256 _index, uint256 _tokenId) public storageAccessControl {
		tokenIds[_index] = _tokenId;
	}

	function pushTokenId(uint256 _tokenId) public storageAccessControl returns (uint256) {
		tokenIds.push(_tokenId);
		return tokenIds.length;
	}

	function decrementTokenIdsLength() public storageAccessControl {
		tokenIds.length--;
	}

	function getTokenIdsIndex(uint256 _tokenId) view public returns (uint256) {
		return tokenIdsIndex[_tokenId];
	}

	function setTokenIdsIndex(uint256 _tokenId, uint256 _tokenIdIndex) public storageAccessControl {
		tokenIdsIndex[_tokenId] = _tokenIdIndex;
	}

	function BdpOwnershipStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/libraries/BdpOwnership.sol

/**
 * Ownership manager
 * Does not check if the caller is allowed to call functions
 * State changing methods are not intended to be called from controller
 */
library BdpOwnership {

	using SafeMath for uint256;

	event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

	event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

	function ownerOf(address[16] _contracts, uint256 _tokenId) public view returns (address) {
		var owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);
		require(owner != address(0));
		return owner;
	}

	function balanceOf(address[16] _contracts, address _owner) public view returns (uint256) {
		return BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getOwnedTokensLength(_owner);
	}

	function approve(address[16] _contracts, address _to, uint256 _tokenId) public {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		address owner = ownerOf(_contracts, _tokenId);
		require(_to != owner);
		if (ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0) {
			ownStorage.setTokenApproval(_tokenId, _to);
			Approval(owner, _to, _tokenId);
		}
	}

	/**
	 * @dev Clear current approval of a given token ID
	 * @param _tokenId uint256 ID of the token to be transferred
	 */
	function clearApproval(address[16] _contracts, address _owner, uint256 _tokenId) public {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownerOf(_contracts, _tokenId) == _owner);
		if (ownStorage.getTokenApproval(_tokenId) != 0) {
			BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).setTokenApproval(_tokenId, 0);
			Approval(_owner, 0, _tokenId);
		}
	}

	/**
	 * @dev Clear current approval and transfer the ownership of a given token ID
	 * @param _from address which you want to send tokens from
	 * @param _to address which you want to transfer the token to
	 * @param _tokenId uint256 ID of the token to be transferred
	 */
	function clearApprovalAndTransfer(address[16] _contracts, address _from, address _to, uint256 _tokenId) public {
		require(_to != address(0));
		require(_to != ownerOf(_contracts, _tokenId));
		require(ownerOf(_contracts, _tokenId) == _from);

		clearApproval(_contracts, _from, _tokenId);
		removeToken(_contracts, _from, _tokenId);
		addToken(_contracts, _to, _tokenId);
		Transfer(_from, _to, _tokenId);
	}

	/**
	 * @dev Internal function to add a token ID to the list of a given address
	 * @param _to address representing the new owner of the given token ID
	 * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address
	 */
	function addToken(address[16] _contracts, address _to, uint256 _tokenId) private {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownStorage.getTokenOwner(_tokenId) == address(0));

		// Set token owner
		ownStorage.setTokenOwner(_tokenId, _to);

		// Add token to tokenIds list
		var tokenIdsLength = ownStorage.pushTokenId(_tokenId);
		ownStorage.setTokenIdsIndex(_tokenId, tokenIdsLength.sub(1));

		uint256 ownedTokensLength = ownStorage.getOwnedTokensLength(_to);

		// Add token to ownedTokens list
		ownStorage.pushOwnedToken(_to, _tokenId);
		ownStorage.setOwnedTokensIndex(_tokenId, ownedTokensLength);

		// Increment total owned area
		var (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);
		ownStorage.incrementOwnedArea(_to, area);
	}

	/**
	 * @dev Internal function to remove a token ID from the list of a given address
	 * @param _from address representing the previous owner of the given token ID
	 * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address
	 */
	function removeToken(address[16] _contracts, address _from, uint256 _tokenId) private {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownerOf(_contracts, _tokenId) == _from);

		// Clear token owner
		ownStorage.setTokenOwner(_tokenId, 0);

		removeFromTokenIds(ownStorage, _tokenId);
		removeFromOwnedToken(ownStorage, _from, _tokenId);

		// Decrement total owned area
		var (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);
		ownStorage.decrementOwnedArea(_from, area);
	}

	/**
	 * @dev Remove token from ownedTokens list
	 * Note that this will handle single-element arrays. In that case, both ownedTokenIndex and lastOwnedTokenIndex are going to
	 * be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping
	 * the lastOwnedToken to the first position, and then dropping the element placed in the last position of the list
	 */
	function removeFromOwnedToken(BdpOwnershipStorage _ownStorage, address _from, uint256 _tokenId) private {
		var ownedTokenIndex = _ownStorage.getOwnedTokensIndex(_tokenId);
		var lastOwnedTokenIndex = _ownStorage.getOwnedTokensLength(_from).sub(1);
		var lastOwnedToken = _ownStorage.getOwnedToken(_from, lastOwnedTokenIndex);
		_ownStorage.setOwnedToken(_from, ownedTokenIndex, lastOwnedToken);
		_ownStorage.setOwnedToken(_from, lastOwnedTokenIndex, 0);
		_ownStorage.decrementOwnedTokensLength(_from);
		_ownStorage.setOwnedTokensIndex(_tokenId, 0);
		_ownStorage.setOwnedTokensIndex(lastOwnedToken, ownedTokenIndex);
	}

	/**
	 * @dev Remove token from tokenIds list
	 */
	function removeFromTokenIds(BdpOwnershipStorage _ownStorage, uint256 _tokenId) private {
		var tokenIndex = _ownStorage.getTokenIdsIndex(_tokenId);
		var lastTokenIdIndex = _ownStorage.getTokenIdsLength().sub(1);
		var lastTokenId = _ownStorage.getTokenIdByIndex(lastTokenIdIndex);
		_ownStorage.setTokenIdByIndex(tokenIndex, lastTokenId);
		_ownStorage.setTokenIdByIndex(lastTokenIdIndex, 0);
		_ownStorage.decrementTokenIdsLength();
		_ownStorage.setTokenIdsIndex(_tokenId, 0);
		_ownStorage.setTokenIdsIndex(lastTokenId, tokenIndex);
	}

	/**
	 * @dev Mint token function
	 * @param _to The address that will own the minted token
	 * @param _tokenId uint256 ID of the token to be minted by the msg.sender
	 */
	function mint(address[16] _contracts, address _to, uint256 _tokenId) public {
		require(_to != address(0));
		addToken(_contracts, _to, _tokenId);
		Transfer(address(0), _to, _tokenId);
	}

	/**
	 * @dev Burns a specific token
	 * @param _tokenId uint256 ID of the token being burned
	 */
	function burn(address[16] _contracts, uint256 _tokenId) public {
		address owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);
		clearApproval(_contracts, owner, _tokenId);
		removeToken(_contracts, owner, _tokenId);
		Transfer(owner, address(0), _tokenId);
	}

}

// File: contracts/libraries/BdpImage.sol

library BdpImage {

	function checkImageInput(address[16] _contracts, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, bool _clearImage) view public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));

		require( (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage) // Only one way to change image can be specified
			|| (_imageId != 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage) // If image has to be changed
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length != 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage)
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; _swapImages &amp;amp;&amp;amp; !_clearImage)
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; _clearImage) );

		require(_imageId == 0 || // Can use only own images not used by other regions
			( (msg.sender == imageStorage.getImageOwner(_imageId)) &amp;amp;&amp;amp; (imageStorage.getImageCurrentRegionId(_imageId) == 0) ) );

		var nextImageId = dataStorage.getRegionNextImageId(_regionId);
		require(!_swapImages || imageUploadComplete(_contracts, nextImageId)); // Can swap images if next image upload is complete
	}

	function setNextImagePart(address[16] _contracts, uint256 _regionId, uint16 _part, uint16 _partsCount, uint16 _imageDescriptor, uint256[] _imageData) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));

		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		require(_imageData.length != 0);
		require(_part &amp;gt; 0);
		require(_part &amp;lt;= _partsCount);

		var nextImageId = dataStorage.getRegionNextImageId(_regionId);
		if(nextImageId == 0 || _imageDescriptor != imageStorage.getImageDescriptor(nextImageId)) {
			var (, width, height) = BdpCalculator.calculateArea(_contracts, _regionId);
			nextImageId = imageStorage.createImage(msg.sender, _regionId, uint16(width), uint16(height), _partsCount, _imageDescriptor);
			dataStorage.setRegionNextImageId(_regionId, nextImageId);
		}

		imageStorage.setImageData(nextImageId, _part, _imageData);
	}

	function setImageOwner(address[16] _contracts, uint256 _imageId, address _owner) public {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		require(imageStorage.getImageOwner(_imageId) == msg.sender);
		require(_owner != address(0));

		imageStorage.setImageOwner(_imageId, _owner);
	}

	function setImageData(address[16] _contracts, uint256 _imageId, uint16 _part, uint256[] _imageData) public returns (address) {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		require(imageStorage.getImageOwner(_imageId) == msg.sender);
		require(imageStorage.getImageCurrentRegionId(_imageId) == 0);
		require(_imageData.length != 0);
		require(_part &amp;gt; 0);
		require(_part &amp;lt;= imageStorage.getImagePartsCount(_imageId));

		imageStorage.setImageData(_imageId, _part, _imageData);
	}

	function imageUploadComplete(address[16] _contracts, uint256 _imageId) view public returns (bool) {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		var partsCount = imageStorage.getImagePartsCount(_imageId);
		for (uint16 i = 1; i &amp;lt;= partsCount; i++) {
			if(imageStorage.getImageDataLength(_imageId, i) == 0) {
				return false;
			}
		}
		return true;
	}

}

// File: contracts/libraries/BdpCrud.sol

library BdpCrud {

	function createRegion(address[16] _contracts, address _to, uint256 _x1, uint256 _y1, uint256 _x2, uint256 _y2) public returns (uint256) {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		require(_x2 &amp;lt; 1000 &amp;amp;&amp;amp; _x1 &amp;lt;= _x2);
		require(_y2 &amp;lt; 1000 &amp;amp;&amp;amp; _y1 &amp;lt;= _y2);

		var regionId = dataStorage.getNextRegionId();
		dataStorage.setRegionCoordinates(regionId, _x1, _y1, _x2, _y2);
		dataStorage.setRegionBlockUpdatedAt(regionId, block.number);
		dataStorage.setRegionUpdatedAt(regionId, block.timestamp);

		BdpOwnership.mint(_contracts, _to, regionId);

		return regionId;
	}

	function deleteRegion(address[16] _contracts, uint256 _regionId) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		var regionPurchasePixelPrice = dataStorage.getRegionPurchasePixelPrice(_regionId);
		require(regionPurchasePixelPrice == 0);
		BdpOwnership.burn(_contracts, _regionId);
		dataStorage.deleteRegionData(_regionId);
	}

	function setupRegion(address[16] _contracts, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, uint8[128] _url) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		require(_imageId != 0 || _imageData.length != 0 || _swapImages || _url.length != 0); // Only if image or url is specified
		require(block.timestamp &amp;lt; BdpCalculator.calculateSetupAllowedUntil(_contracts, _regionId)); // Can only execute if setup is allowed
		BdpImage.checkImageInput(_contracts, _regionId, _imageId, _imageData, _swapImages, false);

		_updateRegionImage(_contracts, dataStorage, _regionId, _imageId, _imageData, _swapImages, false);
		_updateRegionUrl(dataStorage, _regionId, _url, false);

		dataStorage.setRegionBlockUpdatedAt(_regionId, block.number);
		dataStorage.setRegionUpdatedAt(_regionId, block.timestamp);
	}

	function updateRegion(address[16] _contracts, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, bool _clearImage, uint8[128] _url, bool _deleteUrl, address _newOwner) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		BdpImage.checkImageInput(_contracts, _regionId, _imageId, _imageData, _swapImages, _clearImage);
		var regionCurrentPixelPrice = dataStorage.getRegionCurrentPixelPrice(_regionId);
		require(regionCurrentPixelPrice != 0); // region was purchased

		var marketPixelPrice = BdpCalculator.calculateCurrentMarketPixelPrice(_contracts);

		var (area,,) = BdpCalculator.calculateArea(_contracts, _regionId);
		_processUpdateFee(_contracts, marketPixelPrice * area / 20);

		_updateRegionImage(_contracts, dataStorage, _regionId, _imageId, _imageData, _swapImages, _clearImage);
		_updateRegionUrl(dataStorage, _regionId, _url, _deleteUrl);
		_updateRegionOwner(_contracts, _regionId, _newOwner);
		if(marketPixelPrice &amp;gt; regionCurrentPixelPrice) {
			dataStorage.setRegionCurrentPixelPrice(_regionId, marketPixelPrice);
		}
		dataStorage.setRegionBlockUpdatedAt(_regionId, block.number);
		dataStorage.setRegionUpdatedAt(_regionId, block.timestamp);
	}

	function updateRegionPixelPrice(address[16] _contracts, uint256 _regionId, uint256 _pixelPrice) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		var regionCurrentPixelPrice = dataStorage.getRegionCurrentPixelPrice(_regionId);
		require(regionCurrentPixelPrice != 0); // region was purchased

		var marketPixelPrice = BdpCalculator.calculateCurrentMarketPixelPrice(_contracts);
		require(_pixelPrice &amp;gt;= marketPixelPrice);

		var (area,,) = BdpCalculator.calculateArea(_contracts, _regionId);
		_processUpdateFee(_contracts, _pixelPrice * area / 20);

		dataStorage.setRegionCurrentPixelPrice(_regionId, _pixelPrice);
	}

	function _processUpdateFee(address[16] _contracts, uint256 _updateFee) internal {
		require(msg.value &amp;gt;= _updateFee);

		if(msg.value &amp;gt; _updateFee) {
			var change = msg.value - _updateFee;
			msg.sender.transfer(change);
		}

		var forwardUpdateFeesTo = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getForwardUpdateFeesTo();
		if(forwardUpdateFeesTo != address(0)) {
			forwardUpdateFeesTo.transfer(_updateFee);
		}
	}

	function _updateRegionImage(address[16] _contracts, BdpDataStorage _dataStorage, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, bool _clearImage) internal {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		var currentImageId = _dataStorage.getRegionCurrentImageId(_regionId);
		if(_imageId != 0) {
			if(currentImageId != 0) {
				imageStorage.setImageCurrentRegionId(currentImageId, 0);
			}
			_dataStorage.setRegionCurrentImageId(_regionId, _imageId);
			imageStorage.setImageCurrentRegionId(_imageId, _regionId);
		}

		if(_imageData.length &amp;gt; 0) {
			if(currentImageId != 0) {
				imageStorage.setImageCurrentRegionId(currentImageId, 0);
			}
			var (, width, height) = BdpCalculator.calculateArea(_contracts, _regionId);
			var imageId = imageStorage.createImage(msg.sender, _regionId, uint16(width), uint16(height), 1, 1);
			imageStorage.setImageData(imageId, 1, _imageData);
			_dataStorage.setRegionCurrentImageId(_regionId, imageId);
			imageStorage.setImageCurrentRegionId(imageId, _regionId);
		}

		if(_swapImages) {
			if(currentImageId != 0) {
				imageStorage.setImageCurrentRegionId(currentImageId, 0);
			}
			var nextImageId = _dataStorage.getRegionNextImageId(_regionId);
			_dataStorage.setRegionCurrentImageId(_regionId, nextImageId);
			imageStorage.setImageCurrentRegionId(nextImageId, _regionId);
			_dataStorage.setRegionNextImageId(_regionId, 0);
		}

		if(_clearImage) {
			if(currentImageId != 0) {
				imageStorage.setImageCurrentRegionId(currentImageId, 0);
			}
			_dataStorage.setRegionCurrentImageId(_regionId, 0);
		}
	}

	function _updateRegionUrl(BdpDataStorage _dataStorage, uint256 _regionId, uint8[128] _url, bool _deleteUrl) internal {
		if(_url[0] != 0) {
			_dataStorage.setRegionUrl(_regionId, _url);
		}
		if(_deleteUrl) {
			uint8[128] memory emptyUrl;
			_dataStorage.setRegionUrl(_regionId, emptyUrl);
		}
	}

	function _updateRegionOwner(address[16] _contracts, uint256 _regionId, address _newOwner) internal {
		if(_newOwner != address(0)) {
			BdpOwnership.clearApprovalAndTransfer(_contracts, msg.sender, _newOwner, _regionId);
		}
	}

}

// File: contracts/libraries/BdpTransfer.sol

library BdpTransfer {

	using SafeMath for uint256;

	function approve(address[16] _contracts, address _to, uint256 _regionId) public {
		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		BdpOwnership.approve(_contracts, _to, _regionId);
	}

	function purchase(address[16] _contracts, uint256 _regionId) public {
		uint256 pixelPrice = BdpCalculator.calculateRegionSalePixelPrice(_contracts, _regionId);
		var (area,,) = BdpCalculator.calculateArea(_contracts, _regionId);
		uint256 regionPrice = pixelPrice * area;

		require(msg.value &amp;gt;= regionPrice );

		if(msg.value &amp;gt; regionPrice) {
			uint256 change = msg.value - regionPrice;
			msg.sender.transfer(change);
		}

		if(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCurrentPixelPrice(_regionId) &amp;gt; 0) { // send 95% ether to ownerOf(_regionId)
			uint256 etherToPreviousOwner = regionPrice * 19 / 20;
			BdpOwnership.ownerOf(_contracts, _regionId).transfer(etherToPreviousOwner);
			var forwardUpdateFeesTo = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getForwardUpdateFeesTo();
			if(forwardUpdateFeesTo != address(0)) {
				forwardUpdateFeesTo.transfer(regionPrice - etherToPreviousOwner);
			}
		} else {
			var forwardPurchaseFeesTo = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getForwardPurchaseFeesTo();
			if(forwardPurchaseFeesTo != address(0)) {
				forwardPurchaseFeesTo.transfer(regionPrice);
			}
		}

		BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionCurrentPixelPrice(_regionId, pixelPrice);
		BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionBlockUpdatedAt(_regionId, block.number);
		BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionUpdatedAt(_regionId, block.timestamp);
		BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedAt(_regionId, block.timestamp);
		BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedPixelPrice(_regionId, pixelPrice);

		BdpOwnership.clearApprovalAndTransfer(_contracts, BdpOwnership.ownerOf(_contracts, _regionId), msg.sender, _regionId);
	}

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x24175662a23a69e5c923A430FE12204f895171E8.sol" target="_blank" title="show github file">0x24175662a23a69e5c923A430FE12204f895171E8.sol</a>
        </div>
        <div class="path">solidity-files/0x24175662a23a69e5c923A430FE12204f895171E8.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

/*
100tokens.com Smart Contract Crowdsale
*/

// File: zeppelin-solidity/contracts/math/SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

// File: zeppelin-solidity/contracts/ownership/Ownable.sol

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

// File: zeppelin-solidity/contracts/token/ERC20Basic.sol

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

// File: zeppelin-solidity/contracts/token/BasicToken.sol

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address =&amp;gt; uint256) balances;

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}

// File: zeppelin-solidity/contracts/token/ERC20.sol

/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: zeppelin-solidity/contracts/token/StandardToken.sol

/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

  mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[_from]);
    require(_value &amp;lt;= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue &amp;gt; oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}

// File: zeppelin-solidity/contracts/token/MintableToken.sol

/**
 * @title Mintable token
 * @dev Simple ERC20 Token example, with mintable token creation
 * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
 */

contract MintableToken is StandardToken, Ownable {
  event Mint(address indexed to, uint256 amount);
  event MintFinished();

  bool public mintingFinished = false;


  modifier canMint() {
    require(!mintingFinished);
    _;
  }

  /**
   * @dev Function to mint tokens
   * @param _to The address that will receive the minted tokens.
   * @param _amount The amount of tokens to mint.
   * @return A boolean that indicates if the operation was successful.
   */
  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    Transfer(address(0), _to, _amount);
    return true;
  }

  /**
   * @dev Function to stop minting new tokens.
   * @return True if the operation was successful.
   */
  function finishMinting() onlyOwner canMint public returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
}

// File: zeppelin-solidity/contracts/crowdsale/Crowdsale.sol

/**
 * @title Crowdsale
 * @dev Crowdsale is a base contract for managing a token crowdsale.
 * Crowdsales have a start and end timestamps, where investors can make
 * token purchases and the crowdsale will assign them tokens based
 * on a token per ETH rate. Funds collected are forwarded to a wallet
 * as they arrive.
 */
contract Crowdsale {
  using SafeMath for uint256;

  // The token being sold
  MintableToken public token;

  // start and end timestamps where investments are allowed (both inclusive)
  uint256 public startTime;
  uint256 public endTime;

  // address where funds are collected
  address public wallet;

  // how many token units a buyer gets per wei
  uint256 public rate;

  // amount of raised money in wei
  uint256 public weiRaised;

  /**
   * event for token purchase logging
   * @param purchaser who paid for the tokens
   * @param beneficiary who got the tokens
   * @param value weis paid for purchase
   * @param amount amount of tokens purchased
   */
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime &amp;gt;= now);
    require(_endTime &amp;gt;= _startTime);
    require(_rate &amp;gt; 0);
    require(_wallet != address(0));

    token = createTokenContract();
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }

  // creates the token to be sold.
  // override this method to have crowdsale of a specific mintable token.
  function createTokenContract() internal returns (MintableToken) {
    return new MintableToken();
  }


  // fallback function can be used to buy tokens
  function () external payable {
    buyTokens(msg.sender);
  }

  // low level token purchase function
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    // calculate token amount to be created
    uint256 tokens = weiAmount.mul(rate);

    // update state
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  // send ether to the fund collection wallet
  // override to create custom fund forwarding mechanisms
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  // @return true if the transaction can buy tokens
  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now &amp;gt;= startTime &amp;amp;&amp;amp; now &amp;lt;= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod &amp;amp;&amp;amp; nonZeroPurchase;
  }

  // @return true if crowdsale event has ended
  function hasEnded() public view returns (bool) {
    return now &amp;gt; endTime;
  }


}


contract OHC_CrowdsaleToken is MintableToken {
  string public constant name = &amp;quot;One Hundred Coin&amp;quot;;
  string public constant symbol = &amp;quot;OHC&amp;quot;;
  uint8 public constant decimals = 18;

  // overriding BasicToken#transfer
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[msg.sender]);
    require(now &amp;gt;= 1521795600);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  event Burn(address indexed burner, uint256 value);

  function burn(address _burner, uint256 _value) onlyOwner public {
    require(_value &amp;lt;= balances[_burner]);

    balances[_burner] = balances[_burner].sub(_value);
    totalSupply = totalSupply.sub(_value);
    Burn(_burner, _value);
    Transfer(_burner, address(0), _value);
  }

}

contract OHC_Crowdsale is Crowdsale, Ownable {

  uint256 constant CAP =  1000000000000000000000000000;
  uint256 constant CAP_PRE_SALE = 200000000000000000000000000;
  uint256 constant CAP_ICO_SALE = 400000000000000000000000000;

  uint256 constant RATE1 = 70000;
  uint256 constant RATE2 = 65000;
  uint256 constant RATE3 = 60000;
  uint256 constant RATE4 = 55000;
  uint256 constant RATE5 = 35000;
  uint256 constant RATE6 = 30000;
  uint256 constant RATE7 = 25000;
  uint256 constant RATE8 = 20000;

  uint256 public totalSupplyIco;

  function OHC_Crowdsale (
    uint256 _startTime,
    uint256 _endTime,
    uint256 _rate,
    address _wallet
  ) public
    Crowdsale(_startTime, _endTime, _rate, _wallet)
  {

  }

  function createTokenContract() internal returns (MintableToken) {
    return new OHC_CrowdsaleToken();
  }

  // overriding Crowdsale#validPurchase
  function validPurchase() internal constant returns (bool) {
    if (msg.value &amp;lt; 20000000000000000) {
      return false;
    }

    if (token.totalSupply().add(msg.value.mul(getRate())) &amp;gt;= CAP) {
      return false;
    }

    if (now &amp;gt; 1525939200 &amp;amp;&amp;amp; now &amp;lt; 1539158400) {
      return false;
    }

    if (1523347200 &amp;gt;= now &amp;amp;&amp;amp; 1525939200 &amp;lt;= now) {
      if (token.totalSupply().add(msg.value.mul(getRate())) &amp;gt;= CAP_PRE_SALE) {
        return false;
      }
    }

    if (1539158400 &amp;gt;= now &amp;amp;&amp;amp; 1541840400 &amp;lt;= now) {
      if (totalSupplyIco.add(msg.value.mul(getRate())) &amp;gt;= CAP_ICO_SALE) {
        return false;
      }
    }

    if (getRate() == 0) {
      return false;
    }

    return super.validPurchase();
  }

  function buyTokens(address beneficiary) payable public {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;
    uint256 tokens = weiAmount.mul(getRate());
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  function getRate() public constant returns (uint256) {
    if (1523347200 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1523952000) {
      return RATE1;
    }

    if (1523952001 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1524556800) {
      return RATE2;
    }

    if (1524556805 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1525161600) {
      return RATE3;
    }

    if (1525161601 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1525939200) {
      return RATE4;
    }

    if (1539158400 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1539763200) {
      return RATE5;
    }

    if (1539763201 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1540368000) {
      return RATE6;
    }

    if (1540368001 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1540976400) {
      return RATE7;
    }

    if (1540976401 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1541840400) {
      return RATE8;
    }

    return 0;
  }

  function mintTokens(address walletToMint, uint256 t) onlyOwner payable public {
    require(token.totalSupply().add(t) &amp;lt; CAP);

    token.mint(walletToMint, t);
  }

  function tokenTransferOwnership(address newOwner) onlyOwner payable public {
    token.transferOwnership(newOwner);
  }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xd8ba10ebdba5437fd1c308122608d67dfed17960.sol" target="_blank" title="show github file">0xd8ba10ebdba5437fd1c308122608d67dfed17960.sol</a>
        </div>
        <div class="path">solidity-files/0xd8ba10ebdba5437fd1c308122608d67dfed17960.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;ACT239012&amp;#39; token contract
//
// Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
// Symbol      : ACT239012
// Name        : ADZbuzz Imore.com Community Token
// Total supply: 2000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function ADZbuzzCommunityToken() public {
        symbol = &amp;quot;ACT239012&amp;quot;;
        name = &amp;quot;ADZbuzz Imore.com Community Token&amp;quot;;
        decimals = 8;
        _totalSupply = 200000000000000;
        balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
        emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xd1bebf7d8222cc1a940327df606a0d9d521f5062.sol" target="_blank" title="show github file">0xd1bebf7d8222cc1a940327df606a0d9d521f5062.sol</a>
        </div>
        <div class="path">solidity-files/0xd1bebf7d8222cc1a940327df606a0d9d521f5062.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;ACT156529&amp;#39; token contract
//
// Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
// Symbol      : ACT156529
// Name        : ADZbuzz Variety.com Community Token
// Total supply: 2000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function ADZbuzzCommunityToken() public {
        symbol = &amp;quot;ACT156529&amp;quot;;
        name = &amp;quot;ADZbuzz Variety.com Community Token&amp;quot;;
        decimals = 8;
        _totalSupply = 200000000000000;
        balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
        emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x03bb85e156a5daf4b1e3357f251310a0e7e78b18.sol" target="_blank" title="show github file">0x03bb85e156a5daf4b1e3357f251310a0e7e78b18.sol</a>
        </div>
        <div class="path">solidity-files/0x03bb85e156a5daf4b1e3357f251310a0e7e78b18.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.16;

contract Token {

    /// @return total amount of tokens
    function totalSupply() constant returns (uint256 supply) {}

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint256 balance) {}

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint256 _value) returns (bool success) {}

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint256 _value) returns (bool success) {}

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    
}



contract StandardToken is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can&amp;#39;t be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&amp;#39;t wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; balances[_to] + _value &amp;gt; balances[_to]) {
        if (balances[msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; _value &amp;gt; 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] &amp;gt;= _value &amp;amp;&amp;amp; allowed[_from][msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; balances[_to] + _value &amp;gt; balances[_to]) {
        if (balances[_from] &amp;gt;= _value &amp;amp;&amp;amp; allowed[_from][msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; _value &amp;gt; 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address =&amp;gt; uint256) balances;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;
    uint256 public totalSupply;
}


//name this contract whatever you&amp;#39;d like
contract MORCO is StandardToken {

    function () {
        //if ether is sent to this address, send it back.
        throw;
    }

    /* Public variables of the token */

    /*
    NOTE:
    The following variables are OPTIONAL vanities. One does not have to include them.
    They allow one to customise the token contract &amp;amp; in no way influences the core functionality.
    Some wallets/interfaces might not even bother to look at this information.
    */
    string public name;                   //fancy name: eg Simon Bucks
    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It&amp;#39;s like comparing 1 wei to 1 ether.
    string public symbol;                 //An identifier: eg SBX
    string public version = &amp;#39;H1.0&amp;#39;;       //human 0.1 standard. Just an arbitrary versioning scheme.


    function MORCO(
        ) {
        balances[msg.sender] = 100000000000000000000000000;
        totalSupply = 100000000000000000000000000;
        name = &amp;quot;MORCO&amp;quot;;                                   // Set the name for display purposes
        decimals = 15;                            // Amount of decimals for display purposes
        symbol = &amp;quot;MCS&amp;quot;;                               // Set the symbol for display purposes
    }

    /* Approves and then calls the receiving contract */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn&amp;#39;t have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(&amp;quot;receiveApproval(address,uint256,address,bytes)&amp;quot;))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x7b126ab811f278f288bf1d62d47334351da20d1d.sol" target="_blank" title="show github file">0x7b126ab811f278f288bf1d62d47334351da20d1d.sol</a>
        </div>
        <div class="path">solidity-files/0x7b126ab811f278f288bf1d62d47334351da20d1d.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
pragma solidity 0.4.19;
/// @title Utility Functions for uint
/// @author Daniel Wang - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;d2b6b3bcbbb7be92bebdbda2a0bbbcb5fcbda0b5&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;
library MathUint {
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function sub(uint a, uint b) internal pure returns (uint) {
        require(b &amp;lt;= a);
        return a - b;
    }
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function tolerantSub(uint a, uint b) internal pure returns (uint c) {
        return (a &amp;gt;= b) ? a - b : 0;
    }
    /// @dev calculate the square of Coefficient of Variation (CV)
    /// https://en.wikipedia.org/wiki/Coefficient_of_variation
    function cvsquare(
        uint[] arr,
        uint scale
        )
        internal
        pure
        returns (uint)
    {
        uint len = arr.length;
        require(len &amp;gt; 1);
        require(scale &amp;gt; 0);
        uint avg = 0;
        for (uint i = 0; i &amp;lt; len; i++) {
            avg += arr[i];
        }
        avg = avg / len;
        if (avg == 0) {
            return 0;
        }
        uint cvs = 0;
        uint s;
        uint item;
        for (i = 0; i &amp;lt; len; i++) {
            item = arr[i];
            s = item &amp;gt; avg ? item - avg : avg - item;
            cvs += mul(s, s);
        }
        return ((mul(mul(cvs, scale), scale) / avg) / avg) / (len - 1);
    }
}
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/// @title ERC20 Token Interface
/// @dev see https://github.com/ethereum/EIPs/issues/20
/// @author Daniel Wang - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;fb9f9a95929e97bb9794948b8992959cd594899c&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;
contract ERC20 {
    uint public totalSupply;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function balanceOf(address who) view public returns (uint256);
    function allowance(address owner, address spender) view public returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
}
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/// @title Ownable
/// @dev The Ownable contract has an owner address, and provides basic
///      authorization control functions, this simplifies the implementation of
///      &amp;quot;user permissions&amp;quot;.
contract Ownable {
    address public owner;
    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );
    /// @dev The Ownable constructor sets the original `owner` of the contract
    ///      to the sender.
    function Ownable() public {
        owner = msg.sender;
    }
    /// @dev Throws if called by any account other than the owner.
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    /// @dev Allows the current owner to transfer control of the contract to a
    ///      newOwner.
    /// @param newOwner The address to transfer ownership to.
    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != 0x0);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
/// @title Claimable
/// @dev Extension for the Ownable contract, where the ownership needs
///      to be claimed. This allows the new owner to accept the transfer.
contract Claimable is Ownable {
    address public pendingOwner;
    /// @dev Modifier throws if called by any account other than the pendingOwner.
    modifier onlyPendingOwner() {
        require(msg.sender == pendingOwner);
        _;
    }
    /// @dev Allows the current owner to set the pendingOwner address.
    /// @param newOwner The address to transfer ownership to.
    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != 0x0 &amp;amp;&amp;amp; newOwner != owner);
        pendingOwner = newOwner;
    }
    /// @dev Allows the pendingOwner address to finalize the transfer.
    function claimOwnership() onlyPendingOwner public {
        OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = 0x0;
    }
}
/// @title TokenTransferDelegate
/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different
/// versions of Loopring protocol to avoid ERC20 re-authorization.
/// @author Daniel Wang - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;096d6867606c6549656666797b60676e27667b6e&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;.
contract TokenTransferDelegate is Claimable {
    using MathUint for uint;
    ////////////////////////////////////////////////////////////////////////////
    /// Variables                                                            ///
    ////////////////////////////////////////////////////////////////////////////
    mapping(address =&amp;gt; AddressInfo) private addressInfos;
    address public latestAddress;
    ////////////////////////////////////////////////////////////////////////////
    /// Structs                                                              ///
    ////////////////////////////////////////////////////////////////////////////
    struct AddressInfo {
        address previous;
        uint32  index;
        bool    authorized;
    }
    ////////////////////////////////////////////////////////////////////////////
    /// Modifiers                                                            ///
    ////////////////////////////////////////////////////////////////////////////
    modifier onlyAuthorized() {
        require(addressInfos[msg.sender].authorized);
        _;
    }
    ////////////////////////////////////////////////////////////////////////////
    /// Events                                                               ///
    ////////////////////////////////////////////////////////////////////////////
    event AddressAuthorized(address indexed addr, uint32 number);
    event AddressDeauthorized(address indexed addr, uint32 number);
    ////////////////////////////////////////////////////////////////////////////
    /// Public Functions                                                     ///
    ////////////////////////////////////////////////////////////////////////////
    /// @dev Disable default function.
    function () payable public {
        revert();
    }
    /// @dev Add a Loopring protocol address.
    /// @param addr A loopring protocol address.
    function authorizeAddress(address addr)
        onlyOwner
        external
    {
        AddressInfo storage addrInfo = addressInfos[addr];
        if (addrInfo.index != 0) { // existing
            if (addrInfo.authorized == false) { // re-authorize
                addrInfo.authorized = true;
                AddressAuthorized(addr, addrInfo.index);
            }
        } else {
            address prev = latestAddress;
            if (prev == 0x0) {
                addrInfo.index = 1;
                addrInfo.authorized = true;
            } else {
                addrInfo.previous = prev;
                addrInfo.index = addressInfos[prev].index + 1;
            }
            addrInfo.authorized = true;
            latestAddress = addr;
            AddressAuthorized(addr, addrInfo.index);
        }
    }
    /// @dev Remove a Loopring protocol address.
    /// @param addr A loopring protocol address.
    function deauthorizeAddress(address addr)
        onlyOwner
        external
    {
        uint32 index = addressInfos[addr].index;
        if (index != 0) {
            addressInfos[addr].authorized = false;
            AddressDeauthorized(addr, index);
        }
    }
    function getLatestAuthorizedAddresses(uint max)
        external
        view
        returns (address[] addresses)
    {
        addresses = new address[](max);
        address addr = latestAddress;
        AddressInfo memory addrInfo;
        uint count = 0;
        while (addr != 0x0 &amp;amp;&amp;amp; count &amp;lt; max) {
            addrInfo = addressInfos[addr];
            if (addrInfo.index == 0) {
                break;
            }
            addresses[count++] = addr;
            addr = addrInfo.previous;
        }
    }
    /// @dev Invoke ERC20 transferFrom method.
    /// @param token Address of token to transfer.
    /// @param from Address to transfer token from.
    /// @param to Address to transfer token to.
    /// @param value Amount of token to transfer.
    function transferToken(
        address token,
        address from,
        address to,
        uint    value)
        onlyAuthorized
        external
    {
        if (value &amp;gt; 0 &amp;amp;&amp;amp; from != to &amp;amp;&amp;amp; to != 0x0) {
            require(
                ERC20(token).transferFrom(from, to, value)
            );
        }
    }
    function batchTransferToken(
        address lrcTokenAddress,
        address minerFeeRecipient,
        uint8 walletSplitPercentage,
        bytes32[] batch)
        onlyAuthorized
        external
    {
        uint len = batch.length;
        require(len % 7 == 0);
        require(walletSplitPercentage &amp;gt; 0 &amp;amp;&amp;amp; walletSplitPercentage &amp;lt; 100);
        ERC20 lrc = ERC20(lrcTokenAddress);
        for (uint i = 0; i &amp;lt; len; i += 7) {
            address owner = address(batch[i]);
            address prevOwner = address(batch[(i + len - 7) % len]);
            // Pay token to previous order, or to miner as previous order&amp;#39;s
            // margin split or/and this order&amp;#39;s margin split.
            ERC20 token = ERC20(address(batch[i + 1]));
            // Here batch[i + 2] has been checked not to be 0.
            if (owner != prevOwner) {
                require(
                    token.transferFrom(
                        owner,
                        prevOwner,
                        uint(batch[i + 2])
                    )
                );
            }
            // Miner pays LRx fee to order owner
            uint lrcReward = uint(batch[i + 4]);
            if (lrcReward != 0 &amp;amp;&amp;amp; minerFeeRecipient != owner) {
                require(
                    lrc.transferFrom(
                        minerFeeRecipient,
                        owner,
                        lrcReward
                    )
                );
            }
            // Split margin-split income between miner and wallet
            splitPayFee(
                token,
                uint(batch[i + 3]),
                owner,
                minerFeeRecipient,
                address(batch[i + 6]),
                walletSplitPercentage
            );
            // Split LRx fee income between miner and wallet
            splitPayFee(
                lrc,
                uint(batch[i + 5]),
                owner,
                minerFeeRecipient,
                address(batch[i + 6]),
                walletSplitPercentage
            );
        }
    }
    function isAddressAuthorized(address addr)
        public
        view
        returns (bool)
    {
        return addressInfos[addr].authorized;
    }
    function splitPayFee(
        ERC20   token,
        uint    fee,
        address owner,
        address minerFeeRecipient,
        address walletFeeRecipient,
        uint    walletSplitPercentage
        )
        internal
    {
        if (fee == 0) {
            return;
        }
        uint walletFee = (walletFeeRecipient == 0x0) ? 0 : fee.mul(walletSplitPercentage) / 100;
        uint minerFee = fee - walletFee;
        if (walletFee &amp;gt; 0 &amp;amp;&amp;amp; walletFeeRecipient != owner) {
            require(
                token.transferFrom(
                    owner,
                    walletFeeRecipient,
                    walletFee
                )
            );
        }
        if (minerFee &amp;gt; 0 &amp;amp;&amp;amp; minerFeeRecipient != 0x0 &amp;amp;&amp;amp; minerFeeRecipient != owner) {
            require(
                token.transferFrom(
                    owner,
                    minerFeeRecipient,
                    minerFee
                )
            );
        }
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x17c93f4bfe407b4f58b73c7839f3a588d499e67d.sol" target="_blank" title="show github file">0x17c93f4bfe407b4f58b73c7839f3a588d499e67d.sol</a>
        </div>
        <div class="path">solidity-files/0x17c93f4bfe407b4f58b73c7839f3a588d499e67d.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;




/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}


/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address =&amp;gt; uint256) balances;

  uint256 totalSupply_;

  /**
  * @dev total number of tokens in existence
  */
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}




/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}


/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

  mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[_from]);
    require(_value &amp;lt;= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue &amp;gt; oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}


/**
 * @title Burnable Token
 * @dev Token that can be irreversibly burned (destroyed).
 */
contract BurnableToken is StandardToken {

  event Burn(address indexed burner, uint256 value);

  /**
   * @dev Burns a specific amount of tokens.
   * @param _value The amount of token to be burned.
   */
  function burn(uint256 _value) public {
    require(_value &amp;lt;= balances[msg.sender]);
    // no need to require value &amp;lt;= totalSupply, since that would imply the
    // sender&amp;#39;s balance is greater than the totalSupply, which *should* be an assertion failure

    address burner = msg.sender;
    balances[burner] = balances[burner].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    Burn(burner, _value);
    Transfer(burner, address(0), _value);
  }
}

/**
 * @title FobsCoin
 */
 
contract FobsCoin is StandardToken, BurnableToken {

  string public constant name = &amp;quot;Fobscoin&amp;quot;;
  string public constant symbol = &amp;quot;FOBS&amp;quot;; 
  uint8 public constant decimals = 18; 

  uint256 public constant INITIAL_SUPPLY = 10000000 * (10 ** uint256(decimals));

  /**
   * @dev Constructor that gives msg.sender all of existing tokens.
   */
  function FobsCoin() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x02b0cfdc2ce5775feb68be62a7df3bba56598817.sol" target="_blank" title="show github file">0x02b0cfdc2ce5775feb68be62a7df3bba56598817.sol</a>
        </div>
        <div class="path">solidity-files/0x02b0cfdc2ce5775feb68be62a7df3bba56598817.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b &amp;lt;= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c &amp;gt;= a);
        return c;
    }

    function max64(uint64 a, uint64 b) internal pure returns (uint64) {
        return a &amp;gt;= b ? a : b;
    }

    function min64(uint64 a, uint64 b) internal pure returns (uint64) {
        return a &amp;lt; b ? a : b;
    }

    function max256(uint256 a, uint256 b) internal pure returns (uint256) {
        return a &amp;gt;= b ? a : b;
    }

    function min256(uint256 a, uint256 b) internal pure returns (uint256) {
        return a &amp;lt; b ? a : b;
    }
}

contract ERC20Basic {
    uint256 public totalSupply;

    bool public transfersEnabled;

    function balanceOf(address who) public view returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
}

contract ERC20 {
    uint256 public totalSupply;

    bool public transfersEnabled;

    function balanceOf(address _owner) public constant returns (uint256 balance);

    function transfer(address _to, uint256 _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    function approve(address _spender, uint256 _value) public returns (bool success);

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract BasicToken is ERC20Basic {
    using SafeMath for uint256;

    mapping(address =&amp;gt; uint256) balances;

    /**
    * @dev protection against short address attack
    */
    modifier onlyPayloadSize(uint numwords) {
        assert(msg.data.length == numwords * 32 + 4);
        _;
    }


    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[msg.sender]);
        require(transfersEnabled);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

}

contract StandardToken is ERC20, BasicToken {

    mapping(address =&amp;gt; mapping(address =&amp;gt; uint256)) internal allowed;

    /**
     * @dev Transfer tokens from one address to another
     * @param _from address The address which you want to send tokens from
     * @param _to address The address which you want to transfer to
     * @param _value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3) returns (bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[_from]);
        require(_value &amp;lt;= allowed[_from][msg.sender]);
        require(transfersEnabled);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     *
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param _spender The address which will spend the funds.
     * @param _value The amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address _owner, address _spender) public onlyPayloadSize(2) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /**
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     */
    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue &amp;gt; oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

}

contract EthereumAI is StandardToken {

    string public constant name = &amp;quot;Ethereum AI&amp;quot;;
    string public constant symbol = &amp;quot;ETHAI&amp;quot;;
    uint8 public constant decimals = 18;
    uint256 public constant INITIAL_SUPPLY = 1 * 10**9 * (10**uint256(decimals));
    uint256 public weiRaised;
    uint256 public tokenAllocated;
    address public owner;
    bool public saleToken = true;

    event OwnerChanged(address indexed previousOwner, address indexed newOwner);
    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
    event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function EthereumAI(address _owner) public {
        totalSupply = INITIAL_SUPPLY;
        owner = _owner;
        //owner = msg.sender; // for testing
        balances[owner] = INITIAL_SUPPLY;
        tokenAllocated = 0;
        transfersEnabled = true;
    }

    // fallback function can be used to buy tokens
    function() payable public {
        buyTokens(msg.sender);
    }

    function buyTokens(address _investor) public payable returns (uint256){
        require(_investor != address(0));
        require(saleToken == true);
        address wallet = owner;
        uint256 weiAmount = msg.value;
        uint256 tokens = validPurchaseTokens(weiAmount);
        if (tokens == 0) {revert();}
        weiRaised = weiRaised.add(weiAmount);
        tokenAllocated = tokenAllocated.add(tokens);
        mint(_investor, tokens, owner);

        TokenPurchase(_investor, weiAmount, tokens);
        wallet.transfer(weiAmount);
        return tokens;
    }

    function validPurchaseTokens(uint256 _weiAmount) public returns (uint256) {
        uint256 addTokens = getTotalAmountOfTokens(_weiAmount);
        if (addTokens &amp;gt; balances[owner]) {
            TokenLimitReached(tokenAllocated, addTokens);
            return 0;
        }
        return addTokens;
    }

    /**
    * If the user sends 0 ether, he receives 100tokens.
    * If he sends 0.001 ether, he receives 3000tokens
    * If he sends 0.005 ether he receives 16,000tokens
    * If he sends 0.01ether, he receives 35000 tokens
    * If he sends 0.05ether he receives 175000tokens
    * If he sends 0.1ether, he receives 360,000tokens
    */
    function getTotalAmountOfTokens(uint256 _weiAmount) internal pure returns (uint256) {
        uint256 amountOfTokens = 0;
        if(_weiAmount == 0){
            amountOfTokens = 100 * (10**uint256(decimals));
        }
        if( _weiAmount == 0.001 ether){
            amountOfTokens = 3 * 10**3 * (10**uint256(decimals));
        }
        if( _weiAmount == 0.005 ether){
            amountOfTokens = 16 * 10**3 * (10**uint256(decimals));
        }
        if( _weiAmount == 0.01 ether){
            amountOfTokens = 35 * 10**3 * (10**uint256(decimals));
        }
        if( _weiAmount == 0.05 ether){
            amountOfTokens = 175 * 10**3 * (10**uint256(decimals));
        }
        if( _weiAmount == 0.1 ether){
            amountOfTokens = 360 * 10**3 * (10**uint256(decimals));
        }
        return amountOfTokens;
    }

    function mint(address _to, uint256 _amount, address _owner) internal returns (bool) {
        require(_to != address(0));
        require(_amount &amp;lt;= balances[_owner]);

        balances[_to] = balances[_to].add(_amount);
        balances[_owner] = balances[_owner].sub(_amount);
        Transfer(_owner, _to, _amount);
        return true;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function changeOwner(address _newOwner) onlyOwner public returns (bool){
        require(_newOwner != address(0));
        OwnerChanged(owner, _newOwner);
        owner = _newOwner;
        return true;
    }

    function startSale() public onlyOwner {
        saleToken = true;
    }

    function stopSale() public onlyOwner {
        saleToken = false;
    }

    function enableTransfers(bool _transfersEnabled) onlyOwner public {
        transfersEnabled = _transfersEnabled;
    }

    /**
     * Peterson&amp;#39;s Law Protection
     * Claim tokens
     */
    function claimTokens() public onlyOwner {
        owner.transfer(this.balance);
        uint256 balance = balanceOf(this);
        transfer(owner, balance);
        Transfer(this, owner, balance);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xf6b6aa0ef0f5edc2c1c5d925477f97eaf66303e7.sol" target="_blank" title="show github file">0xf6b6aa0ef0f5edc2c1c5d925477f97eaf66303e7.sol</a>
        </div>
        <div class="path">solidity-files/0xf6b6aa0ef0f5edc2c1c5d925477f97eaf66303e7.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

// Going Gems (Gems for Purchasing Game) 
// Token name: Going Gems
// Symbol: XGG
// Decimals: 8
// Twitter : @GoingGems



library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

contract ForeignToken {
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
}

contract ERC20Basic {
    uint256 public totalSupply;
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface Token { 
    function distr(address _to, uint256 _value) public returns (bool);
    function totalSupply() constant public returns (uint256 supply);
    function balanceOf(address _owner) constant public returns (uint256 balance);
}

contract GoingGems is ERC20 {
    
    using SafeMath for uint256;
    address owner = msg.sender;

    mapping (address =&amp;gt; uint256) balances;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;
    mapping (address =&amp;gt; bool) public blacklist;

    string public constant name = &amp;quot;Going Gems&amp;quot;;
    string public constant symbol = &amp;quot;XGG&amp;quot;;
    uint public constant decimals = 8;
    
    uint256 public totalSupply = 1000000000e8;
    uint256 public totalDistributed = 400000000e8;
    uint256 public totalRemaining = totalSupply.sub(totalDistributed);
    uint256 public value;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    
    event Distr(address indexed to, uint256 amount);
    event DistrFinished();
    
    event Burn(address indexed burner, uint256 value);

    bool public distributionFinished = false;
    
    modifier canDistr() {
        require(!distributionFinished);
        _;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }
    
    function GoingGems (uint random, address randomAddr) public {
        owner = msg.sender;
        value = 5000e8;
        distr(owner, totalDistributed);
    }
    
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
    
    function enableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i &amp;lt; addresses.length; i++) {
            blacklist[addresses[i]] = false;
        }
    }

    function disableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i &amp;lt; addresses.length; i++) {
            blacklist[addresses[i]] = true;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        DistrFinished();
        return true;
    }
    
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);
        totalRemaining = totalRemaining.sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Distr(_to, _amount);
        Transfer(address(0), _to, _amount);
        return true;
        
        if (totalDistributed &amp;gt;= totalSupply) {
            distributionFinished = true;
        }
    }
    
    function airdrop(address[] addresses) onlyOwner canDistr public {
        
        require(addresses.length &amp;lt;= 255);
        require(value &amp;lt;= totalRemaining);
        
        for (uint i = 0; i &amp;lt; addresses.length; i++) {
            require(value &amp;lt;= totalRemaining);
            distr(addresses[i], value);
        }
	
        if (totalDistributed &amp;gt;= totalSupply) {
            distributionFinished = true;
        }
    }
    
    function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public {
        
        require(addresses.length &amp;lt;= 255);
        require(amount &amp;lt;= totalRemaining);
        
        for (uint i = 0; i &amp;lt; addresses.length; i++) {
            require(amount &amp;lt;= totalRemaining);
            distr(addresses[i], amount);
        }
	
        if (totalDistributed &amp;gt;= totalSupply) {
            distributionFinished = true;
        }
    }
    
    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {

        require(addresses.length &amp;lt;= 255);
        require(addresses.length == amounts.length);
        
        for (uint8 i = 0; i &amp;lt; addresses.length; i++) {
            require(amounts[i] &amp;lt;= totalRemaining);
            distr(addresses[i], amounts[i]);
            
            if (totalDistributed &amp;gt;= totalSupply) {
                distributionFinished = true;
            }
        }
    }
    
    function () external payable {
            getTokens();
     }
    
    function getTokens() payable canDistr onlyWhitelist public {
        
        if (value &amp;gt; totalRemaining) {
            value = totalRemaining;
        }
        
        require(value &amp;lt;= totalRemaining);
        
        address investor = msg.sender;
        uint256 toGive = value;
        
        distr(investor, toGive);
        
        if (toGive &amp;gt; 0) {
            blacklist[investor] = true;
        }

        if (totalDistributed &amp;gt;= totalSupply) {
            distributionFinished = true;
        }
        
        value = value.div(100000).mul(99999);
    }

    function balanceOf(address _owner) constant public returns (uint256) {
	    return balances[_owner];
    }

    // mitigates the ERC20 short address attack
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length &amp;gt;= size + 4);
        _;
    }
    
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount &amp;lt;= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount &amp;lt;= balances[_from]);
        require(_amount &amp;lt;= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
        // mitigates the ERC20 spend/approval race condition
        if (_value != 0 &amp;amp;&amp;amp; allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    
    function withdraw() onlyOwner public {
        uint256 etherBalance = this.balance;
        owner.transfer(etherBalance);
    }
    
    function burn(uint256 _value) onlyOwner public {
        require(_value &amp;lt;= balances[msg.sender]);
        // no need to require value &amp;lt;= totalSupply, since that would imply the
        // sender&amp;#39;s balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        Burn(burner, _value);
    }
    
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }


}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x1f4bfab69d34f769833b90a9b0c106f23d59be7f.sol" target="_blank" title="show github file">0x1f4bfab69d34f769833b90a9b0c106f23d59be7f.sol</a>
        </div>
        <div class="path">solidity-files/0x1f4bfab69d34f769833b90a9b0c106f23d59be7f.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT275258&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT275258
    // Name        : ADZbuzz Sciencemag.org Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT275258&amp;quot;;
            name = &amp;quot;ADZbuzz Sciencemag.org Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xa35d00500c2942d51ee1364576bc2ac71819df68.sol" target="_blank" title="show github file">0xa35d00500c2942d51ee1364576bc2ac71819df68.sol</a>
        </div>
        <div class="path">solidity-files/0xa35d00500c2942d51ee1364576bc2ac71819df68.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">/* This source code is part of CACIB DocChain registered trademark
*  It is provided becaused published in the public blockchain of Ethereum.
*  Reusing this code is forbidden without approbation of CACIB first (&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;b8d1dcddd9f8dbd995dbd1da96dbd7d5&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;)
*  Providing this code in public repository is meant to provide clarity to the mechanism by which the DocChain product works
*/
pragma solidity ^0.4.11;

/**
 * The IEthIdentity interface defines fundamental functionnalities
 * that every Ethereum identity in this framework must implement to be 
 * usable with DocChain principles.
 * 
 * The purpose of implementing IEthIdentity interface is to prove its own identity
 * and let others checking whether any proof has been made by its identity.
 */
interface IEthIdentity {
    
    /**
     * Add proof if it does not exist yet
     *  - address: the smart contract address where the identity proof has been stored (see eSignature contract)
     *  - bytes32: the attribute id or proof id for which the identity owner has made a proof
     */
    function addProof(address, bytes32) public returns(bool);
    
    /**
     * Remove proof of a source if existed
     *  - address: the smart contract address where the identity proof has been stored (see eSignature contract)
     *  - bytes32: the attribute id or proof id to be removed
     */
    function removeProof(address, bytes32) public returns(bool);

    /**
     * Check whether the provided address is the controlling wallet (owner) of the identity
     */
    function checkOwner(address) public constant returns(bool);
    
    /**
     * Get the identity owner name
     */
    function getIdentityName() public constant returns(bytes32);
    
}

/**
 * The implementation of IEthIdentity interface.
 * 
 * This is just an implementation of IEthIdentity interface, other implementation
 * may be different. However, the fundamental functionnalities defined in IEthIdentity
 * interface must be fully implemented to be compatible with the framework.
 */
contract EthIdentity is IEthIdentity {
    
    /**
     * The EthIdentity contract is a prudent identity proof of its owner
     * When contract is created, it assigns the sender of creating contract
     * transaction as its owner. 
     * The contract owner can only be changed by the override owner.
     * The override owner can only be changed by the override owner.
     * Although set as private but they can always be read via the getStorageAt. It saves bytecode in the final structure
     */
    address public owner;
    address private override;
    
    /**
     * The identity name is a string for human readability and visibility
     * but is stored as 32 bytes in order to be used between contract calls.
     */
    bytes32 private identityName;
    
    /**
     * Constructor of EthIdentity contract
     * Only execute once.
     * receives the Name of the identity
     */
    function EthIdentity(bytes32 _name) public {
        owner = msg.sender;
        override = msg.sender;
        identityName = _name;
    }
    
    /**
     * Constants for event type &amp;amp; notifications
     */
    uint constant ERROR_EVENT = 119;
    uint constant INFO_EVENT = 115;
    
    /**
     * This event is used for change notification and outputs the following:
     * - event sender (indexed for filter)
     * - event status (indexed for filter)
     * - event message
     */
    event EventNotification(address indexed sender, uint indexed status, bytes32 message);
    
    /**
     * The list of proofs stored by this identity owner
     * The identity owner can store several proofs for a particular source, hence
     * is defined as a mapping list that use the proof value (attribute) as key
     * Hence the attribute value must be unique accross all sources.
     * 
     * For the eSignature contract, the proof is defined as the document id
     * generated by this contract when the document hash is added/signed by an identity owner.
     * For a wider use, it can be any attribute that is stored by this identity owner, but must be a bytes32 for optimisation.
     */
    mapping(bytes32 =&amp;gt; address) proofList;
    
    /**
     * Add a proof ONLY if not already present and ONLY by the identity owner
     * 
     * _source: address of the source (e.g. eSignature contract) where the proof has been stored
     * _attribute: a bytes32 representing the attribute at the source identifying the proof
     * 
     * For eSignature case, _attribute is the document id generated when the identity adds/signs the document
     */
    function addProof(address _source, bytes32 _attribute) public onlyBy(owner) returns(bool) {
        // Check input
        require(_source != address(0x0));
        
        // Check proof existence
        bool existed = checkProof(_attribute);
        
        // Returns and do nothing except emitting event if the proof already exists
        if (existed == true) {
            EventNotification(msg.sender, ERROR_EVENT, &amp;quot;Proof already exist&amp;quot;);
            return false;
        }
        
        // Add new proof
        proofList[_attribute] = _source;
        
        EventNotification(msg.sender, INFO_EVENT, &amp;quot;New proof added&amp;quot;);
        return true;
    }
    
    /**
     * Remove proof of a source ONLY if present and ONLY by the identity owner
     * 
     * _source: address of the source (e.g. eSignature contract) where the proof has been stored
     * _attribute: a bytes32 representing the attribute at the source identifying the proof
     * 
     * For eSignature case, _attribute is the document id generated when the identity adds/signs the document
     */
    function removeProof(address _source, bytes32 _attribute) public onlyBy(owner) returns(bool) {
        // Check proof existence
        bool existed = checkProof(_attribute);
        
        // Return and do nothing except emitting event if the proof does not exist
        if (existed == false) {
            EventNotification(msg.sender, ERROR_EVENT, &amp;quot;Proof not found&amp;quot;);
            return false;
        }
        
        // Return and do nothing except emitting event if the source is not correct
        if (proofList[_attribute] != _source) {
            EventNotification(msg.sender, ERROR_EVENT, &amp;quot;Incorrect source&amp;quot;);
            return false;
        }
        
        // Delete existing proof
        delete proofList[_attribute];
        
        EventNotification(msg.sender, INFO_EVENT, &amp;quot;Proof removed&amp;quot;);
        return true;
    }
    
    /**
     * Check whether the identity owner has stored a proof with a  source
     * Return true if proof is found
     * 
     * _attribute: a string representing the attribute of the source for which the proof has been made
     * 
     * For eSignature case, _attribute is the document id generated when the identity create/sign the document
     */
    function checkProof(bytes32 _attribute) public constant returns(bool) {
        var source = proofList[_attribute];
        // Check if proof source is assigned &amp;amp; matched
        if (source != address(0x0))
            return true;
        // Proof not exists since its source is not matched    
        return false;
    }
    
    /**
     * Check whether the provided address is the controlling wallet of the identity
     * Return true if yes
     */
    function checkOwner(address _check) public constant returns(bool) {
        return _check == owner;
    }
    
    /**
     * Get the identity owner name, usable inside contract call
     */
    function getIdentityName() public constant returns(bytes32) {
        return identityName;
    }
    
    /**
     * Show the name of the identity in string 
     * (for Etherscan read-only function)
     */
    function nameOfIdentity() public constant returns(string) {
        return bytes32ToString(identityName);
    }
    
    /**
     * Get the identity detail information
     */
    function getIdentityInfo() public constant returns(address, address, string) {
        return (override, owner, bytes32ToString(identityName));
    }
    
     /**
     * Only the identity owner can set its name
     */
    function setIdentityName(bytes32 _newName) public onlyBy(owner) returns(bool) {
        identityName = _newName;
        EventNotification(msg.sender, INFO_EVENT, &amp;quot;Set owner name&amp;quot;);
        return true;
    }
    
    /**
     * Only the override address is allowed to change the owner address.
     */
    function setOwner(address _newOwner) public onlyBy(override) returns(bool) {
        owner = _newOwner;
        EventNotification(msg.sender, INFO_EVENT, &amp;quot;Set new owner&amp;quot;);
        return true;
    }

    /**
     * Only the override address is allowed to change the override address.
     */
    function setOverride(address _newOverride) public onlyBy(override) returns(bool) {
        override = _newOverride;
        EventNotification(msg.sender, INFO_EVENT, &amp;quot;Set new override&amp;quot;);
        return true;
    }
    
    /**
     * Convert bytes32 to string. Set modifier pure which means cannot
     * access the contract storage.
     */
    function bytes32ToString(bytes32 data) internal pure returns (string) {
        bytes memory bytesString = new bytes(32);
        for (uint j=0; j&amp;lt;32; j++){
            if (data[j] != 0) {
                bytesString[j] = data[j];
            }
        }
        return string(bytesString);
    }
    
    /**
     * Modifier to make a constraint on who is permitted
     * to execute a function
     */
    modifier onlyBy(address _authorized) {
        assert(msg.sender == _authorized);
        _;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x63da5c2d6c066c95f054170e5a5a9f6c9c4b406f.sol" target="_blank" title="show github file">0x63da5c2d6c066c95f054170e5a5a9f6c9c4b406f.sol</a>
        </div>
        <div class="path">solidity-files/0x63da5c2d6c066c95f054170e5a5a9f6c9c4b406f.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT121930&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT121930
    // Name        : ADZbuzz Espn.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT121930&amp;quot;;
            name = &amp;quot;ADZbuzz Espn.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x3cc2661846c4d04ab6268784429228e80e70a280.sol" target="_blank" title="show github file">0x3cc2661846c4d04ab6268784429228e80e70a280.sol</a>
        </div>
        <div class="path">solidity-files/0x3cc2661846c4d04ab6268784429228e80e70a280.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT108470&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT108470
    // Name        : ADZbuzz Bit.ly Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT108470&amp;quot;;
            name = &amp;quot;ADZbuzz Bit.ly Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x9673328837f7e978ef70d5e692ebfc3073317a61.sol" target="_blank" title="show github file">0x9673328837f7e978ef70d5e692ebfc3073317a61.sol</a>
        </div>
        <div class="path">solidity-files/0x9673328837f7e978ef70d5e692ebfc3073317a61.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

contract BaseToken {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping (address =&amp;gt; uint256) public balanceOf;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] &amp;gt;= _value);
        require(balanceOf[_to] + _value &amp;gt; balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
        Transfer(_from, _to, _value);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value &amp;lt;= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
}

contract CustomToken is BaseToken {
    function CustomToken() public {
        totalSupply = 200000000000000000000000000;
        name = &amp;#39;YahooChain&amp;#39;;
        symbol = &amp;#39;YHO&amp;#39;;
        decimals = 18;
        balanceOf[0xe1f77b81a2383162cbbdd0dd93630f31a6672477] = totalSupply;
        Transfer(address(0), 0xe1f77b81a2383162cbbdd0dd93630f31a6672477, totalSupply);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xce59a5ce4af6c36ddaeeb149c382bacf2e70e817.sol" target="_blank" title="show github file">0xce59a5ce4af6c36ddaeeb149c382bacf2e70e817.sol</a>
        </div>
        <div class="path">solidity-files/0xce59a5ce4af6c36ddaeeb149c382bacf2e70e817.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.4;

contract Token {

    /// @return total amount of tokens
    function totalSupply() constant returns (uint256 supply) {}

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint256 balance) {}

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint256 _value) returns (bool success) {}

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint256 _value) returns (bool success) {}

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    
}



contract StandardToken is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can&amp;#39;t be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&amp;#39;t wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; balances[_to] + _value &amp;gt; balances[_to]) {
        if (balances[msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; _value &amp;gt; 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] &amp;gt;= _value &amp;amp;&amp;amp; allowed[_from][msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; balances[_to] + _value &amp;gt; balances[_to]) {
        if (balances[_from] &amp;gt;= _value &amp;amp;&amp;amp; allowed[_from][msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; _value &amp;gt; 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address =&amp;gt; uint256) balances;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;
    uint256 public totalSupply;
}


//name this contract whatever you&amp;#39;d like
contract ERC20Token is StandardToken {

    function () {
        //if ether is sent to this address, send it back.
        throw;
    }

    /* Public variables of the token */

    /*
    NOTE:
    The following variables are OPTIONAL vanities. One does not have to include them.
    They allow one to customise the token contract &amp;amp; in no way influences the core functionality.
    Some wallets/interfaces might not even bother to look at this information.
    */
    string public name;                   //fancy name: eg Simon Bucks
    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It&amp;#39;s like comparing 1 wei to 1 ether.
    string public symbol;                 //An identifier: eg SBX
    string public version = &amp;#39;H1.0&amp;#39;;       //human 0.1 standard. Just an arbitrary versioning scheme.

//
// CHANGE THESE VALUES FOR YOUR TOKEN
//

//make sure this function name matches the contract name above. So if you&amp;#39;re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token

    function ERC20Token(
        ) {
        balances[msg.sender] = 100000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 100000000000;                        // Update total supply (100000 for example)
        name = &amp;quot;cryptoworldbank&amp;quot;;                                   // Set the name for display purposes
        decimals = 2;                            // Amount of decimals for display purposes
        symbol = &amp;quot;CWB&amp;quot;;                               // Set the symbol for display purposes
    }

    /* Approves and then calls the receiving contract */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn&amp;#39;t have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(&amp;quot;receiveApproval(address,uint256,address,bytes)&amp;quot;))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x6fd0305217f176c128a9e236d7cb3e459892a290.sol" target="_blank" title="show github file">0x6fd0305217f176c128a9e236d7cb3e459892a290.sol</a>
        </div>
        <div class="path">solidity-files/0x6fd0305217f176c128a9e236d7cb3e459892a290.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}

contract BigbomPrivateSaleList is Ownable {
    mapping(address=&amp;gt;uint) public addressCap;

    function BigbomPrivateSaleList() public  {}

    event ListAddress( address _user, uint _amount, uint _time );

    // Owner can delist by setting amount = 0.
    // Onwer can also change it at any time
    function listAddress( address _user, uint _amount ) public onlyOwner {
        require(_user != address(0x0));

        addressCap[_user] = _amount;
        ListAddress( _user, _amount, now );
    }

    // an optimization in case of network congestion
    function listAddresses( address[] _users, uint[] _amount ) public onlyOwner {
        require(_users.length == _amount.length );
        for( uint i = 0 ; i &amp;lt; _users.length ; i++ ) {
            listAddress( _users[i], _amount[i] );
        }
    }

    function getCap( address _user ) public constant returns(uint) {
        return addressCap[_user];
    }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xcafa0159cdf721cb10120c0b054050ce369a9937.sol" target="_blank" title="show github file">0xcafa0159cdf721cb10120c0b054050ce369a9937.sol</a>
        </div>
        <div class="path">solidity-files/0xcafa0159cdf721cb10120c0b054050ce369a9937.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT287517&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT287517
    // Name        : ADZbuzz Zinzino.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT287517&amp;quot;;
            name = &amp;quot;ADZbuzz Zinzino.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xf85a2e95fa30d005f629cbe6c6d2887d979fff2a.sol" target="_blank" title="show github file">0xf85a2e95fa30d005f629cbe6c6d2887d979fff2a.sol</a>
        </div>
        <div class="path">solidity-files/0xf85a2e95fa30d005f629cbe6c6d2887d979fff2a.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.21;
    
   // ----------------------------------------------------------------------------------------------
   // Project Delta 
   // DELTA - New Crypto-Platform with own currency, verified semantic contracts and multi blockchains!
   // Site: http://delta.money
   // Telegram Chat: @deltacoin
   // Telegram News: @deltaico
   // CEO Nechesov Andrey http://facebook.com/Nechesov     
   // Ltd. &amp;quot;Delta&amp;quot;   
   // Tokens Delta: BUY and SELL into this smart contract on exchange
   // ----------------------------------------------------------------------------------------------
    
  library SafeMath {
    function mul(uint256 a, uint256 b) internal returns (uint256) {
      uint256 c = a * b;
      assert(a == 0 || c / a == b);
      return c;
    }

    function div(uint256 a, uint256 b) internal returns (uint256) {
      // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
      uint256 c = a / b;
      // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
      return c;
    }

    function sub(uint256 a, uint256 b) internal returns (uint256) {
      assert(b &amp;lt;= a);
      return a - b;
    }

    function add(uint256 a, uint256 b) internal returns (uint256) {
      uint256 c = a + b;
      assert(c &amp;gt;= a);
      return c;
    }
  }

   // ERC Token Standard #20 Interface
   // https://github.com/ethereum/EIPs/issues/20

  contract ERC20Interface {
      // Get the total token supply
      function totalSupply() constant returns (uint256 totalSupply);
   
      // Get the account balance of another account with address _owner
      function balanceOf(address _owner) constant returns (uint256 balance);
   
      // Send _value amount of tokens to address _to
      function transfer(address _to, uint256 _value) returns (bool success);
   
      // Send _value amount of tokens from address _from to address _to
      function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
   
      // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
      // If this function is called again it overwrites the current allowance with _value.
      // this function is required for some DEX functionality
      function approve(address _spender, uint256 _value) returns (bool success);
   
      // Returns the amount which _spender is still allowed to withdraw from _owner
      function allowance(address _owner, address _spender) constant returns (uint256 remaining);
   
      // Triggered when tokens are transferred.
      event Transfer(address indexed _from, address indexed _to, uint256 _value);
   
      // Triggered whenever approve(address _spender, uint256 _value) is called.
      event Approval(address indexed _owner, address indexed _spender, uint256 _value);
  }

  contract MigrationAgent {
    function migrateFrom(address _from, uint256 _value);
  }      
   
  contract TokenBase is ERC20Interface {

      using SafeMath for uint;

      string public constant symbol = &amp;quot;DELTA&amp;quot;;
      string public constant name = &amp;quot;DELTA token&amp;quot;;
      uint8 public constant decimals = 18; 
           
      uint256 public constant maxTokens = (2**32-1)*10**18; 
      uint256 public constant ownerSupply = maxTokens*25/100;
      uint256 _totalSupply = ownerSupply;              

      // For future
      // If migration to a new contract is allowed
      bool public migrationAllowed = false;

      // New contract address
      address public migrationAddress;

      // How many tokens were migrated to a new contract 
      uint256 public totalMigrated = 0; 
      
      // Owner of this contract
      address public owner;
   
      // Balances for each account
      mapping(address =&amp;gt; uint256) balances;
   
      // Owner of account approves the transfer of an amount to another account
      mapping(address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;

      // Orders holders who wish sell tokens, save amount
      mapping(address =&amp;gt; uint256) public orders_sell_amount;

      // Orders holders who wish sell tokens, save price
      mapping(address =&amp;gt; uint256) public orders_sell_price;

      //orders list
      address[] public orders_sell_list;

      // Triggered orders sell/buy
      event Orders_sell(address indexed _from, address indexed _to, uint256 _amount, uint256 _price, uint256 _seller_money, uint256 _buyer_money);
   
      // Functions with this modifier can only be executed by the owner
      modifier onlyOwner() {
          if (msg.sender != owner) {
              throw;
          }
          _;
      }

      // Migrate tokens to a new contract
      function migrate(uint256 _value) external {
          require(migrationAllowed);
          require(migrationAddress != 0x0);
          require(_value &amp;gt; 0);
          require(_value &amp;lt;= balances[msg.sender]);

          balances[msg.sender] = balances[msg.sender].sub(_value);
          _totalSupply = _totalSupply.sub(_value);
          totalMigrated = totalMigrated.add(_value);

          MigrationAgent(migrationAddress).migrateFrom(msg.sender, _value);
      }  
      
      function configureMigrate(bool _migrationAllowed, address _migrationAddress) onlyOwner {
          migrationAllowed = _migrationAllowed;
          migrationAddress = _migrationAddress;
      }

  }

  contract DELTA_Token is TokenBase {

      using SafeMath for uint;

      uint256 public constant token_price = 10**18*1/100; 

      uint public pre_ico_start = 1522540800;
      uint public ico_start = 1525132800;
      uint public ico_finish = 1530403200;             

      uint public p1 = 250;             
      uint public p2 = 200;             
      uint public p3 = 150;             
      uint public p4 = 125;             
      uint public p5 = 100;

      uint public coef = 105;      
   
      // Constructor
      function DELTA_Token() {
          owner = msg.sender;
          balances[owner] = ownerSupply;
      }
      
      //default function for buy tokens      
      function() payable {        
          tokens_buy();        
      }
      
      function totalSupply() constant returns (uint256 totalSupply) {
          totalSupply = _totalSupply;
      }

      //Withdraw money from contract balance to owner
      function withdraw(uint256 _amount) onlyOwner returns (bool result) {
          uint256 balance;
          balance = this.balance;
          if(_amount &amp;gt; 0) balance = _amount;
          owner.send(balance);
          return true;
      }

      //Change coef
      function change_coef(uint256 _coef) onlyOwner returns (bool result) {
          coef = _coef;
          return true;
      }

      function change_p1(uint256 _p1) onlyOwner returns (bool result) {
          p1 = _p1;
          return true;
      }

      function change_p2(uint256 _p2) onlyOwner returns (bool result) {
          p2 = _p2;
          return true;
      }

      function change_p3(uint256 _p3) onlyOwner returns (bool result) {
          p3 = _p3;
          return true;
      }

      function change_p4(uint256 _p4) onlyOwner returns (bool result) {
          p4 = _p4;
          return true;
      }

      function change_p5(uint256 _p5) onlyOwner returns (bool result) {
          p5 = _p5;
          return true;
      }

      //Change pre_ico_start date
      function change_pre_ico_start(uint256 _pre_ico_start) onlyOwner returns (bool result) {
          pre_ico_start = _pre_ico_start;
          return true;
      }

      //Change ico_start date
      function change_ico_start(uint256 _ico_start) onlyOwner returns (bool result) {
          ico_start = _ico_start;
          return true;
      }

      //Change ico_finish date
      function change_ico_finish(uint256 _ico_finish) onlyOwner returns (bool result) {
          ico_finish = _ico_finish;
          return true;
      }
   
      // What is the balance of a particular account?
      function balanceOf(address _owner) constant returns (uint256 balance) {
          return balances[_owner];
      }
   
      // Transfer the balance from owner&amp;#39;s account to another account
      function transfer(address _to, uint256 _amount) returns (bool success) {          

          if (balances[msg.sender] &amp;gt;= _amount 
              &amp;amp;&amp;amp; _amount &amp;gt; 0
              &amp;amp;&amp;amp; balances[_to] + _amount &amp;gt; balances[_to]) {
              balances[msg.sender] -= _amount;
              balances[_to] += _amount;
              Transfer(msg.sender, _to, _amount);
              return true;
          } else {
              return false;
          }
      }
   
      // Send _value amount of tokens from address _from to address _to
      // The transferFrom method is used for a withdraw workflow, allowing contracts to send
      // tokens on your behalf, for example to &amp;quot;deposit&amp;quot; to a contract address and/or to charge
      // fees in sub-currencies; the command should fail unless the _from account has
      // deliberately authorized the sender of the message via some mechanism; we propose
      // these standardized APIs for approval:
      function transferFrom(
          address _from,
          address _to,
          uint256 _amount
     ) returns (bool success) {         

         if (balances[_from] &amp;gt;= _amount
             &amp;amp;&amp;amp; allowed[_from][msg.sender] &amp;gt;= _amount
             &amp;amp;&amp;amp; _amount &amp;gt; 0
             &amp;amp;&amp;amp; balances[_to] + _amount &amp;gt; balances[_to]) {
             balances[_from] -= _amount;
             allowed[_from][msg.sender] -= _amount;
             balances[_to] += _amount;
             Transfer(_from, _to, _amount);
             return true;
         } else {
             return false;
         }
     }
  
     // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
     // If this function is called again it overwrites the current allowance with _value.
     function approve(address _spender, uint256 _amount) returns (bool success) {
         allowed[msg.sender][_spender] = _amount;
         Approval(msg.sender, _spender, _amount);
         return true;
     }
  
     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
         return allowed[_owner][_spender];
     } 

      /**
      * Buy tokens on pre-ico and ico 
      */
      function tokens_buy() payable returns (bool) { 

        uint tnow = now;        
        
        require(tnow &amp;lt;= ico_finish);
        require(_totalSupply &amp;lt; maxTokens);
        require(msg.value &amp;gt;= token_price);        

        uint tokens_buy = msg.value*10**18/token_price;

        require(tokens_buy &amp;gt; 0);   
        
        if(tnow &amp;lt; ico_start + 86400*0){          
          tokens_buy = tokens_buy*p1/100;
        } 
        if((ico_start + 86400*0 &amp;lt;= tnow)&amp;amp;&amp;amp;(tnow &amp;lt; ico_start + 86400*2)){
          tokens_buy = tokens_buy*p2/100;
        } 
        if((ico_start + 86400*2 &amp;lt;= tnow)&amp;amp;&amp;amp;(tnow &amp;lt; ico_start + 86400*7)){
          tokens_buy = tokens_buy*p3/100;        
        } 
        if((ico_start + 86400*7 &amp;lt;= tnow)&amp;amp;&amp;amp;(tnow &amp;lt; ico_start + 86400*14)){
          tokens_buy = tokens_buy*p4/100;        
        }
        if(ico_start + 86400*14 &amp;lt;= tnow){
          tokens_buy = tokens_buy*p5/100;        
        }         

        require(_totalSupply.add(tokens_buy) &amp;lt;= maxTokens);
        _totalSupply = _totalSupply.add(tokens_buy);
        balances[msg.sender] = balances[msg.sender].add(tokens_buy);         

        return true;
      }      

      function orders_sell_total () constant returns (uint) {
        return orders_sell_list.length;
      } 

      function get_orders_sell_amount(address _from) constant returns(uint) {

        uint _amount_max = 0;

        if(!(orders_sell_amount[_from] &amp;gt; 0)) return _amount_max;

        if(balanceOf(_from) &amp;gt; 0) _amount_max = balanceOf(_from);
        if(orders_sell_amount[_from] &amp;lt; _amount_max) _amount_max = orders_sell_amount[_from];

        return _amount_max;
      }

      /**
      * Order Sell tokens  
      */
      function order_sell(uint256 _max_amount, uint256 _price) returns (bool) {

        require(_max_amount &amp;gt; 0);
        require(_price &amp;gt; 0);        

        orders_sell_amount[msg.sender] = _max_amount;
        orders_sell_price[msg.sender] = (_price*coef).div(100);
        orders_sell_list.push(msg.sender);        

        return true;
      }

      function order_buy(address _from, uint256 _max_price) payable returns (bool) {
        
        require(msg.value &amp;gt; 0);
        require(_max_price &amp;gt; 0);        
        require(orders_sell_amount[_from] &amp;gt; 0);
        require(orders_sell_price[_from] &amp;gt; 0); 
        require(orders_sell_price[_from] &amp;lt;= _max_price);

        uint _amount = (msg.value*10**18).div(orders_sell_price[_from]);
        uint _amount_from = get_orders_sell_amount(_from);

        if(_amount &amp;gt; _amount_from) _amount = _amount_from;        
        require(_amount &amp;gt; 0);        

        uint _total_money = (orders_sell_price[_from]*_amount).div(10**18);        
        require(_total_money &amp;lt;= msg.value);

        uint _seller_money = (_total_money*100).div(coef);
        uint _buyer_money = msg.value - _total_money;

        require(_seller_money &amp;gt; 0);        
        require(_seller_money + _buyer_money &amp;lt;= msg.value);
        
        _from.send(_seller_money);
        msg.sender.send(_buyer_money);

        orders_sell_amount[_from] -= _amount;        
        balances[_from] -= _amount;
        balances[msg.sender] += _amount; 

        Orders_sell(_from, msg.sender, _amount, orders_sell_price[_from], _seller_money, _buyer_money);

      }
      
 }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xb1ea18b3195d25847fedc83511043ac2be9e9bf1.sol" target="_blank" title="show github file">0xb1ea18b3195d25847fedc83511043ac2be9e9bf1.sol</a>
        </div>
        <div class="path">solidity-files/0xb1ea18b3195d25847fedc83511043ac2be9e9bf1.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;


/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

/**
 * @title Contract that will work with ERC223 tokens.
 */
 
contract ERC223ReceivingContract {

  struct TKN {
    address sender;
    uint value;
    bytes data;
    bytes4 sig;
  }

  /**
   * @dev Standard ERC223 function that will handle incoming token transfers.
   *
   * @param _from  Token sender address.
   * @param _value Amount of tokens.
   * @param _data  Transaction metadata.
   */
  function tokenFallback(address _from, uint _value, bytes _data) public pure {
    TKN memory tkn;
    tkn.sender = _from;
    tkn.value = _value;
    tkn.data = _data;
    if(_data.length &amp;gt; 0) {
      uint32 u = uint32(_data[3]) + (uint32(_data[2]) &amp;lt;&amp;lt; 8) + (uint32(_data[1]) &amp;lt;&amp;lt; 16) + (uint32(_data[0]) &amp;lt;&amp;lt; 24);
      tkn.sig = bytes4(u);
    }

    /* tkn variable is analogue of msg variable of Ether transaction
    *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender)
    *  tkn.value the number of tokens that were sent   (analogue of msg.value)
    *  tkn.data is data of token transaction   (analogue of msg.data)
    *  tkn.sig is 4 bytes signature of function
    *  if data of token transaction is a function execution
    */
  }

}

contract ERC223Interface {
  uint public totalSupply;
  function balanceOf(address who) public view returns (uint);
  function allowedAddressesOf(address who) public view returns (bool);
  function getTotalSupply() public view returns (uint);

  function transfer(address to, uint value) public returns (bool ok);
  function transfer(address to, uint value, bytes data) public returns (bool ok);
  function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok);

  event Transfer(address indexed from, address indexed to, uint256 value);
}

/**
 * @title Unity Token is ERC223 token.
 * @author Vladimir Kovalchuk
 */

contract UnityToken is ERC223Interface {
  using SafeMath for uint;

  string public constant name = &amp;quot;Unity Token&amp;quot;;
  string public constant symbol = &amp;quot;UNT&amp;quot;;
  uint8 public constant decimals = 18;


  /* The supply is initially 100UNT to the precision of 18 decimals */
  uint public constant INITIAL_SUPPLY = 100000 * (10 ** uint(decimals));

  mapping(address =&amp;gt; uint) balances; // List of user balances.
  mapping(address =&amp;gt; bool) allowedAddresses;

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function addAllowed(address newAddress) public onlyOwner {
    allowedAddresses[newAddress] = true;
  }

  function removeAllowed(address remAddress) public onlyOwner {
    allowedAddresses[remAddress] = false;
  }


  address public owner;

  /* Constructor initializes the owner&amp;#39;s balance and the supply  */
  function UnityToken() public {
    owner = msg.sender;
    totalSupply = INITIAL_SUPPLY;
    balances[owner] = INITIAL_SUPPLY;
  }

  function getTotalSupply() public view returns (uint) {
    return totalSupply;
  }

  // Function that is called when a user or another contract wants to transfer funds .
  function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
    if (isContract(_to)) {
      require(allowedAddresses[_to]);
      if (balanceOf(msg.sender) &amp;lt; _value)
        revert();

      balances[msg.sender] = balances[msg.sender].sub(_value);
      balances[_to] = balances[_to].add(_value);
      assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
      Transfer(msg.sender, _to, _value);
      return true;
    }
    else {
      return transferToAddress(_to, _value);
    }
  }


  // Function that is called when a user or another contract wants to transfer funds .
  function transfer(address _to, uint _value, bytes _data) public returns (bool success) {

    if (isContract(_to)) {
      return transferToContract(_to, _value, _data);
    } else {
      return transferToAddress(_to, _value);
    }
  }

  // Standard function transfer similar to ERC20 transfer with no _data .
  // Added due to backwards compatibility reasons .
  function transfer(address _to, uint _value) public returns (bool success) {
    //standard function transfer similar to ERC20 transfer with no _data
    //added due to backwards compatibility reasons
    bytes memory empty;
    if (isContract(_to)) {
      return transferToContract(_to, _value, empty);
    }
    else {
      return transferToAddress(_to, _value);
    }
  }

  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.
  function isContract(address _addr) private view returns (bool is_contract) {
    uint length;
    assembly {
    //retrieve the size of the code on target address, this needs assembly
      length := extcodesize(_addr)
    }
    return (length &amp;gt; 0);
  }

  //function that is called when transaction target is an address
  function transferToAddress(address _to, uint _value) private returns (bool success) {
    if (balanceOf(msg.sender) &amp;lt; _value)
      revert();
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  //function that is called when transaction target is a contract
  function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {
    require(allowedAddresses[_to]);
    if (balanceOf(msg.sender) &amp;lt; _value)
      revert();
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
    receiver.tokenFallback(msg.sender, _value, _data);
    Transfer(msg.sender, _to, _value);
    return true;
  }


  function balanceOf(address _owner) public view returns (uint balance) {
    return balances[_owner];
  }

  function allowedAddressesOf(address _owner) public view returns (bool allowed) {
    return allowedAddresses[_owner];
  }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xBf0Ad2f31aaF6Af7C20f1aFcbfeB1677A2343217.sol" target="_blank" title="show github file">0xBf0Ad2f31aaF6Af7C20f1aFcbfeB1677A2343217.sol</a>
        </div>
        <div class="path">solidity-files/0xBf0Ad2f31aaF6Af7C20f1aFcbfeB1677A2343217.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network 
pragma solidity ^0.4.11;


/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}
// Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin




/**
 * Math operations with safety checks
 */
contract SafeMath {
  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b &amp;gt; 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c&amp;gt;=a &amp;amp;&amp;amp; c&amp;gt;=b);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a &amp;gt;= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a &amp;lt; b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a &amp;gt;= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a &amp;lt; b ? a : b;
  }

}



/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}


/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * Safe unsigned safe math.
 *
 * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli
 *
 * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol
 *
 * Maintained here until merged to mainline zeppelin-solidity.
 *
 */
library SafeMathLibExt {

  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
    assert(b &amp;gt; 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c&amp;gt;=a);
    return c;
  }

}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */




/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */





/*
 * Haltable
 *
 * Abstract contract that allows children to implement an
 * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.
 *
 *
 * Originally envisioned in FirstBlood ICO contract.
 */
contract Haltable is Ownable {
  bool public halted;

  modifier stopInEmergency {
    if (halted) throw;
    _;
  }

  modifier stopNonOwnersInEmergency {
    if (halted &amp;amp;&amp;amp; msg.sender != owner) throw;
    _;
  }

  modifier onlyInEmergency {
    if (!halted) throw;
    _;
  }

  // called by the owner on emergency, triggers stopped state
  function halt() external onlyOwner {
    halted = true;
  }

  // called by the owner on end of emergency, returns to normal state
  function unhalt() external onlyOwner onlyInEmergency {
    halted = false;
  }

}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * Interface for defining crowdsale pricing.
 */
contract PricingStrategy {

  address public tier;

  /** Interface declaration. */
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  /** Self check if all references are correctly set.
   *
   * Checks that pricing strategy matches crowdsale parameters.
   */
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  /**
   * @dev Pricing tells if this is a presale purchase or not.
     @param purchaser Address of the purchaser
     @return False by default, true if a presale purchaser
   */
  function isPresalePurchase(address purchaser) public constant returns (bool) {
    return false;
  }

  /* How many weis one token costs */
  function updateRate(uint newOneTokenInWei) public;

  /**
   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.
   *
   *
   * @param value - What is the value of the transaction send in as wei
   * @param tokensSold - how much tokens have been sold this far
   * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale
   * @param msgSender - who is the investor of this transaction
   * @param decimals - how many decimal units the token has
   * @return Amount of tokens the investor receives
   */
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * Finalize agent defines what happens at the end of succeseful crowdsale.
 *
 * - Allocate tokens for founders, bounties and community
 * - Make tokens transferable
 * - etc.
 */
contract FinalizeAgent {

  bool public reservedTokensAreDistributed = false;

  function isFinalizeAgent() public constant returns(bool) {
    return true;
  }

  /** Return true if we can run finalizeCrowdsale() properly.
   *
   * This is a safety check function that doesn&amp;#39;t allow crowdsale to begin
   * unless the finalizer has been set up properly.
   */
  function isSane() public constant returns (bool);

  function distributeReservedTokens(uint reservedTokensDistributionBatch);

  /** Called once by crowdsale finalize() if the sale was success. */
  function finalizeCrowdsale();

}
/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */









/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}


/**
 * A token that defines fractional units as decimals.
 */
contract FractionalERC20Ext is ERC20 {

  uint public decimals;
  uint public minCap;

}



/**
 * Abstract base contract for token sales.
 *
 * Handle
 * - start and end dates
 * - accepting investments
 * - minimum funding goal and refund
 * - various statistics during the crowdfund
 * - different pricing strategies
 * - different investment policies (require server side customer id, allow only whitelisted addresses)
 *
 */
contract CrowdsaleExt is Haltable {

  /* Max investment count when we are still allowed to change the multisig address */
  uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;

  using SafeMathLibExt for uint;

  /* The token we are selling */
  FractionalERC20Ext public token;

  /* How we are going to price our offering */
  PricingStrategy public pricingStrategy;

  /* Post-success callback */
  FinalizeAgent public finalizeAgent;

  /* name of the crowdsale tier */
  string public name;

  /* tokens will be transfered from this address */
  address public multisigWallet;

  /* if the funding goal is not reached, investors may withdraw their funds */
  uint public minimumFundingGoal;

  /* the UNIX timestamp start date of the crowdsale */
  uint public startsAt;

  /* the UNIX timestamp end date of the crowdsale */
  uint public endsAt;

  /* the number of tokens already sold through this contract*/
  uint public tokensSold = 0;

  /* How many wei of funding we have raised */
  uint public weiRaised = 0;

  /* How many distinct addresses have invested */
  uint public investorCount = 0;

  /* Has this crowdsale been finalized */
  bool public finalized;

  bool public isWhiteListed;

  address[] public joinedCrowdsales;
  uint8 public joinedCrowdsalesLen = 0;
  uint8 public joinedCrowdsalesLenMax = 50;
  struct JoinedCrowdsaleStatus {
    bool isJoined;
    uint8 position;
  }
  mapping (address =&amp;gt; JoinedCrowdsaleStatus) joinedCrowdsaleState;

  /** How much ETH each address has invested to this crowdsale */
  mapping (address =&amp;gt; uint256) public investedAmountOf;

  /** How much tokens this crowdsale has credited for each investor address */
  mapping (address =&amp;gt; uint256) public tokenAmountOf;

  struct WhiteListData {
    bool status;
    uint minCap;
    uint maxCap;
  }

  //is crowdsale updatable
  bool public isUpdatable;

  /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */
  mapping (address =&amp;gt; WhiteListData) public earlyParticipantWhitelist;

  /** List of whitelisted addresses */
  address[] public whitelistedParticipants;

  /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */
  uint public ownerTestValue;

  /** State machine
   *
   * - Preparing: All contract initialization calls and variables have not been set yet
   * - Prefunding: We have not passed start time yet
   * - Funding: Active crowdsale
   * - Success: Minimum funding goal reached
   * - Failure: Minimum funding goal not reached before ending time
   * - Finalized: The finalized has been called and succesfully executed
   */
  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}

  // A new investment was made
  event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);

  // Address early participation whitelist status changed
  event Whitelisted(address addr, bool status, uint minCap, uint maxCap);
  event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);

  // Crowdsale start time has been changed
  event StartsAtChanged(uint newStartsAt);

  // Crowdsale end time has been changed
  event EndsAtChanged(uint newEndsAt);

  function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {

    owner = msg.sender;

    name = _name;

    token = FractionalERC20Ext(_token);

    setPricingStrategy(_pricingStrategy);

    multisigWallet = _multisigWallet;
    if(multisigWallet == 0) {
        throw;
    }

    if(_start == 0) {
        throw;
    }

    startsAt = _start;

    if(_end == 0) {
        throw;
    }

    endsAt = _end;

    // Don&amp;#39;t mess the dates
    if(startsAt &amp;gt;= endsAt) {
        throw;
    }

    // Minimum funding goal can be zero
    minimumFundingGoal = _minimumFundingGoal;

    isUpdatable = _isUpdatable;

    isWhiteListed = _isWhiteListed;
  }

  /**
   * Don&amp;#39;t expect to just send in money and get tokens.
   */
  function() payable {
    throw;
  }

  /**
   * Make an investment.
   *
   * Crowdsale must be running for one to invest.
   * We must have not pressed the emergency brake.
   *
   * @param receiver The Ethereum address who receives the tokens
   * @param customerId (optional) UUID v4 to track the successful payments on the server side
   *
   */
  function investInternal(address receiver, uint128 customerId) stopInEmergency private {

    // Determine if it&amp;#39;s a good time to accept investment from this participant
    if(getState() == State.PreFunding) {
      // Are we whitelisted for early deposit
      throw;
    } else if(getState() == State.Funding) {
      // Retail participants can only come in when the crowdsale is running
      // pass
      if(isWhiteListed) {
        if(!earlyParticipantWhitelist[receiver].status) {
          throw;
        }
      }
    } else {
      // Unwanted state
      throw;
    }

    uint weiAmount = msg.value;

    // Account presale sales separately, so that they do not count against pricing tranches
    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());

    if(tokenAmount == 0) {
      // Dust transaction
      throw;
    }

    if(isWhiteListed) {
      if(tokenAmount &amp;lt; earlyParticipantWhitelist[receiver].minCap &amp;amp;&amp;amp; tokenAmountOf[receiver] == 0) {
        // tokenAmount &amp;lt; minCap for investor
        throw;
      }

      // Check that we did not bust the investor&amp;#39;s cap
      if (isBreakingInvestorCap(receiver, tokenAmount)) {
        throw;
      }

      updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);
    } else {
      if(tokenAmount &amp;lt; token.minCap() &amp;amp;&amp;amp; tokenAmountOf[receiver] == 0) {
        throw;
      }
    }

    if(investedAmountOf[receiver] == 0) {
       // A new investor
       investorCount++;
    }

    // Update investor
    investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);
    tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);

    // Update totals
    weiRaised = weiRaised.plus(weiAmount);
    tokensSold = tokensSold.plus(tokenAmount);

    // Check that we did not bust the cap
    if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {
      throw;
    }

    assignTokens(receiver, tokenAmount);

    // Pocket the money
    if(!multisigWallet.send(weiAmount)) throw;

    // Tell us invest was success
    Invested(receiver, weiAmount, tokenAmount, customerId);
  }

  /**
   * Allow anonymous contributions to this crowdsale.
   */
  function invest(address addr) public payable {
    investInternal(addr, 0);
  }

  /**
   * The basic entry point to participate the crowdsale process.
   *
   * Pay for funding, get invested tokens back in the sender address.
   */
  function buy() public payable {
    invest(msg.sender);
  }

  function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {
    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != address(0)) {
      finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);
    }
  }

  function areReservedTokensDistributed() public constant returns (bool) {
    return finalizeAgent.reservedTokensAreDistributed();
  }

  function canDistributeReservedTokens() public constant returns(bool) {
    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if ((lastTierCntrct.getState() == State.Success) &amp;amp;&amp;amp; !lastTierCntrct.halted() &amp;amp;&amp;amp; !lastTierCntrct.finalized() &amp;amp;&amp;amp; !lastTierCntrct.areReservedTokensDistributed()) return true;
    return false;
  }

  /**
   * Finalize a succcesful crowdsale.
   *
   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.
   */
  function finalize() public inState(State.Success) onlyOwner stopInEmergency {

    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != address(0)) {
      finalizeAgent.finalizeCrowdsale();
    }

    finalized = true;
  }

  /**
   * Allow to (re)set finalize agent.
   *
   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.
   */
  function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {
    assert(address(addr) != address(0));
    assert(address(finalizeAgent) == address(0));
    finalizeAgent = addr;

    // Don&amp;#39;t allow setting bad agent
    if(!finalizeAgent.isFinalizeAgent()) {
      throw;
    }
  }

  /**
   * Allow addresses to do early participation.
   */
  function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {
    if (!isWhiteListed) throw;
    assert(addr != address(0));
    assert(maxCap &amp;gt; 0);
    assert(minCap &amp;lt;= maxCap);
    assert(now &amp;lt;= endsAt);

    if (!isAddressWhitelisted(addr)) {
      whitelistedParticipants.push(addr);
      Whitelisted(addr, status, minCap, maxCap);
    } else {
      WhitelistItemChanged(addr, status, minCap, maxCap);
    }

    earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});
  }

  function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {
    if (!isWhiteListed) throw;
    assert(now &amp;lt;= endsAt);
    assert(addrs.length == statuses.length);
    assert(statuses.length == minCaps.length);
    assert(minCaps.length == maxCaps.length);
    for (uint iterator = 0; iterator &amp;lt; addrs.length; iterator++) {
      setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);
    }
  }

  function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {
    if (!isWhiteListed) throw;
    if (tokensBought &amp;lt; earlyParticipantWhitelist[reciever].minCap &amp;amp;&amp;amp; tokenAmountOf[reciever] == 0) throw;

    uint8 tierPosition = getTierPosition(this);

    for (uint8 j = tierPosition + 1; j &amp;lt; joinedCrowdsalesLen; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);
    }
  }

  function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {
    if (!isWhiteListed) throw;
    assert(addr != address(0));
    assert(now &amp;lt;= endsAt);
    assert(isTierJoined(msg.sender));
    if (tokensBought &amp;lt; earlyParticipantWhitelist[addr].minCap &amp;amp;&amp;amp; tokenAmountOf[addr] == 0) throw;
    //if (addr != msg.sender &amp;amp;&amp;amp; contractAddr != msg.sender) throw;
    uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;
    newMaxCap = newMaxCap.minus(tokensBought);
    earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});
  }

  function isAddressWhitelisted(address addr) public constant returns(bool) {
    for (uint i = 0; i &amp;lt; whitelistedParticipants.length; i++) {
      if (whitelistedParticipants[i] == addr) {
        return true;
        break;
      }
    }

    return false;
  }

  function whitelistedParticipantsLength() public constant returns (uint) {
    return whitelistedParticipants.length;
  }

  function isTierJoined(address addr) public constant returns(bool) {
    return joinedCrowdsaleState[addr].isJoined;
  }

  function getTierPosition(address addr) public constant returns(uint8) {
    return joinedCrowdsaleState[addr].position;
  }

  function getLastTier() public constant returns(address) {
    if (joinedCrowdsalesLen &amp;gt; 0)
      return joinedCrowdsales[joinedCrowdsalesLen - 1];
    else
      return address(0);
  }

  function setJoinedCrowdsales(address addr) private onlyOwner {
    assert(addr != address(0));
    assert(joinedCrowdsalesLen &amp;lt;= joinedCrowdsalesLenMax);
    assert(!isTierJoined(addr));
    joinedCrowdsales.push(addr);
    joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({
      isJoined: true,
      position: joinedCrowdsalesLen
    });
    joinedCrowdsalesLen++;
  }

  function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {
    assert(addrs.length &amp;gt; 0);
    assert(joinedCrowdsalesLen == 0);
    assert(addrs.length &amp;lt;= joinedCrowdsalesLenMax);
    for (uint8 iter = 0; iter &amp;lt; addrs.length; iter++) {
      setJoinedCrowdsales(addrs[iter]);
    }
  }

  function setStartsAt(uint time) onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now &amp;lt;= time); // Don&amp;#39;t change past
    assert(time &amp;lt;= endsAt);
    assert(now &amp;lt;= startsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if (lastTierCntrct.finalized()) throw;

    uint8 tierPosition = getTierPosition(this);

    //start time should be greater then end time of previous tiers
    for (uint8 j = 0; j &amp;lt; tierPosition; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      assert(time &amp;gt;= crowdsale.endsAt());
    }

    startsAt = time;
    StartsAtChanged(startsAt);
  }

  /**
   * Allow crowdsale owner to close early or extend the crowdsale.
   *
   * This is useful e.g. for a manual soft cap implementation:
   * - after X amount is reached determine manual closing
   *
   * This may put the crowdsale to an invalid state,
   * but we trust owners know what they are doing.
   *
   */
  function setEndsAt(uint time) public onlyOwner {
    assert(!finalized);
    assert(isUpdatable);
    assert(now &amp;lt;= time);// Don&amp;#39;t change past
    assert(startsAt &amp;lt;= time);
    assert(now &amp;lt;= endsAt);

    CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());
    if (lastTierCntrct.finalized()) throw;


    uint8 tierPosition = getTierPosition(this);

    for (uint8 j = tierPosition + 1; j &amp;lt; joinedCrowdsalesLen; j++) {
      CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);
      assert(time &amp;lt;= crowdsale.startsAt());
    }

    endsAt = time;
    EndsAtChanged(endsAt);
  }

  /**
   * Allow to (re)set pricing strategy.
   *
   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.
   */
  function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {
    assert(address(_pricingStrategy) != address(0));
    assert(address(pricingStrategy) == address(0));
    pricingStrategy = _pricingStrategy;

    // Don&amp;#39;t allow setting bad agent
    if(!pricingStrategy.isPricingStrategy()) {
      throw;
    }
  }

  /**
   * Allow to change the team multisig address in the case of emergency.
   *
   * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun
   * (we have done only few test transactions). After the crowdsale is going
   * then multisig address stays locked for the safety reasons.
   */
  function setMultisig(address addr) public onlyOwner {

    // Change
    if(investorCount &amp;gt; MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {
      throw;
    }

    multisigWallet = addr;
  }

  /**
   * @return true if the crowdsale has raised enough money to be a successful.
   */
  function isMinimumGoalReached() public constant returns (bool reached) {
    return weiRaised &amp;gt;= minimumFundingGoal;
  }

  /**
   * Check if the contract relationship looks good.
   */
  function isFinalizerSane() public constant returns (bool sane) {
    return finalizeAgent.isSane();
  }

  /**
   * Check if the contract relationship looks good.
   */
  function isPricingSane() public constant returns (bool sane) {
    return pricingStrategy.isSane(address(this));
  }

  /**
   * Crowdfund state machine management.
   *
   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.
   */
  function getState() public constant returns (State) {
    if(finalized) return State.Finalized;
    else if (address(finalizeAgent) == 0) return State.Preparing;
    else if (!finalizeAgent.isSane()) return State.Preparing;
    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;
    else if (block.timestamp &amp;lt; startsAt) return State.PreFunding;
    else if (block.timestamp &amp;lt;= endsAt &amp;amp;&amp;amp; !isCrowdsaleFull()) return State.Funding;
    else if (isMinimumGoalReached()) return State.Success;
    else return State.Failure;
  }

  /** Interface marker. */
  function isCrowdsale() public constant returns (bool) {
    return true;
  }

  //
  // Modifiers
  //

  /** Modified allowing execution only if the crowdsale is currently running.  */
  modifier inState(State state) {
    if(getState() != state) throw;
    _;
  }


  //
  // Abstract functions
  //

  /**
   * Check if the current invested breaks our cap rules.
   *
   *
   * The child contract must define their own cap setting rules.
   * We allow a lot of flexibility through different capping strategies (ETH, token count)
   * Called from invest().
   *
   * @param weiAmount The amount of wei the investor tries to invest in the current transaction
   * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction
   * @param weiRaisedTotal What would be our total raised balance after this transaction
   * @param tokensSoldTotal What would be our total sold tokens count after this transaction
   *
   * @return true if taking this investment would break our cap rules
   */
  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);

  function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);

  /**
   * Check if the current crowdsale is full and we can no longer sell any tokens.
   */
  function isCrowdsaleFull() public constant returns (bool);

  /**
   * Create new tokens or transfer issued tokens to the investor depending on the cap model.
   */
  function assignTokens(address receiver, uint tokenAmount) private;
}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */








/**
 * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.
 *
 * Based on code by FirstBlood:
 * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, SafeMath {

  /* Token supply got increased and a new owner received these tokens */
  event Minted(address receiver, uint amount);

  /* Actual balances of token holders */
  mapping(address =&amp;gt; uint) balances;

  /* approve() allowances */
  mapping (address =&amp;gt; mapping (address =&amp;gt; uint)) allowed;

  /* Interface declaration */
  function isToken() public constant returns (bool weAre) {
    return true;
  }

  function transfer(address _to, uint _value) returns (bool success) {
    balances[msg.sender] = safeSub(balances[msg.sender], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
    uint _allowance = allowed[_from][msg.sender];

    balances[_to] = safeAdd(balances[_to], _value);
    balances[_from] = safeSub(balances[_from], _value);
    allowed[_from][msg.sender] = safeSub(_allowance, _value);
    Transfer(_from, _to, _value);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint _value) returns (bool success) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    if ((_value != 0) &amp;amp;&amp;amp; (allowed[msg.sender][_spender] != 0)) throw;

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }

}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */





/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * Upgrade agent interface inspired by Lunyr.
 *
 * Upgrade agent transfers tokens to a new contract.
 * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.
 */
contract UpgradeAgent {

  uint public originalSupply;

  /** Interface marker */
  function isUpgradeAgent() public constant returns (bool) {
    return true;
  }

  function upgradeFrom(address _from, uint256 _value) public;

}


/**
 * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.
 *
 * First envisioned by Golem and Lunyr projects.
 */
contract UpgradeableToken is StandardToken {

  /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */
  address public upgradeMaster;

  /** The next contract where the tokens will be migrated. */
  UpgradeAgent public upgradeAgent;

  /** How many tokens we have upgraded by now. */
  uint256 public totalUpgraded;

  /**
   * Upgrade states.
   *
   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun
   * - WaitingForAgent: Token allows upgrade, but we don&amp;#39;t have a new agent yet
   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet
   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens
   *
   */
  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}

  /**
   * Somebody has upgraded some of his tokens.
   */
  event Upgrade(address indexed _from, address indexed _to, uint256 _value);

  /**
   * New upgrade agent available.
   */
  event UpgradeAgentSet(address agent);

  /**
   * Do not allow construction without upgrade master set.
   */
  function UpgradeableToken(address _upgradeMaster) {
    upgradeMaster = _upgradeMaster;
  }

  /**
   * Allow the token holder to upgrade some of their tokens to a new contract.
   */
  function upgrade(uint256 value) public {

      UpgradeState state = getUpgradeState();
      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {
        // Called in a bad state
        throw;
      }

      // Validate input value.
      if (value == 0) throw;

      balances[msg.sender] = safeSub(balances[msg.sender], value);

      // Take tokens out from circulation
      totalSupply = safeSub(totalSupply, value);
      totalUpgraded = safeAdd(totalUpgraded, value);

      // Upgrade agent reissues the tokens
      upgradeAgent.upgradeFrom(msg.sender, value);
      Upgrade(msg.sender, upgradeAgent, value);
  }

  /**
   * Set an upgrade agent that handles
   */
  function setUpgradeAgent(address agent) external {

      if(!canUpgrade()) {
        // The token is not yet in a state that we could think upgrading
        throw;
      }

      if (agent == 0x0) throw;
      // Only a master can designate the next agent
      if (msg.sender != upgradeMaster) throw;
      // Upgrade has already begun for an agent
      if (getUpgradeState() == UpgradeState.Upgrading) throw;

      upgradeAgent = UpgradeAgent(agent);

      // Bad interface
      if(!upgradeAgent.isUpgradeAgent()) throw;
      // Make sure that token supplies match in source and target
      if (upgradeAgent.originalSupply() != totalSupply) throw;

      UpgradeAgentSet(upgradeAgent);
  }

  /**
   * Get the state of the token upgrade.
   */
  function getUpgradeState() public constant returns(UpgradeState) {
    if(!canUpgrade()) return UpgradeState.NotAllowed;
    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;
    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;
    else return UpgradeState.Upgrading;
  }

  /**
   * Change the upgrade master.
   *
   * This allows us to set a new owner for the upgrade mechanism.
   */
  function setUpgradeMaster(address master) public {
      if (master == 0x0) throw;
      if (msg.sender != upgradeMaster) throw;
      upgradeMaster = master;
  }

  /**
   * Child contract can enable to provide the condition when the upgrade can begun.
   */
  function canUpgrade() public constant returns(bool) {
     return true;
  }

}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */







/**
 * Define interface for releasing the token transfer after a successful crowdsale.
 */
contract ReleasableToken is ERC20, Ownable {

  /* The finalizer contract that allows unlift the transfer limits on this token */
  address public releaseAgent;

  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/
  bool public released = false;

  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */
  mapping (address =&amp;gt; bool) public transferAgents;

  /**
   * Limit token transfer until the crowdsale is over.
   *
   */
  modifier canTransfer(address _sender) {

    if(!released) {
        if(!transferAgents[_sender]) {
            throw;
        }
    }

    _;
  }

  /**
   * Set the contract that can call release and make the token transferable.
   *
   * Design choice. Allow reset the release agent to fix fat finger mistakes.
   */
  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {

    // We don&amp;#39;t do interface check here as we might want to a normal wallet address to act as a release agent
    releaseAgent = addr;
  }

  /**
   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.
   */
  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
    transferAgents[addr] = state;
  }

  /**
   * One way function to release the tokens to the wild.
   *
   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
    released = true;
  }

  /** The function can be called only before or after the tokens have been releasesd */
  modifier inReleaseState(bool releaseState) {
    if(releaseState != released) {
        throw;
    }
    _;
  }

  /** The function can be called only by a whitelisted release agent. */
  modifier onlyReleaseAgent() {
    if(msg.sender != releaseAgent) {
        throw;
    }
    _;
  }

  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {
    // Call StandardToken.transfer()
   return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
    // Call StandardToken.transferForm()
    return super.transferFrom(_from, _to, _value);
  }

}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */








/**
 * A token that can increase its supply by another contract.
 *
 * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.
 * Only mint agents, contracts whitelisted by owner, can mint new tokens.
 *
 */
contract MintableTokenExt is StandardToken, Ownable {

  using SafeMathLibExt for uint;

  bool public mintingFinished = false;

  /** List of agents that are allowed to create new tokens */
  mapping (address =&amp;gt; bool) public mintAgents;

  event MintingAgentChanged(address addr, bool state  );

  /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals.
  * For example, for reserved tokens in percents 2.54%
  * inPercentageUnit = 254
  * inPercentageDecimals = 2
  */
  struct ReservedTokensData {
    uint inTokens;
    uint inPercentageUnit;
    uint inPercentageDecimals;
    bool isReserved;
    bool isDistributed;
  }

  mapping (address =&amp;gt; ReservedTokensData) public reservedTokensList;
  address[] public reservedTokensDestinations;
  uint public reservedTokensDestinationsLen = 0;
  bool reservedTokensDestinationsAreSet = false;

  modifier onlyMintAgent() {
    // Only crowdsale contracts are allowed to mint new tokens
    if(!mintAgents[msg.sender]) {
        throw;
    }
    _;
  }

  /** Make sure we are not done yet. */
  modifier canMint() {
    if(mintingFinished) throw;
    _;
  }

  function finalizeReservedAddress(address addr) public onlyMintAgent canMint {
    ReservedTokensData storage reservedTokensData = reservedTokensList[addr];
    reservedTokensData.isDistributed = true;
  }

  function isAddressReserved(address addr) public constant returns (bool isReserved) {
    return reservedTokensList[addr].isReserved;
  }

  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
    return reservedTokensList[addr].isDistributed;
  }

  function getReservedTokens(address addr) public constant returns (uint inTokens) {
    return reservedTokensList[addr].inTokens;
  }

  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
    return reservedTokensList[addr].inPercentageUnit;
  }

  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
    return reservedTokensList[addr].inPercentageDecimals;
  }

  function setReservedTokensListMultiple(
    address[] addrs, 
    uint[] inTokens, 
    uint[] inPercentageUnit, 
    uint[] inPercentageDecimals
  ) public canMint onlyOwner {
    assert(!reservedTokensDestinationsAreSet);
    assert(addrs.length == inTokens.length);
    assert(inTokens.length == inPercentageUnit.length);
    assert(inPercentageUnit.length == inPercentageDecimals.length);
    for (uint iterator = 0; iterator &amp;lt; addrs.length; iterator++) {
      if (addrs[iterator] != address(0)) {
        setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);
      }
    }
    reservedTokensDestinationsAreSet = true;
  }

  /**
   * Create new tokens and allocate them to an address..
   *
   * Only callably by a crowdsale contract (mint agent).
   */
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
    totalSupply = totalSupply.plus(amount);
    balances[receiver] = balances[receiver].plus(amount);

    // This will make the mint transaction apper in EtherScan.io
    // We can remove this after there is a standardized minting event
    Transfer(0, receiver, amount);
  }

  /**
   * Owner can allow a crowdsale contract to mint new tokens.
   */
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
    mintAgents[addr] = state;
    MintingAgentChanged(addr, state);
  }

  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
    assert(addr != address(0));
    if (!isAddressReserved(addr)) {
      reservedTokensDestinations.push(addr);
      reservedTokensDestinationsLen++;
    }

    reservedTokensList[addr] = ReservedTokensData({
      inTokens: inTokens, 
      inPercentageUnit: inPercentageUnit, 
      inPercentageDecimals: inPercentageDecimals,
      isReserved: true,
      isDistributed: false
    });
  }
}


/**
 * A crowdsaled token.
 *
 * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.
 *
 * - The token transfer() is disabled until the crowdsale is over
 * - The token contract gives an opt-in upgrade path to a new contract
 * - The same token can be part of several crowdsales through approve() mechanism
 * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)
 *
 */
contract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {

  /** Name and symbol were updated. */
  event UpdatedTokenInformation(string newName, string newSymbol);

  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);

  string public name;

  string public symbol;

  uint public decimals;

  /* Minimum ammount of tokens every buyer can buy. */
  uint public minCap;

  /**
   * Construct the token.
   *
   * This token must be created through a team multisig wallet, so that it is owned by that wallet.
   *
   * @param _name Token name
   * @param _symbol Token symbol - should be all caps
   * @param _initialSupply How many tokens we start with
   * @param _decimals Number of decimal places
   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.
   */
  function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)
    UpgradeableToken(msg.sender) {

    // Create any address, can be transferred
    // to team multisig via changeOwner(),
    // also remember to call setUpgradeMaster()
    owner = msg.sender;

    name = _name;
    symbol = _symbol;

    totalSupply = _initialSupply;

    decimals = _decimals;

    minCap = _globalMinCap;

    // Create initially all balance on the team multisig
    balances[owner] = totalSupply;

    if(totalSupply &amp;gt; 0) {
      Minted(owner, totalSupply);
    }

    // No more new supply allowed after the token creation
    if(!_mintable) {
      mintingFinished = true;
      if(totalSupply == 0) {
        throw; // Cannot create a token without supply and no minting
      }
    }
  }

  /**
   * When token is released to be transferable, enforce no new tokens can be created.
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
    mintingFinished = true;
    super.releaseTokenTransfer();
  }

  /**
   * Allow upgrade agent functionality kick in only if the crowdsale was success.
   */
  function canUpgrade() public constant returns(bool) {
    return released &amp;amp;&amp;amp; super.canUpgrade();
  }

  /**
   * Owner can update token information here.
   *
   * It is often useful to conceal the actual token association, until
   * the token operations, like central issuance or reissuance have been completed.
   *
   * This function allows the token owner to rename the token after the operations
   * have been completed and then point the audience to use the token contract.
   */
  function setTokenInformation(string _name, string _symbol) onlyOwner {
    name = _name;
    symbol = _symbol;

    UpdatedTokenInformation(name, symbol);
  }

  /**
   * Claim tokens that were accidentally sent to this contract.
   *
   * @param _token The address of the token contract that you want to recover.
   */
  function claimTokens(address _token) public onlyOwner {
    require(_token != address(0));

    ERC20 token = ERC20(_token);
    uint balance = token.balanceOf(this);
    token.transfer(owner, balance);

    ClaimedTokens(_token, owner, balance);
  }

}


/**
 * The default behavior for the crowdsale end.
 *
 * Unlock tokens.
 */
contract ReservedTokensFinalizeAgent is FinalizeAgent {
  using SafeMathLibExt for uint;
  CrowdsaleTokenExt public token;
  CrowdsaleExt public crowdsale;

  uint public distributedReservedTokensDestinationsLen = 0;

  function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {
    token = _token;
    crowdsale = _crowdsale;
  }

  /** Check that we can release the token */
  function isSane() public constant returns (bool) {
    return (token.releaseAgent() == address(this));
  }

  //distributes reserved tokens. Should be called before finalization
  function distributeReservedTokens(uint reservedTokensDistributionBatch) public {
    assert(msg.sender == address(crowdsale));

    assert(reservedTokensDistributionBatch &amp;gt; 0);
    assert(!reservedTokensAreDistributed);
    assert(distributedReservedTokensDestinationsLen &amp;lt; token.reservedTokensDestinationsLen());


    // How many % of tokens the founders and others get
    uint tokensSold = 0;
    for (uint8 i = 0; i &amp;lt; crowdsale.joinedCrowdsalesLen(); i++) {
      CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));
      tokensSold = tokensSold.plus(tier.tokensSold());
    }

    uint startLooping = distributedReservedTokensDestinationsLen;
    uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);
    if (batch &amp;gt;= reservedTokensDistributionBatch) {
      batch = reservedTokensDistributionBatch;
    }
    uint endLooping = startLooping + batch;

    // move reserved tokens
    for (uint j = startLooping; j &amp;lt; endLooping; j++) {
      address reservedAddr = token.reservedTokensDestinations(j);
      if (!token.areTokensDistributedForAddress(reservedAddr)) {
        uint allocatedBonusInPercentage;
        uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);
        uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);
        uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);

        if (percentsOfTokensUnit &amp;gt; 0) {
          allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;
          token.mint(reservedAddr, allocatedBonusInPercentage);
        }

        if (allocatedBonusInTokens &amp;gt; 0) {
          token.mint(reservedAddr, allocatedBonusInTokens);
        }

        token.finalizeReservedAddress(reservedAddr);
        distributedReservedTokensDestinationsLen++;
      }
    }

    if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {
      reservedTokensAreDistributed = true;
    }
  }

  /** Called once by crowdsale finalize() if the sale was success. */
  function finalizeCrowdsale() public {
    assert(msg.sender == address(crowdsale));

    if (token.reservedTokensDestinationsLen() &amp;gt; 0) {
      assert(reservedTokensAreDistributed);
    }

    token.releaseTokenTransfer();
  }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xeeb80ebafd5288a782d13afe9951852701e3de6c.sol" target="_blank" title="show github file">0xeeb80ebafd5288a782d13afe9951852701e3de6c.sol</a>
        </div>
        <div class="path">solidity-files/0xeeb80ebafd5288a782d13afe9951852701e3de6c.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity 0.4.16;

interface tokenRecipient { 
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; 
}

contract TokenERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 8;
    uint256 public totalSupply;
    mapping (address =&amp;gt; uint256) public balanceOf;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) public allowance;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);
    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
    }
    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] &amp;gt;= _value);
        require(balanceOf[_to] + _value &amp;gt; balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {        
        require(_value &amp;lt;= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);        
        return true;
    }
    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;        
        return true;
    }
    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);        
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);            
            return true;
        }
    }
    
    function burn(uint256 _value) public returns (bool success) {        
        require(balanceOf[msg.sender] &amp;gt;= _value);
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        Burn(msg.sender, _value);        
        return true;
    }
    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {        
        require(balanceOf[_from] &amp;gt;= _value);
        require(_value &amp;lt;= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        Burn(_from, _value);        
        return true;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x87dc86E1Fde430c226c881AE6E9108afB43EEb47.sol" target="_blank" title="show github file">0x87dc86E1Fde430c226c881AE6E9108afB43EEb47.sol</a>
        </div>
        <div class="path">solidity-files/0x87dc86E1Fde430c226c881AE6E9108afB43EEb47.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network 
pragma solidity ^0.4.11;


/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */




/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * Interface for defining crowdsale pricing.
 */
contract PricingStrategy {

  address public tier;

  /** Interface declaration. */
  function isPricingStrategy() public constant returns (bool) {
    return true;
  }

  /** Self check if all references are correctly set.
   *
   * Checks that pricing strategy matches crowdsale parameters.
   */
  function isSane(address crowdsale) public constant returns (bool) {
    return true;
  }

  /**
   * @dev Pricing tells if this is a presale purchase or not.
     @param purchaser Address of the purchaser
     @return False by default, true if a presale purchaser
   */
  function isPresalePurchase(address purchaser) public constant returns (bool) {
    return false;
  }

  /* How many weis one token costs */
  function updateRate(uint newOneTokenInWei) public;

  /**
   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.
   *
   *
   * @param value - What is the value of the transaction send in as wei
   * @param tokensSold - how much tokens have been sold this far
   * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale
   * @param msgSender - who is the investor of this transaction
   * @param decimals - how many decimal units the token has
   * @return Amount of tokens the investor receives
   */
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);
}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * Safe unsigned safe math.
 *
 * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli
 *
 * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol
 *
 * Maintained here until merged to mainline zeppelin-solidity.
 *
 */
library SafeMathLibExt {

  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
    assert(b &amp;gt; 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c&amp;gt;=a);
    return c;
  }

}



/**
 * Fixed crowdsale pricing - everybody gets the same price.
 */
contract FlatPricingExt is PricingStrategy, Ownable {
  using SafeMathLibExt for uint;

  /* How many weis one token costs */
  uint public oneTokenInWei;

  // Crowdsale rate has been changed
  event RateChanged(uint newOneTokenInWei);

  modifier onlyTier() {
    if (msg.sender != address(tier)) throw;
    _;
  }

  function setTier(address _tier) onlyOwner {
    assert(_tier != address(0));
    assert(tier == address(0));
    tier = _tier;
  }

  function FlatPricingExt(uint _oneTokenInWei) onlyOwner {
    require(_oneTokenInWei &amp;gt; 0);
    oneTokenInWei = _oneTokenInWei;
  }

  function updateRate(uint newOneTokenInWei) onlyTier {
    oneTokenInWei = newOneTokenInWei;
    RateChanged(newOneTokenInWei);
  }

  /**
   * Calculate the current price for buy in amount.
   *
   */
  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) {
    uint multiplier = 10 ** decimals;
    return value.times(multiplier) / oneTokenInWei;
  }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x1a9d7ee82cc595d2ea6dc877fc5b3bd8462887b0.sol" target="_blank" title="show github file">0x1a9d7ee82cc595d2ea6dc877fc5b3bd8462887b0.sol</a>
        </div>
        <div class="path">solidity-files/0x1a9d7ee82cc595d2ea6dc877fc5b3bd8462887b0.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;Mobilla&amp;#39; token contract
//
// Deployed to : 0xdb4ff87f187cd2560cfaae170a05d2024194df02
// Symbol      : MBB
// Name        : Mobilla
// Total supply: 100000000000000000000
// Decimals    : 18
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract Mobilla is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function FucksToken() public {
        symbol = &amp;quot;MBB&amp;quot;;
        name = &amp;quot;Mobilla&amp;quot;;
        decimals = 18;
        _totalSupply = 100000000000000000000000000;
        balances[0xdb4ff87f187cd2560cfaae170a05d2024194df02] = _totalSupply;
        Transfer(address(0), 0xdb4ff87f187cd2560cfaae170a05d2024194df02, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x48da908f5727f467308f06210b615c2b3a58d627.sol" target="_blank" title="show github file">0x48da908f5727f467308f06210b615c2b3a58d627.sol</a>
        </div>
        <div class="path">solidity-files/0x48da908f5727f467308f06210b615c2b3a58d627.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.13;


contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

contract DIVC is ERC20,Ownable{
	using SafeMath for uint256;

	string public constant name=&amp;quot;dividend chain&amp;quot;;
	string public symbol=&amp;quot;DIVC&amp;quot;;
	string public constant version = &amp;quot;1.0&amp;quot;;
	uint256 public constant decimals = 18;
	uint256 public totalSupply;

	uint256 public constant MAX_SUPPLY=1300000000*10**decimals;

	
    mapping(address =&amp;gt; uint256) balances;
	mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;
	event GetETH(address indexed _from, uint256 _value);

	function DIVC(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}

	function () payable external
	{
		GetETH(msg.sender,msg.value);
	}

	function etherProceeds() external
		onlyOwner
	{
		if(!msg.sender.send(this.balance)) revert();
	}

  	function transfer(address _to, uint256 _value) public  returns (bool)
 	{
		require(_to != address(0));
		// SafeMath.sub will throw if there is not enough balance.
		balances[msg.sender] = balances[msg.sender].sub(_value);
		balances[_to] = balances[_to].add(_value);
		Transfer(msg.sender, _to, _value);
		return true;
  	}

  	function balanceOf(address _owner) public constant returns (uint256 balance) 
  	{
		return balances[_owner];
  	}

  	function transferFrom(address _from, address _to, uint256 _value) public returns (bool) 
  	{
		require(_to != address(0));
		uint256 _allowance = allowed[_from][msg.sender];

		balances[_from] = balances[_from].sub(_value);
		balances[_to] = balances[_to].add(_value);
		allowed[_from][msg.sender] = _allowance.sub(_value);
		Transfer(_from, _to, _value);
		return true;
  	}

  	function approve(address _spender, uint256 _value) public returns (bool) 
  	{
		allowed[msg.sender][_spender] = _value;
		Approval(msg.sender, _spender, _value);
		return true;
  	}

  	function allowance(address _owner, address _spender) public constant returns (uint256 remaining) 
  	{
		return allowed[_owner][_spender];
  	}

	  
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x2fe7408cef927cc48878bb05fd23879a9427cd0b.sol" target="_blank" title="show github file">0x2fe7408cef927cc48878bb05fd23879a9427cd0b.sol</a>
        </div>
        <div class="path">solidity-files/0x2fe7408cef927cc48878bb05fd23879a9427cd0b.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

// Turn the usage of callcode
contract SafeMath {
    function safeMul(uint a, uint b) internal returns (uint) {
        uint c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function safeSub(uint a, uint b) internal returns (uint) {
        assert(b &amp;lt;= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) internal returns (uint) {
        uint c = a + b;
        assert(c&amp;gt;=a &amp;amp;&amp;amp; c&amp;gt;=b);
        return c;
    }
}

contract CreatorEnabled {
    address public creator = 0x0;

    modifier onlyCreator() { require(msg.sender==creator); _; }

    function changeCreator(address _to) public onlyCreator {
        creator = _to;
    }
}

// ERC20 standard
contract StdToken is SafeMath {

    mapping(address =&amp;gt; uint256) public balances;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;
    uint public totalSupply = 0;


    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);


    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns(bool) {
      require(0x0!=_to);

      balances[msg.sender] = safeSub(balances[msg.sender],_value);
      balances[_to] = safeAdd(balances[_to],_value);

      Transfer(msg.sender, _to, _value);
      return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns(bool) {
      require(0x0!=_to);

      balances[_to] = safeAdd(balances[_to],_value);
      balances[_from] = safeSub(balances[_from],_value);
      allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);

      Transfer(_from, _to, _value);
      return true;
    }

    function balanceOf(address _owner) constant returns (uint256) {
      return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool) {
      // To change the approve amount you first have to reduce the addresses`
      //  allowance to zero by calling `approve(_spender, 0)` if it is not
      //  already 0 to mitigate the race condition described here:
      //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
      require((_value == 0) || (allowed[msg.sender][_spender] == 0));

      allowed[msg.sender][_spender] = _value;
      Approval(msg.sender, _spender, _value);
      return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256) {
      return allowed[_owner][_spender];
    }

    modifier onlyPayloadSize(uint _size) {
      require(msg.data.length &amp;gt;= _size + 4);
      _;
    }
}

contract IGoldFee {
    function calculateFee(address _sender, bool _isMigrationStarted, bool _isMigrationFinished, uint _mntpBalance, uint _value) public constant returns(uint);
}

contract GoldFee is CreatorEnabled {

    mapping(address =&amp;gt; bool) exceptAddresses;

    function GoldFee() {
        creator = msg.sender;
    }

    function getMin(uint out)returns (uint) {
        // 0.002 GOLD is min fee
        uint minFee = (2 * 1 ether) / 1000;
        if (out &amp;lt; minFee) {
             return minFee;
        }
        return out;
    }

    function getMax(uint out)returns (uint) {
        // 0.02 GOLD is max fee
        uint maxFee = (2 * 1 ether) / 100;
        if (out &amp;gt;= maxFee) {
             return maxFee;
        }
        return out;
    }

    function calculateFee(address _sender, bool _isMigrationStarted, bool _isMigrationFinished, uint _mntpBalance, uint _value) public constant returns(uint)
    {
       //if this is an excaptional address
       if (exceptAddresses[_sender]) {
            return 0;
       }

        // When migration process is finished (1 year from Goldmint blockchain launch), then transaction fee is 1% GOLD.
        if (_isMigrationFinished) {
             return (_value / 100);
        }

        // If the sender holds 0 MNTP, then the transaction fee is 1% GOLD.

        // If the sender holds at least 10 MNTP, then the transaction fee is 0.333333% GOLD,
        // but not less than 0.002 MNTP

        // If the sender holds at least 1000 MNTP, then the transaction fee is 0.033333% GOLD,
        // but not less than 0.002 MNTP

        // If the sender holds at least 10000 MNTP, then the transaction fee is 0.0333333% GOLD,
        // but not more than 0.02 MNTP
        if (_mntpBalance &amp;gt;= (10000 * 1 ether)) {
             return getMax((_value / 100) / 30);
        }
        if (_mntpBalance &amp;gt;= (1000 * 1 ether)) {
             return getMin((_value / 100) / 30);
        }
        if (_mntpBalance &amp;gt;= (10 * 1 ether)) {
             return getMin((_value / 100) / 3);
        }

        // 1%
        return getMin(_value / 100);
    }

    function addExceptAddress(address _address) public onlyCreator {
        exceptAddresses[_address] = true;
    }

    function removeExceptAddress(address _address) public onlyCreator {
        exceptAddresses[_address] = false;
    }

    function isAddressExcept(address _address) public constant returns(bool) {
        return exceptAddresses[_address];
    }
}

contract Gold is StdToken, CreatorEnabled {

    string public constant name = &amp;quot;GoldMint GOLD cryptoasset&amp;quot;;
    string public constant symbol = &amp;quot;GOLD&amp;quot;;
    uint8 public constant decimals = 18;

    // this is used to send fees (that is then distributed as rewards)
    address public migrationAddress = 0x0;
    address public storageControllerAddress = 0x0;

    address public goldmintTeamAddress = 0x0;
    IMNTP public mntpToken;
    IGoldFee public goldFee;


    bool public transfersLocked = false;
    bool public contractLocked = false;
    bool public migrationStarted = false;
    bool public migrationFinished = false;

    uint public totalIssued = 0;
    uint public totalBurnt = 0;

    // Modifiers:
    modifier onlyMigration() { require(msg.sender == migrationAddress); _; }
    modifier onlyMigrationOrStorageController() { require(msg.sender == migrationAddress || msg.sender == storageControllerAddress); _; }
    modifier onlyCreatorOrStorageController() { require(msg.sender == creator || msg.sender == storageControllerAddress); _; }
    modifier onlyIfUnlocked() { require(!transfersLocked); _; }

    // Functions:
    function Gold(address _mntpContractAddress, address _goldmintTeamAddress, address _goldFeeAddress) public {
        creator = msg.sender;

        mntpToken = IMNTP(_mntpContractAddress);
        goldmintTeamAddress = _goldmintTeamAddress;
        goldFee = IGoldFee(_goldFeeAddress);
    }

    function setCreator(address _address) public onlyCreator {
       creator = _address;
    }

    function lockContract(bool _contractLocked) public onlyCreator {
       contractLocked = _contractLocked;
    }

    function setStorageControllerContractAddress(address _address) public onlyCreator {
        storageControllerAddress = _address;
    }

    function setMigrationContractAddress(address _migrationAddress) public onlyCreator {
        migrationAddress = _migrationAddress;
    }

    function setGoldmintTeamAddress(address _teamAddress) public onlyCreator {
        goldmintTeamAddress = _teamAddress;
    }

    function setGoldFeeAddress(address _goldFeeAddress) public onlyCreator {
        goldFee = IGoldFee(_goldFeeAddress);
    }

    function issueTokens(address _who, uint _tokens) public onlyCreatorOrStorageController {
        require(!contractLocked);

        balances[_who] = safeAdd(balances[_who],_tokens);
        totalSupply = safeAdd(totalSupply,_tokens);
        totalIssued = safeAdd(totalIssued,_tokens);

        Transfer(0x0, _who, _tokens);
    }

    function burnTokens(address _who, uint _tokens) public onlyMigrationOrStorageController {
        require(!contractLocked);
        balances[_who] = safeSub(balances[_who],_tokens);
        totalSupply = safeSub(totalSupply,_tokens);
        totalBurnt = safeAdd(totalBurnt,_tokens);
    }

    // there is no way to revert that
    function startMigration() public onlyMigration {
        require(false == migrationStarted);
        migrationStarted = true;
    }

    // there is no way to revert that
    function finishMigration() public onlyMigration {
        require(true == migrationStarted);

        migrationFinished = true;
    }

    function lockTransfer(bool _lock) public onlyMigration {
        transfersLocked = _lock;
    }

    function transfer(address _to, uint256 _value) public onlyIfUnlocked onlyPayloadSize(2 * 32) returns(bool) {

        uint yourCurrentMntpBalance = mntpToken.balanceOf(msg.sender);

        // you can transfer if fee is ZERO
        uint fee = goldFee.calculateFee(msg.sender, migrationStarted, migrationFinished, yourCurrentMntpBalance, _value);
        uint sendThis = _value;
        if (0 != fee) {
             sendThis = safeSub(_value,fee);

             // 1.Transfer fee
             // A -&amp;gt; rewards account
             //
             // Each GOLD token transfer should send transaction fee to
             // GoldmintMigration contract if Migration process is not started.
             // Goldmint team if Migration process is started.
             if (migrationStarted) {
                  super.transfer(goldmintTeamAddress, fee);
             } else {
                  super.transfer(migrationAddress, fee);
             }
        }

        // 2.Transfer
        // A -&amp;gt; B
        return super.transfer(_to, sendThis);
    }

    function transferFrom(address _from, address _to, uint256 _value) public onlyIfUnlocked returns(bool) {

        uint yourCurrentMntpBalance = mntpToken.balanceOf(_from);

        uint fee = goldFee.calculateFee(msg.sender, migrationStarted, migrationFinished, yourCurrentMntpBalance, _value);
        if (0 != fee) {
             // 1.Transfer fee
             // A -&amp;gt; rewards account
             //
             // Each GOLD token transfer should send transaction fee to
             // GoldmintMigration contract if Migration process is not started.
             // Goldmint team if Migration process is started.
             if (migrationStarted) {
                  super.transferFrom(_from, goldmintTeamAddress, fee);
             } else {
                  super.transferFrom(_from, migrationAddress, fee);
             }
        }

        // 2.Transfer
        // A -&amp;gt; B
        uint sendThis = safeSub(_value,fee);
        return super.transferFrom(_from, _to, sendThis);
    }

    // Used to send rewards)
    function transferRewardWithoutFee(address _to, uint _value) public onlyMigration onlyPayloadSize(2*32) {
        require(0x0!=_to);

        balances[migrationAddress] = safeSub(balances[migrationAddress],_value);
        balances[_to] = safeAdd(balances[_to],_value);

        Transfer(migrationAddress, _to, _value);
    }

    // This is an emergency function that can be called by Creator only
    function rescueAllRewards(address _to) public onlyCreator {
        require(0x0!=_to);

        uint totalReward = balances[migrationAddress];

        balances[_to] = safeAdd(balances[_to],totalReward);
        balances[migrationAddress] = 0;

        Transfer(migrationAddress, _to, totalReward);
    }


    function getTotalIssued() public constant returns (uint) {
        return totalIssued;
    }

    function getTotalBurnt() public constant returns (uint) {
        return totalBurnt;
    }
}

contract IMNTP is StdToken {
    // Additional methods that MNTP contract provides
    function lockTransfer(bool _lock);
    function issueTokens(address _who, uint _tokens);
    function burnTokens(address _who, uint _tokens);
}

contract GoldmintMigration is CreatorEnabled {
    // Fields:
    IMNTP public mntpToken;
    Gold public goldToken;

    enum State {
        Init,
        MigrationStarted,
        MigrationPaused,
        MigrationFinished
    }

    State public state = State.Init;

    // this is total collected GOLD rewards (launch to migration start)
    uint public mntpToMigrateTotal = 0;
    uint public migrationRewardTotal = 0;
    uint64 public migrationStartedTime = 0;
    uint64 public migrationFinishedTime = 0;

    struct Migration {
        address ethAddress;
        string gmAddress;
        uint tokensCount;
        bool migrated;
        uint64 date;
        string comment;
    }

    mapping (uint=&amp;gt;Migration) public mntpMigrations;
    mapping (address=&amp;gt;uint) public mntpMigrationIndexes;
    uint public mntpMigrationsCount = 0;

    mapping (uint=&amp;gt;Migration) public goldMigrations;
    mapping (address=&amp;gt;uint) public goldMigrationIndexes;
    uint public goldMigrationsCount = 0;

    event MntpMigrateWanted(address _ethAddress, string _gmAddress, uint256 _value);
    event MntpMigrated(address _ethAddress, string _gmAddress, uint256 _value);

    event GoldMigrateWanted(address _ethAddress, string _gmAddress, uint256 _value);
    event GoldMigrated(address _ethAddress, string _gmAddress, uint256 _value);

    // Access methods
    function getMntpMigration(uint index) public constant returns(address,string,uint,bool,uint64,string){
        Migration memory mig = mntpMigrations[index];
        return (mig.ethAddress, mig.gmAddress, mig.tokensCount, mig.migrated, mig.date, mig.comment);
    }

    function getGoldMigration(uint index) public constant returns(address,string,uint,bool,uint64,string){
        Migration memory mig = goldMigrations[index];
        return (mig.ethAddress, mig.gmAddress, mig.tokensCount, mig.migrated, mig.date, mig.comment);
    }

    // Functions:
    // Constructor
    function GoldmintMigration(address _mntpContractAddress, address _goldContractAddress) public {
        creator = msg.sender;

        require(_mntpContractAddress != 0);
        require(_goldContractAddress != 0);

        mntpMigrationIndexes[address(0x0)] = 0;
        goldMigrationIndexes[address(0x0)] = 0;

        mntpToken = IMNTP(_mntpContractAddress);
        goldToken = Gold(_goldContractAddress);
    }

    function lockMntpTransfers(bool _lock) public onlyCreator {
        mntpToken.lockTransfer(_lock);
    }

    function lockGoldTransfers(bool _lock) public onlyCreator {
        goldToken.lockTransfer(_lock);
    }

    // This method is called when migration to Goldmint&amp;#39;s blockchain
    // process is started...
    function startMigration() public onlyCreator {
        require((State.Init == state) || (State.MigrationPaused == state));

        if (State.Init == state) {
             // 1 - change fees
             goldToken.startMigration();

             // 2 - store the current values
             migrationRewardTotal = goldToken.balanceOf(this);
             migrationStartedTime = uint64(now);
             mntpToMigrateTotal = mntpToken.totalSupply();
        }

        state = State.MigrationStarted;
    }

    function pauseMigration() public onlyCreator {
        require((state == State.MigrationStarted) || (state == State.MigrationFinished));

        state = State.MigrationPaused;
    }

    // that doesn&amp;#39;t mean that you cant migrate from Ethereum -&amp;gt; Goldmint blockchain
    // that means that you will get no reward
    function finishMigration() public onlyCreator {
        require((State.MigrationStarted == state) || (State.MigrationPaused == state));

        if (State.MigrationStarted == state) {
             goldToken.finishMigration();
             migrationFinishedTime = uint64(now);
        }

        state = State.MigrationFinished;
    }

    function destroyMe() public onlyCreator {
        selfdestruct(msg.sender);
    }

    // MNTP
    // Call this to migrate your MNTP tokens to Goldmint MNT
    // (this is one-way only)
    // _gmAddress is something like that - &amp;quot;BTS7yRXCkBjKxho57RCbqYE3nEiprWXXESw3Hxs5CKRnft8x7mdGi&amp;quot;
    //
    // !!! WARNING: will not allow anyone to migrate tokens partly
    // !!! DISCLAIMER: check goldmint blockchain address format. You will not be able to change that!
    function migrateMntp(string _gmAddress) public {
        require((state==State.MigrationStarted) || (state==State.MigrationFinished));

        // 1 - calculate current reward
        uint myBalance = mntpToken.balanceOf(msg.sender);
        require(0!=myBalance);

        uint myRewardMax = calculateMyRewardMax(msg.sender);
        uint myReward = calculateMyReward(myRewardMax);

        // 2 - pay the reward to our user
        goldToken.transferRewardWithoutFee(msg.sender, myReward);

        // 3 - burn tokens
        // WARNING: burn will reduce totalSupply
        //
        // WARNING: creator must call
        // setIcoContractAddress(migrationContractAddress)
        // of the mntpToken
        mntpToken.burnTokens(msg.sender,myBalance);

        // save tuple
        Migration memory mig;
        mig.ethAddress = msg.sender;
        mig.gmAddress = _gmAddress;
        mig.tokensCount = myBalance;
        mig.migrated = false;
        mig.date = uint64(now);
        mig.comment = &amp;#39;&amp;#39;;

        mntpMigrations[mntpMigrationsCount + 1] = mig;
        mntpMigrationIndexes[msg.sender] = mntpMigrationsCount + 1;
        mntpMigrationsCount++;

        // send an event
        MntpMigrateWanted(msg.sender, _gmAddress, myBalance);
    }

    function isMntpMigrated(address _who) public constant returns(bool) {
        uint index = mntpMigrationIndexes[_who];

        Migration memory mig = mntpMigrations[index];
        return mig.migrated;
    }

    function setMntpMigrated(address _who, bool _isMigrated, string _comment) public onlyCreator {
        uint index = mntpMigrationIndexes[_who];
        require(index &amp;gt; 0);

        mntpMigrations[index].migrated = _isMigrated;
        mntpMigrations[index].comment = _comment;

        // send an event
        if (_isMigrated) {
             MntpMigrated(  mntpMigrations[index].ethAddress,
                            mntpMigrations[index].gmAddress,
                            mntpMigrations[index].tokensCount);
        }
    }

    // GOLD
    function migrateGold(string _gmAddress) public {
        require((state==State.MigrationStarted) || (state==State.MigrationFinished));

        // 1 - get balance
        uint myBalance = goldToken.balanceOf(msg.sender);
        require(0!=myBalance);

        // 2 - burn tokens
        // WARNING: burn will reduce totalSupply
        //
        goldToken.burnTokens(msg.sender,myBalance);

        // save tuple
        Migration memory mig;
        mig.ethAddress = msg.sender;
        mig.gmAddress = _gmAddress;
        mig.tokensCount = myBalance;
        mig.migrated = false;
        mig.date = uint64(now);
        mig.comment = &amp;#39;&amp;#39;;

        goldMigrations[goldMigrationsCount + 1] = mig;
        goldMigrationIndexes[msg.sender] = goldMigrationsCount + 1;
        goldMigrationsCount++;

        // send an event
        GoldMigrateWanted(msg.sender, _gmAddress, myBalance);
    }

    function isGoldMigrated(address _who) public constant returns(bool) {
        uint index = goldMigrationIndexes[_who];

        Migration memory mig = goldMigrations[index];
        return mig.migrated;
    }

    function setGoldMigrated(address _who, bool _isMigrated, string _comment) public onlyCreator {
        uint index = goldMigrationIndexes[_who];
        require(index &amp;gt; 0);

        goldMigrations[index].migrated = _isMigrated;
        goldMigrations[index].comment = _comment;

        // send an event
        if (_isMigrated) {
             GoldMigrated(  goldMigrations[index].ethAddress,
                            goldMigrations[index].gmAddress,
                            goldMigrations[index].tokensCount);
        }
    }

    // Each MNTP token holder gets a GOLD reward as a percent of all rewards
    // proportional to his MNTP token stake
    function calculateMyRewardMax(address _of) public constant returns(uint){
        if (0 == mntpToMigrateTotal) {
             return 0;
        }

        uint myCurrentMntpBalance = mntpToken.balanceOf(_of);
        if (0 == myCurrentMntpBalance) {
             return 0;
        }

        return (migrationRewardTotal * myCurrentMntpBalance) / mntpToMigrateTotal;
    }

    //emergency function. used in case of a mistake to transfer all the reward to a new migraiton smart contract.
    function transferReward(address _newContractAddress) public onlyCreator {
      goldToken.transferRewardWithoutFee(_newContractAddress, goldToken.balanceOf(this));
    }

    // Migration rewards decreased linearly.
    //
    // The formula is: rewardPercents = max(100 - 100 * day / 365, 0)
    //
    // On 1st day of migration, you will get: 100 - 100 * 0/365 = 100% of your rewards
    // On 2nd day of migration, you will get: 100 - 100 * 1/365 = 99.7261% of your rewards
    // On 365th day of migration, you will get: 100 - 100 * 364/365 = 0.274%
    function calculateMyRewardDecreased(uint _day, uint _myRewardMax) public constant returns(uint){
        if (_day &amp;gt;= 365) {
             return 0;
        }

        uint x = ((100 * 1000000000 * _day) / 365);
        return (_myRewardMax * ((100 * 1000000000) - x)) / (100 * 1000000000);
    }

    function calculateMyReward(uint _myRewardMax) public constant returns(uint){
        // day starts from 0
        uint day = (uint64(now) - migrationStartedTime) / uint64(1 days);
        return calculateMyRewardDecreased(day, _myRewardMax);
    }

    // do not allow to send money to this contract...
    function() external payable {
        revert();
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x331c97189a8b25c8acabf0af2382cdd8eae4d88a.sol" target="_blank" title="show github file">0x331c97189a8b25c8acabf0af2382cdd8eae4d88a.sol</a>
        </div>
        <div class="path">solidity-files/0x331c97189a8b25c8acabf0af2382cdd8eae4d88a.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">// Copyright (C) 2017 DappHub, LLC

pragma solidity ^0.4.11;


contract ERC20 {
    function totalSupply() constant returns (uint supply);
    function balanceOf( address who ) constant returns (uint value);
    function allowance( address owner, address spender ) constant returns (uint _allowance);

    function transfer( address to, uint value) returns (bool ok);
    function transferFrom( address from, address to, uint value) returns (bool ok);
    function approve( address spender, uint value ) returns (bool ok);

    event Transfer( address indexed from, address indexed to, uint value);
    event Approval( address indexed owner, address indexed spender, uint value);
}

contract DSMath {
    
    /*
    standard uint256 functions
     */

    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {
        assert((z = x + y) &amp;gt;= x);
    }

    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {
        assert((z = x - y) &amp;lt;= x);
    }

    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {
        z = x * y;
        assert(x == 0 || z / x == y);
    }

    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {
        z = x / y;
    }

    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {
        return x &amp;lt;= y ? x : y;
    }
    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {
        return x &amp;gt;= y ? x : y;
    }

    /*
    uint128 functions (h is for half)
     */


    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {
        assert((z = x + y) &amp;gt;= x);
    }

    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {
        assert((z = x - y) &amp;lt;= x);
    }

    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = x * y;
        assert(x == 0 || z / x == y);
    }

    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = x / y;
    }

    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {
        return x &amp;lt;= y ? x : y;
    }
    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {
        return x &amp;gt;= y ? x : y;
    }


    /*
    int256 functions
     */

    function imin(int256 x, int256 y) constant internal returns (int256 z) {
        return x &amp;lt;= y ? x : y;
    }
    function imax(int256 x, int256 y) constant internal returns (int256 z) {
        return x &amp;gt;= y ? x : y;
    }

    /*
    WAD math
     */

    uint128 constant WAD = 10 ** 18;

    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {
        return hadd(x, y);
    }

    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {
        return hsub(x, y);
    }

    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = cast((uint256(x) * y + WAD / 2) / WAD);
    }

    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = cast((uint256(x) * WAD + y / 2) / y);
    }

    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {
        return hmin(x, y);
    }
    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {
        return hmax(x, y);
    }

    /*
    RAY math
     */

    uint128 constant RAY = 10 ** 27;

    function radd(uint128 x, uint128 y) constant internal returns (uint128) {
        return hadd(x, y);
    }

    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {
        return hsub(x, y);
    }

    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = cast((uint256(x) * y + RAY / 2) / RAY);
    }

    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {
        z = cast((uint256(x) * RAY + y / 2) / y);
    }

    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {
        // This famous algorithm is called &amp;quot;exponentiation by squaring&amp;quot;
        // and calculates x^n with x as fixed-point and n as regular unsigned.
        //
        // It&amp;#39;s O(log n), instead of O(n) for naive repeated multiplication.
        //
        // These facts are why it works:
        //
        //  If n is even, then x^n = (x^2)^(n/2).
        //  If n is odd,  then x^n = x * x^(n-1),
        //   and applying the equation for even x gives
        //    x^n = x * (x^2)^((n-1) / 2).
        //
        //  Also, EVM division is flooring and
        //    floor[(n-1) / 2] = floor[n / 2].

        z = n % 2 != 0 ? x : RAY;

        for (n /= 2; n != 0; n /= 2) {
            x = rmul(x, x);

            if (n % 2 != 0) {
                z = rmul(z, x);
            }
        }
    }

    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {
        return hmin(x, y);
    }
    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {
        return hmax(x, y);
    }

    function cast(uint256 x) constant internal returns (uint128 z) {
        assert((z = uint128(x)) == x);
    }

}

contract DSTokenBase is ERC20, DSMath {
    uint256                                            _supply;
    mapping (address =&amp;gt; uint256)                       _balances;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256))  _approvals;
    
    function DSTokenBase(uint256 supply) {
        _balances[msg.sender] = supply;
        _supply = supply;
    }
    
    function totalSupply() constant returns (uint256) {
        return _supply;
    }
    function balanceOf(address src) constant returns (uint256) {
        return _balances[src];
    }
    function allowance(address src, address guy) constant returns (uint256) {
        return _approvals[src][guy];
    }
    
    function transfer(address dst, uint wad) returns (bool) {
        assert(_balances[msg.sender] &amp;gt;= wad);
        
        _balances[msg.sender] = sub(_balances[msg.sender], wad);
        _balances[dst] = add(_balances[dst], wad);
        
        Transfer(msg.sender, dst, wad);
        
        return true;
    }
    
    function transferFrom(address src, address dst, uint wad) returns (bool) {
        assert(_balances[src] &amp;gt;= wad);
        assert(_approvals[src][msg.sender] &amp;gt;= wad);
        
        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);
        _balances[src] = sub(_balances[src], wad);
        _balances[dst] = add(_balances[dst], wad);
        
        Transfer(src, dst, wad);
        
        return true;
    }
    
    function approve(address guy, uint256 wad) returns (bool) {
        _approvals[msg.sender][guy] = wad;
        
        Approval(msg.sender, guy, wad);
        
        return true;
    }

}

contract DSAuthority {
    function canCall(
        address src, address dst, bytes4 sig
    ) constant returns (bool);
}

contract DSAuthEvents {
    event LogSetAuthority (address indexed authority);
    event LogSetOwner     (address indexed owner);
}

contract DSAuth is DSAuthEvents {
    DSAuthority  public  authority;
    address      public  owner;

    function DSAuth() {
        owner = msg.sender;
        LogSetOwner(msg.sender);
    }

    function setOwner(address owner_)
        auth
    {
        owner = owner_;
        LogSetOwner(owner);
    }

    function setAuthority(DSAuthority authority_)
        auth
    {
        authority = authority_;
        LogSetAuthority(authority);
    }

    modifier auth {
        assert(isAuthorized(msg.sender, msg.sig));
        _;
    }

    function isAuthorized(address src, bytes4 sig) internal returns (bool) {
        if (src == address(this)) {
            return true;
        } else if (src == owner) {
            return true;
        } else if (authority == DSAuthority(0)) {
            return false;
        } else {
            return authority.canCall(src, this, sig);
        }
    }
}

contract DSNote {
    event LogNote(
        bytes4   indexed  sig,
        address  indexed  guy,
        bytes32  indexed  foo,
        bytes32  indexed  bar,
        uint              wad,
        bytes             fax
    ) anonymous;

    modifier note {
        bytes32 foo;
        bytes32 bar;

        assembly {
            foo := calldataload(4)
            bar := calldataload(36)
        }

        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);

        _;
    }
}

contract DSStop is DSNote, DSAuth {

    bool public stopped;

    modifier stoppable {
        assert (!stopped);
        _;
    }
    function stop() auth note {
        stopped = true;
    }
    function start() auth note {
        stopped = false;
    }

}

contract DSToken is DSTokenBase(0), DSStop {

    bytes32  public  symbol;
    uint256  public  decimals = 18; // standard token precision. override to customize

    function DSToken(bytes32 symbol_) {
        symbol = symbol_;
    }

    function transfer(address dst, uint wad) stoppable note returns (bool) {
        return super.transfer(dst, wad);
    }
    function transferFrom(
        address src, address dst, uint wad
    ) stoppable note returns (bool) {
        return super.transferFrom(src, dst, wad);
    }
    function approve(address guy, uint wad) stoppable note returns (bool) {
        return super.approve(guy, wad);
    }

    function push(address dst, uint128 wad) returns (bool) {
        return transfer(dst, wad);
    }
    function pull(address src, uint128 wad) returns (bool) {
        return transferFrom(src, msg.sender, wad);
    }

    function mint(uint128 wad) auth stoppable note {
        _balances[msg.sender] = add(_balances[msg.sender], wad);
        _supply = add(_supply, wad);
    }
    function burn(uint128 wad) auth stoppable note {
        _balances[msg.sender] = sub(_balances[msg.sender], wad);
        _supply = sub(_supply, wad);
    }

    // Optional token name

    bytes32   public  name = &amp;quot;&amp;quot;;
    
    function setName(bytes32 name_) auth {
        name = name_;
    }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x486e70cbeaa30343aca50c06c49878943d106224.sol" target="_blank" title="show github file">0x486e70cbeaa30343aca50c06c49878943d106224.sol</a>
        </div>
        <div class="path">solidity-files/0x486e70cbeaa30343aca50c06c49878943d106224.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;Token Bank&amp;#39; token contract
//
// Deployed to : 0x6C3E2DcD5EDE4037d8EA404081385ff788c0C7B7
// Symbol      : TKB
// Name        : Token Bank
// Total supply: 1000000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract TokenBank is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function TokenBank() public {
        symbol = &amp;quot;TKB&amp;quot;;
        name = &amp;quot;Token Bank&amp;quot;;
        decimals = 8;
        _totalSupply = 100000000000000000;
        balances[0x6C3E2DcD5EDE4037d8EA404081385ff788c0C7B7] = _totalSupply;
        Transfer(address(0), 0x6C3E2DcD5EDE4037d8EA404081385ff788c0C7B7, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xa26c6abdc412039d8f76c9d88bbc8f898b8fbb81.sol" target="_blank" title="show github file">0xa26c6abdc412039d8f76c9d88bbc8f898b8fbb81.sol</a>
        </div>
        <div class="path">solidity-files/0xa26c6abdc412039d8f76c9d88bbc8f898b8fbb81.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.13;


contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

contract XTYF is ERC20,Ownable{
	using SafeMath for uint256;

	string public constant name=&amp;quot;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;f3919696b3909c9a9d&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;quot;;
	string public symbol=&amp;quot;XTYF&amp;quot;;
	string public constant version = &amp;quot;1.0&amp;quot;;
	uint256 public constant decimals = 18;
	uint256 public totalSupply;

	uint256 public constant MAX_SUPPLY=50000000*10**decimals;

	
    mapping(address =&amp;gt; uint256) balances;
	mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;
	event GetETH(address indexed _from, uint256 _value);

	function XTYF(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}

	function () payable external
	{
		GetETH(msg.sender,msg.value);
	}

	function etherProceeds() external
		onlyOwner
	{
		if(!msg.sender.send(this.balance)) revert();
	}

  	function transfer(address _to, uint256 _value) public  returns (bool)
 	{
		require(_to != address(0));
		// SafeMath.sub will throw if there is not enough balance.
		balances[msg.sender] = balances[msg.sender].sub(_value);
		balances[_to] = balances[_to].add(_value);
		Transfer(msg.sender, _to, _value);
		return true;
  	}

  	function balanceOf(address _owner) public constant returns (uint256 balance) 
  	{
		return balances[_owner];
  	}

  	function transferFrom(address _from, address _to, uint256 _value) public returns (bool) 
  	{
		require(_to != address(0));
		uint256 _allowance = allowed[_from][msg.sender];

		balances[_from] = balances[_from].sub(_value);
		balances[_to] = balances[_to].add(_value);
		allowed[_from][msg.sender] = _allowance.sub(_value);
		Transfer(_from, _to, _value);
		return true;
  	}

  	function approve(address _spender, uint256 _value) public returns (bool) 
  	{
		allowed[msg.sender][_spender] = _value;
		Approval(msg.sender, _spender, _value);
		return true;
  	}

  	function allowance(address _owner, address _spender) public constant returns (uint256 remaining) 
  	{
		return allowed[_owner][_spender];
  	}

	  
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x0b48b747436f10c846696e889e66425e05cd740f.sol" target="_blank" title="show github file">0x0b48b747436f10c846696e889e66425e05cd740f.sol</a>
        </div>
        <div class="path">solidity-files/0x0b48b747436f10c846696e889e66425e05cd740f.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
pragma solidity 0.4.19;
/// @title Utility Functions for uint8
/// @author Kongliang Zhong - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;c6ada9a8a1aaafa7a8a186aaa9a9b6b4afa8a1e8a9b4a1&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;,
/// @author Daniel Wang - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;b1d5d0dfd8d4ddf1dddedec1c3d8dfd69fdec3d6&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;.
library MathUint8 {
    function xorReduce(
        uint8[] arr,
        uint    len
        )
        internal
        pure
        returns (uint8 res)
    {
        res = arr[0];
        for (uint i = 1; i &amp;lt; len; i++) {
            res ^= arr[i];
        }
    }
}
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/// @title Utility Functions for uint
/// @author Daniel Wang - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;81e5e0efe8e4edc1edeeeef1f3e8efe6afeef3e6&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;
library MathUint {
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function sub(uint a, uint b) internal pure returns (uint) {
        require(b &amp;lt;= a);
        return a - b;
    }
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function tolerantSub(uint a, uint b) internal pure returns (uint c) {
        return (a &amp;gt;= b) ? a - b : 0;
    }
    /// @dev calculate the square of Coefficient of Variation (CV)
    /// https://en.wikipedia.org/wiki/Coefficient_of_variation
    function cvsquare(
        uint[] arr,
        uint scale
        )
        internal
        pure
        returns (uint)
    {
        uint len = arr.length;
        require(len &amp;gt; 1);
        require(scale &amp;gt; 0);
        uint avg = 0;
        for (uint i = 0; i &amp;lt; len; i++) {
            avg += arr[i];
        }
        avg = avg / len;
        if (avg == 0) {
            return 0;
        }
        uint cvs = 0;
        uint s;
        uint item;
        for (i = 0; i &amp;lt; len; i++) {
            item = arr[i];
            s = item &amp;gt; avg ? item - avg : avg - item;
            cvs += mul(s, s);
        }
        return ((mul(mul(cvs, scale), scale) / avg) / avg) / (len - 1);
    }
}
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/// @title Utility Functions for byte32
/// @author Kongliang Zhong - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;bed5d1d0d9d2d7dfd0d9fed2d1d1ceccd7d0d990d1ccd9&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;,
/// @author Daniel Wang - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;5236333c3b373e123e3d3d22203b3c357c3d2035&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;.
library MathBytes32 {
    function xorReduce(
        bytes32[]   arr,
        uint        len
        )
        internal
        pure
        returns (bytes32 res)
    {
        res = arr[0];
        for (uint i = 1; i &amp;lt; len; i++) {
            res ^= arr[i];
        }
    }
}
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/// @title ERC20 Token Interface
/// @dev see https://github.com/ethereum/EIPs/issues/20
/// @author Daniel Wang - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;670306090e020b270b080817150e090049081500&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;
contract ERC20 {
    uint public totalSupply;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function balanceOf(address who) view public returns (uint256);
    function allowance(address owner, address spender) view public returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
}
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/// @title Loopring Token Exchange Protocol Contract Interface
/// @author Daniel Wang - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;6a0e0b04030f062a0605051a1803040d4405180d&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;
/// @author Kongliang Zhong - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;e88387868f848189868fa8848787989a81868fc6879a8f&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;
contract LoopringProtocol {
    ////////////////////////////////////////////////////////////////////////////
    /// Constants                                                            ///
    ////////////////////////////////////////////////////////////////////////////
    uint8   public constant MARGIN_SPLIT_PERCENTAGE_BASE = 100;
    ////////////////////////////////////////////////////////////////////////////
    /// Events                                                               ///
    ////////////////////////////////////////////////////////////////////////////
    /// @dev Event to emit if a ring is successfully mined.
    /// _amountsList is an array of:
    /// [_amountS, _amountB, _lrcReward, _lrcFee, splitS, splitB].
    event RingMined(
        uint                _ringIndex,
        bytes32     indexed _ringHash,
        address             _miner,
        address             _feeRecipient,
        bytes32[]           _orderHashList,
        uint[6][]           _amountsList
    );
    event OrderCancelled(
        bytes32     indexed _orderHash,
        uint                _amountCancelled
    );
    event AllOrdersCancelled(
        address     indexed _address,
        uint                _cutoff
    );
    event OrdersCancelled(
        address     indexed _address,
        address             _token1,
        address             _token2,
        uint                _cutoff
    );
    ////////////////////////////////////////////////////////////////////////////
    /// Functions                                                            ///
    ////////////////////////////////////////////////////////////////////////////
    /// @dev Cancel a order. cancel amount(amountS or amountB) can be specified
    ///      in orderValues.
    /// @param addresses          owner, tokenS, tokenB, authAddr
    /// @param orderValues        amountS, amountB, validSince (second),
    ///                           validUntil (second), lrcFee, walletId, and
    ///                           cancelAmount.
    /// @param buyNoMoreThanAmountB -
    ///                           This indicates when a order should be considered
    ///                           as &amp;#39;completely filled&amp;#39;.
    /// @param marginSplitPercentage -
    ///                           Percentage of margin split to share with miner.
    /// @param v                  Order ECDSA signature parameter v.
    /// @param r                  Order ECDSA signature parameters r.
    /// @param s                  Order ECDSA signature parameters s.
    function cancelOrder(
        address[4] addresses,
        uint[7]    orderValues,
        bool       buyNoMoreThanAmountB,
        uint8      marginSplitPercentage,
        uint8      v,
        bytes32    r,
        bytes32    s
        ) external;
    /// @dev   Set a cutoff timestamp to invalidate all orders whose timestamp
    ///        is smaller than or equal to the new value of the address&amp;#39;s cutoff
    ///        timestamp, for a specific trading pair.
    /// @param cutoff The cutoff timestamp, will default to `block.timestamp`
    ///        if it is 0.
    function cancelAllOrdersByTradingPair(
        address token1,
        address token2,
        uint cutoff
        ) external;
    /// @dev   Set a cutoff timestamp to invalidate all orders whose timestamp
    ///        is smaller than or equal to the new value of the address&amp;#39;s cutoff
    ///        timestamp.
    /// @param cutoff The cutoff timestamp, will default to `block.timestamp`
    ///        if it is 0.
    function cancelAllOrders(uint cutoff) external;
    /// @dev Submit a order-ring for validation and settlement.
    /// @param addressList  List of each order&amp;#39;s owner, tokenS, and authAddr.
    ///                     Note that next order&amp;#39;s `tokenS` equals this order&amp;#39;s
    ///                     `tokenB`.
    /// @param uintArgsList List of uint-type arguments in this order:
    ///                     amountS, amountB, validSince (second),
    ///                     validUntil (second), lrcFee, rateAmountS, and walletId.
    /// @param uint8ArgsList -
    ///                     List of unit8-type arguments, in this order:
    ///                     marginSplitPercentageList.
    /// @param buyNoMoreThanAmountBList -
    ///                     This indicates when a order should be considered
    /// @param vList        List of v for each order. This list is 1-larger than
    ///                     the previous lists, with the last element being the
    ///                     v value of the ring signature.
    /// @param rList        List of r for each order. This list is 1-larger than
    ///                     the previous lists, with the last element being the
    ///                     r value of the ring signature.
    /// @param sList        List of s for each order. This list is 1-larger than
    ///                     the previous lists, with the last element being the
    ///                     s value of the ring signature.
    /// @param minerId      The address pair that miner registered in NameRegistry.
    ///                     The address pair contains a signer address and a fee
    ///                     recipient address.
    ///                     The signer address is used for sign this tx.
    ///                     The Recipient address for fee collection. If this is
    ///                     &amp;#39;0x0&amp;#39;, all fees will be paid to the address who had
    ///                     signed this transaction, not `msg.sender`. Noted if
    ///                     LRC need to be paid back to order owner as the result
    ///                     of fee selection model, LRC will also be sent from
    ///                     this address.
    /// @param feeSelections -
    ///                     Bits to indicate fee selections. `1` represents margin
    ///                     split and `0` represents LRC as fee.
    function submitRing(
        address[3][]    addressList,
        uint[7][]       uintArgsList,
        uint8[1][]      uint8ArgsList,
        bool[]          buyNoMoreThanAmountBList,
        uint8[]         vList,
        bytes32[]       rList,
        bytes32[]       sList,
        uint            minerId,
        uint16          feeSelections
        ) public;
}
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/// @title Ethereum Address Register Contract
/// @dev This contract maintains a name service for addresses and miner.
/// @author Kongliang Zhong - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;ec8783828b80858d828bac8083839c9e85828bc2839e8b&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;,
/// @author Daniel Wang - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;4420252a2d212804282b2b34362d2a236a2b3623&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;,
contract NameRegistry {
    uint public nextId = 0;
    mapping (uint    =&amp;gt; Participant) public participantMap;
    mapping (address =&amp;gt; NameInfo)    public nameInfoMap;
    mapping (bytes12 =&amp;gt; address)     public ownerMap;
    mapping (address =&amp;gt; string)      public nameMap;
    struct NameInfo {
        bytes12  name;
        uint[]   participantIds;
    }
    struct Participant {
        address feeRecipient;
        address signer;
        bytes12 name;
        address owner;
    }
    event NameRegistered (
        string            name,
        address   indexed owner
    );
    event NameUnregistered (
        string             name,
        address    indexed owner
    );
    event OwnershipTransfered (
        bytes12            name,
        address            oldOwner,
        address            newOwner
    );
    event ParticipantRegistered (
        bytes12           name,
        address   indexed owner,
        uint      indexed participantId,
        address           singer,
        address           feeRecipient
    );
    event ParticipantUnregistered (
        uint    participantId,
        address owner
    );
    function registerName(string name)
        external
    {
        require(isNameValid(name));
        bytes12 nameBytes = stringToBytes12(name);
        require(ownerMap[nameBytes] == 0x0);
        require(stringToBytes12(nameMap[msg.sender]) == bytes12(0x0));
        nameInfoMap[msg.sender] = NameInfo(nameBytes, new uint[](0));
        ownerMap[nameBytes] = msg.sender;
        nameMap[msg.sender] = name;
        NameRegistered(name, msg.sender);
    }
    function unregisterName(string name)
        external
    {
        NameInfo storage nameInfo = nameInfoMap[msg.sender];
        uint[] storage participantIds = nameInfo.participantIds;
        bytes12 nameBytes = stringToBytes12(name);
        require(nameInfo.name == nameBytes);
        for (uint i = participantIds.length - 1; i &amp;gt;= 0; i--) {
            delete participantMap[participantIds[i]];
        }
        delete nameInfoMap[msg.sender];
        delete nameMap[msg.sender];
        delete ownerMap[nameBytes];
        NameUnregistered(name, msg.sender);
    }
    function transferOwnership(address newOwner)
        external
    {
        require(newOwner != 0x0);
        require(nameInfoMap[newOwner].name.length == 0);
        NameInfo storage nameInfo = nameInfoMap[msg.sender];
        string storage name = nameMap[msg.sender];
        uint[] memory participantIds = nameInfo.participantIds;
        for (uint i = 0; i &amp;lt; participantIds.length; i ++) {
            Participant storage p = participantMap[participantIds[i]];
            p.owner = newOwner;
        }
        delete nameInfoMap[msg.sender];
        delete nameMap[msg.sender];
        nameInfoMap[newOwner] = nameInfo;
        nameMap[newOwner] = name;
        OwnershipTransfered(nameInfo.name, msg.sender, newOwner);
    }
    /* function addParticipant(address feeRecipient) */
    /*     external */
    /*     returns (uint) */
    /* { */
    /*     return addParticipant(feeRecipient, feeRecipient); */
    /* } */
    function addParticipant(
        address feeRecipient,
        address singer
        )
        external
        returns (uint)
    {
        require(feeRecipient != 0x0 &amp;amp;&amp;amp; singer != 0x0);
        NameInfo storage nameInfo = nameInfoMap[msg.sender];
        bytes12 name = nameInfo.name;
        require(name.length &amp;gt; 0);
        Participant memory participant = Participant(
            feeRecipient,
            singer,
            name,
            msg.sender
        );
        uint participantId = ++nextId;
        participantMap[participantId] = participant;
        nameInfo.participantIds.push(participantId);
        ParticipantRegistered(
            name,
            msg.sender,
            participantId,
            singer,
            feeRecipient
        );
        return participantId;
    }
    function removeParticipant(uint participantId)
        external
    {
        require(msg.sender == participantMap[participantId].owner);
        NameInfo storage nameInfo = nameInfoMap[msg.sender];
        uint[] storage participantIds = nameInfo.participantIds;
        delete participantMap[participantId];
        uint len = participantIds.length;
        for (uint i = 0; i &amp;lt; len; i ++) {
            if (participantId == participantIds[i]) {
                participantIds[i] = participantIds[len - 1];
                participantIds.length -= 1;
            }
        }
        ParticipantUnregistered(participantId, msg.sender);
    }
    function getParticipantById(uint id)
        external
        view
        returns (address feeRecipient, address signer)
    {
        Participant storage addressSet = participantMap[id];
        feeRecipient = addressSet.feeRecipient;
        signer = addressSet.signer;
    }
    function getFeeRecipientById(uint id)
        external
        view
        returns (address feeRecipient)
    {
        Participant storage addressSet = participantMap[id];
        feeRecipient = addressSet.feeRecipient;
    }
    function getParticipantIds(string name, uint start, uint count)
        external
        view
        returns (uint[] idList)
    {
        bytes12 nameBytes = stringToBytes12(name);
        address owner = ownerMap[nameBytes];
        require(owner != 0x0);
        NameInfo storage nameInfo = nameInfoMap[owner];
        uint[] storage pIds = nameInfo.participantIds;
        uint len = pIds.length;
        if (start &amp;gt;= len) {
            return;
        }
        uint end = start + count;
        if (end &amp;gt; len) {
            end = len;
        }
        if (start == end) {
            return;
        }
        idList = new uint[](end - start);
        for (uint i = start; i &amp;lt; end; i ++) {
            idList[i - start] = pIds[i];
        }
    }
    function getOwner(string name)
        external
        view
        returns (address)
    {
        bytes12 nameBytes = stringToBytes12(name);
        return ownerMap[nameBytes];
    }
    function isNameValid(string name)
        internal
        pure
        returns (bool)
    {
        bytes memory temp = bytes(name);
        return temp.length &amp;gt;= 6 &amp;amp;&amp;amp; temp.length &amp;lt;= 12;
    }
    function stringToBytes12(string str)
        internal
        pure
        returns (bytes12 result)
    {
        assembly {
            result := mload(add(str, 32))
        }
    }
}
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/// @title Ownable
/// @dev The Ownable contract has an owner address, and provides basic
///      authorization control functions, this simplifies the implementation of
///      &amp;quot;user permissions&amp;quot;.
contract Ownable {
    address public owner;
    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );
    /// @dev The Ownable constructor sets the original `owner` of the contract
    ///      to the sender.
    function Ownable() public {
        owner = msg.sender;
    }
    /// @dev Throws if called by any account other than the owner.
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    /// @dev Allows the current owner to transfer control of the contract to a
    ///      newOwner.
    /// @param newOwner The address to transfer ownership to.
    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != 0x0);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
/// @title Claimable
/// @dev Extension for the Ownable contract, where the ownership needs
///      to be claimed. This allows the new owner to accept the transfer.
contract Claimable is Ownable {
    address public pendingOwner;
    /// @dev Modifier throws if called by any account other than the pendingOwner.
    modifier onlyPendingOwner() {
        require(msg.sender == pendingOwner);
        _;
    }
    /// @dev Allows the current owner to set the pendingOwner address.
    /// @param newOwner The address to transfer ownership to.
    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != 0x0 &amp;amp;&amp;amp; newOwner != owner);
        pendingOwner = newOwner;
    }
    /// @dev Allows the pendingOwner address to finalize the transfer.
    function claimOwnership() onlyPendingOwner public {
        OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = 0x0;
    }
}
/// @title Token Register Contract
/// @dev This contract maintains a list of tokens the Protocol supports.
/// @author Kongliang Zhong - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;e2898d8c858e8b838c85a28e8d8d92908b8c85cc8d9085&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;,
/// @author Daniel Wang - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;7a1e1b14131f163a1615150a0813141d5415081d&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;.
contract TokenRegistry is Claimable {
    address[] public addresses;
    mapping (address =&amp;gt; TokenInfo) addressMap;
    mapping (string =&amp;gt; address) symbolMap;
    ////////////////////////////////////////////////////////////////////////////
    /// Structs                                                              ///
    ////////////////////////////////////////////////////////////////////////////
    struct TokenInfo {
        uint   pos;      // 0 mens unregistered; if &amp;gt; 0, pos + 1 is the
                         // token&amp;#39;s position in `addresses`.
        string symbol;   // Symbol of the token
    }
    ////////////////////////////////////////////////////////////////////////////
    /// Events                                                               ///
    ////////////////////////////////////////////////////////////////////////////
    event TokenRegistered(address addr, string symbol);
    event TokenUnregistered(address addr, string symbol);
    ////////////////////////////////////////////////////////////////////////////
    /// Public Functions                                                     ///
    ////////////////////////////////////////////////////////////////////////////
    /// @dev Disable default function.
    function () payable public {
        revert();
    }
    function registerToken(
        address addr,
        string  symbol
        )
        external
        onlyOwner
    {
        require(0x0 != addr);
        require(bytes(symbol).length &amp;gt; 0);
        require(0x0 == symbolMap[symbol]);
        require(0 == addressMap[addr].pos);
        addresses.push(addr);
        symbolMap[symbol] = addr;
        addressMap[addr] = TokenInfo(addresses.length, symbol);
        TokenRegistered(addr, symbol);
    }
    function unregisterToken(
        address addr,
        string  symbol
        )
        external
        onlyOwner
    {
        require(addr != 0x0);
        require(symbolMap[symbol] == addr);
        delete symbolMap[symbol];
        uint pos = addressMap[addr].pos;
        require(pos != 0);
        delete addressMap[addr];
        // We will replace the token we need to unregister with the last token
        // Only the pos of the last token will need to be updated
        address lastToken = addresses[addresses.length - 1];
        // Don&amp;#39;t do anything if the last token is the one we want to delete
        if (addr != lastToken) {
            // Swap with the last token and update the pos
            addresses[pos - 1] = lastToken;
            addressMap[lastToken].pos = pos;
        }
        addresses.length--;
        TokenUnregistered(addr, symbol);
    }
    function areAllTokensRegistered(address[] addressList)
        external
        view
        returns (bool)
    {
        for (uint i = 0; i &amp;lt; addressList.length; i++) {
            if (addressMap[addressList[i]].pos == 0) {
                return false;
            }
        }
        return true;
    }
    function getAddressBySymbol(string symbol)
        external
        view
        returns (address)
    {
        return symbolMap[symbol];
    }
    function isTokenRegisteredBySymbol(string symbol)
        public
        view
        returns (bool)
    {
        return symbolMap[symbol] != 0x0;
    }
    function isTokenRegistered(address addr)
        public
        view
        returns (bool)
    {
        return addressMap[addr].pos != 0;
    }
    function getTokens(
        uint start,
        uint count
        )
        public
        view
        returns (address[] addressList)
    {
        uint num = addresses.length;
        if (start &amp;gt;= num) {
            return;
        }
        uint end = start + count;
        if (end &amp;gt; num) {
            end = num;
        }
        if (start == num) {
            return;
        }
        addressList = new address[](end - start);
        for (uint i = start; i &amp;lt; end; i++) {
            addressList[i - start] = addresses[i];
        }
    }
}
/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/// @title TokenTransferDelegate
/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different
/// versions of Loopring protocol to avoid ERC20 re-authorization.
/// @author Daniel Wang - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;bfdbded1d6dad3ffd3d0d0cfcdd6d1d891d0&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;rg&amp;gt;.
contract TokenTransferDelegate is Claimable {
    using MathUint for uint;
    ////////////////////////////////////////////////////////////////////////////
    /// Variables                                                            ///
    ////////////////////////////////////////////////////////////////////////////
    mapping(address =&amp;gt; AddressInfo) private addressInfos;
    address public latestAddress;
    ////////////////////////////////////////////////////////////////////////////
    /// Structs                                                              ///
    ////////////////////////////////////////////////////////////////////////////
    struct AddressInfo {
        address previous;
        uint32  index;
        bool    authorized;
    }
    ////////////////////////////////////////////////////////////////////////////
    /// Modifiers                                                            ///
    ////////////////////////////////////////////////////////////////////////////
    modifier onlyAuthorized() {
        require(addressInfos[msg.sender].authorized);
        _;
    }
    ////////////////////////////////////////////////////////////////////////////
    /// Events                                                               ///
    ////////////////////////////////////////////////////////////////////////////
    event AddressAuthorized(address indexed addr, uint32 number);
    event AddressDeauthorized(address indexed addr, uint32 number);
    ////////////////////////////////////////////////////////////////////////////
    /// Public Functions                                                     ///
    ////////////////////////////////////////////////////////////////////////////
    /// @dev Disable default function.
    function () payable public {
        revert();
    }
    /// @dev Add a Loopring protocol address.
    /// @param addr A loopring protocol address.
    function authorizeAddress(address addr)
        onlyOwner
        external
    {
        AddressInfo storage addrInfo = addressInfos[addr];
        if (addrInfo.index != 0) { // existing
            if (addrInfo.authorized == false) { // re-authorize
                addrInfo.authorized = true;
                AddressAuthorized(addr, addrInfo.index);
            }
        } else {
            address prev = latestAddress;
            if (prev == 0x0) {
                addrInfo.index = 1;
                addrInfo.authorized = true;
            } else {
                addrInfo.previous = prev;
                addrInfo.index = addressInfos[prev].index + 1;
            }
            addrInfo.authorized = true;
            latestAddress = addr;
            AddressAuthorized(addr, addrInfo.index);
        }
    }
    /// @dev Remove a Loopring protocol address.
    /// @param addr A loopring protocol address.
    function deauthorizeAddress(address addr)
        onlyOwner
        external
    {
        uint32 index = addressInfos[addr].index;
        if (index != 0) {
            addressInfos[addr].authorized = false;
            AddressDeauthorized(addr, index);
        }
    }
    function getLatestAuthorizedAddresses(uint max)
        external
        view
        returns (address[] addresses)
    {
        addresses = new address[](max);
        address addr = latestAddress;
        AddressInfo memory addrInfo;
        uint count = 0;
        while (addr != 0x0 &amp;amp;&amp;amp; count &amp;lt; max) {
            addrInfo = addressInfos[addr];
            if (addrInfo.index == 0) {
                break;
            }
            addresses[count++] = addr;
            addr = addrInfo.previous;
        }
    }
    /// @dev Invoke ERC20 transferFrom method.
    /// @param token Address of token to transfer.
    /// @param from Address to transfer token from.
    /// @param to Address to transfer token to.
    /// @param value Amount of token to transfer.
    function transferToken(
        address token,
        address from,
        address to,
        uint    value)
        onlyAuthorized
        external
    {
        if (value &amp;gt; 0 &amp;amp;&amp;amp; from != to &amp;amp;&amp;amp; to != 0x0) {
            require(
                ERC20(token).transferFrom(from, to, value)
            );
        }
    }
    function batchTransferToken(
        address lrcTokenAddress,
        address minerFeeRecipient,
        uint8 walletSplitPercentage,
        bytes32[] batch)
        onlyAuthorized
        external
    {
        uint len = batch.length;
        require(len % 7 == 0);
        require(walletSplitPercentage &amp;gt; 0 &amp;amp;&amp;amp; walletSplitPercentage &amp;lt; 100);
        ERC20 lrc = ERC20(lrcTokenAddress);
        for (uint i = 0; i &amp;lt; len; i += 7) {
            address owner = address(batch[i]);
            address prevOwner = address(batch[(i + len - 7) % len]);
            // Pay token to previous order, or to miner as previous order&amp;#39;s
            // margin split or/and this order&amp;#39;s margin split.
            ERC20 token = ERC20(address(batch[i + 1]));
            // Here batch[i + 2] has been checked not to be 0.
            if (owner != prevOwner) {
                require(
                    token.transferFrom(
                        owner,
                        prevOwner,
                        uint(batch[i + 2])
                    )
                );
            }
            // Miner pays LRx fee to order owner
            uint lrcReward = uint(batch[i + 4]);
            if (lrcReward != 0 &amp;amp;&amp;amp; minerFeeRecipient != owner) {
                require(
                    lrc.transferFrom(
                        minerFeeRecipient,
                        owner,
                        lrcReward
                    )
                );
            }
            // Split margin-split income between miner and wallet
            splitPayFee(
                token,
                uint(batch[i + 3]),
                owner,
                minerFeeRecipient,
                address(batch[i + 6]),
                walletSplitPercentage
            );
            // Split LRx fee income between miner and wallet
            splitPayFee(
                lrc,
                uint(batch[i + 5]),
                owner,
                minerFeeRecipient,
                address(batch[i + 6]),
                walletSplitPercentage
            );
        }
    }
    function isAddressAuthorized(address addr)
        public
        view
        returns (bool)
    {
        return addressInfos[addr].authorized;
    }
    function splitPayFee(
        ERC20   token,
        uint    fee,
        address owner,
        address minerFeeRecipient,
        address walletFeeRecipient,
        uint    walletSplitPercentage
        )
        internal
    {
        if (fee == 0) {
            return;
        }
        uint walletFee = (walletFeeRecipient == 0x0) ? 0 : fee.mul(walletSplitPercentage) / 100;
        uint minerFee = fee - walletFee;
        if (walletFee &amp;gt; 0 &amp;amp;&amp;amp; walletFeeRecipient != owner) {
            require(
                token.transferFrom(
                    owner,
                    walletFeeRecipient,
                    walletFee
                )
            );
        }
        if (minerFee &amp;gt; 0 &amp;amp;&amp;amp; minerFeeRecipient != 0x0 &amp;amp;&amp;amp; minerFeeRecipient != owner) {
            require(
                token.transferFrom(
                    owner,
                    minerFeeRecipient,
                    minerFee
                )
            );
        }
    }
}
/// @title Loopring Token Exchange Protocol Implementation Contract
/// @author Daniel Wang - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;95f1f4fbfcf0f9d5f9fafae5e7fcfbf2bbfae7f2&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;,
/// @author Kongliang Zhong - &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;046f6b6a63686d656a6344686b6b74766d6a632a6b7663&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;
///
/// Recognized contributing developers from the community:
///     https://github.com/Brechtpd
///     https://github.com/rainydio
///     https://github.com/BenjaminPrice
///     https://github.com/jonasshen
contract LoopringProtocolImpl is LoopringProtocol {
    using MathBytes32   for bytes32[];
    using MathUint      for uint;
    using MathUint8     for uint8[];
    ////////////////////////////////////////////////////////////////////////////
    /// Variables                                                            ///
    ////////////////////////////////////////////////////////////////////////////
    address public constant lrcTokenAddress       = 0xEF68e7C694F40c8202821eDF525dE3782458639f;
    address public constant tokenRegistryAddress  = 0xa21c1f2AE7f721aE77b1204A4f0811c642638da9;
    address public constant delegateAddress       = 0x7b126ab811f278f288bf1d62d47334351dA20d1d;
    address public constant nameRegistryAddress   = 0xd181c1808e3f010F0F0aABc6Fe1bcE2025DB7Bb7;
    uint64  public ringIndex                      = 0;
    uint8   public constant walletSplitPercentage = 20;
    // Exchange rate (rate) is the amount to sell or sold divided by the amount
    // to buy or bought.
    //
    // Rate ratio is the ratio between executed rate and an order&amp;#39;s original
    // rate.
    //
    // To require all orders&amp;#39; rate ratios to have coefficient ofvariation (CV)
    // smaller than 2.5%, for an example , rateRatioCVSThreshold should be:
    //     `(0.025 * RATE_RATIO_SCALE)^2` or 62500.
    uint    public constant rateRatioCVSThreshold        = 62500;
    uint    public constant MAX_RING_SIZE                = 16;
    uint    public constant RATE_RATIO_SCALE             = 10000;
    uint64  public constant ENTERED_MASK                 = 1 &amp;lt;&amp;lt; 63;
    // The following map is used to keep trace of order fill and cancellation
    // history.
    mapping (bytes32 =&amp;gt; uint) public cancelledOrFilled;
    // This map is used to keep trace of order&amp;#39;s cancellation history.
    mapping (bytes32 =&amp;gt; uint) public cancelled;
    // A map from address to its cutoff timestamp.
    mapping (address =&amp;gt; uint) public cutoffs;
    // A map from address to its trading-pair cutoff timestamp.
    mapping (address =&amp;gt; mapping (bytes20 =&amp;gt; uint)) public tradingPairCutoffs;
    ////////////////////////////////////////////////////////////////////////////
    /// Structs                                                              ///
    ////////////////////////////////////////////////////////////////////////////
    struct Rate {
        uint amountS;
        uint amountB;
    }
    /// @param tokenS       Token to sell.
    /// @param tokenB       Token to buy.
    /// @param amountS      Maximum amount of tokenS to sell.
    /// @param amountB      Minimum amount of tokenB to buy if all amountS sold.
    /// @param authAddr     An address to verify miner has access to the order&amp;#39;s
    ///                     auth private-key.
    /// @param validSince   Indicating when this order should be treated as
    ///                     valid for trading, in second.
    /// @param validUntil   Indicating when this order should be treated as
    ///                     expired, in second.
    /// @param lrcFee       Max amount of LRC to pay for miner. The real amount
    ///                     to pay is proportional to fill amount.
    /// @param buyNoMoreThanAmountB -
    ///                     If true, this order does not accept buying more
    ///                     than `amountB`.
    /// @param walletId     The id of the wallet that generated this order.
    /// @param marginSplitPercentage -
    ///                     The percentage of margin paid to miner.
    /// @param v            ECDSA signature parameter v.
    /// @param r            ECDSA signature parameters r.
    /// @param s            ECDSA signature parameters s.
    struct Order {
        address owner;
        address tokenS;
        address tokenB;
        address authAddr;
        uint    validSince;
        uint    validUntil;
        uint    amountS;
        uint    amountB;
        uint    lrcFee;
        bool    buyNoMoreThanAmountB;
        uint    walletId;
        uint8   marginSplitPercentage;
    }
    /// @param order        The original order
    /// @param orderHash    The order&amp;#39;s hash
    /// @param feeSelection -
    ///                     A miner-supplied value indicating if LRC (value = 0)
    ///                     or margin split is choosen by the miner (value = 1).
    ///                     We may support more fee model in the future.
    /// @param rate         Exchange rate provided by miner.
    /// @param fillAmountS  Amount of tokenS to sell, calculated by protocol.
    /// @param lrcReward    The amount of LRC paid by miner to order owner in
    ///                     exchange for margin split.
    /// @param lrcFee       The amount of LR paid by order owner to miner.
    /// @param splitS      TokenS paid to miner.
    /// @param splitB      TokenB paid to miner.
    struct OrderState {
        Order   order;
        bytes32 orderHash;
        bool    marginSplitAsFee;
        Rate    rate;
        uint    fillAmountS;
        uint    lrcReward;
        uint    lrcFee;
        uint    splitS;
        uint    splitB;
    }
    /// @dev A struct to capture parameters passed to submitRing method and
    ///      various of other variables used across the submitRing core logics.
    struct RingParams {
        address[3][]  addressList;
        uint[7][]     uintArgsList;
        uint8[1][]    uint8ArgsList;
        bool[]        buyNoMoreThanAmountBList;
        uint8[]       vList;
        bytes32[]     rList;
        bytes32[]     sList;
        uint          minerId;
        uint          ringSize;         // computed
        uint16        feeSelections;
        address       ringMiner;        // queried
        address       feeRecipient;     // queried
        bytes32       ringHash;         // computed
    }
    ////////////////////////////////////////////////////////////////////////////
    /// Constructor                                                          ///
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    /// Public Functions                                                     ///
    ////////////////////////////////////////////////////////////////////////////
    /// @dev Disable default function.
    function () payable public {
        revert();
    }
    function cancelOrder(
        address[4] addresses,
        uint[7]    orderValues,
        bool       buyNoMoreThanAmountB,
        uint8      marginSplitPercentage,
        uint8      v,
        bytes32    r,
        bytes32    s
        )
        external
    {
        uint cancelAmount = orderValues[6];
        require(cancelAmount &amp;gt; 0); // &amp;quot;amount to cancel is zero&amp;quot;);
        Order memory order = Order(
            addresses[0],
            addresses[1],
            addresses[2],
            addresses[3],
            orderValues[2],
            orderValues[3],
            orderValues[0],
            orderValues[1],
            orderValues[4],
            buyNoMoreThanAmountB,
            orderValues[5],
            marginSplitPercentage
        );
        require(msg.sender == order.owner); // &amp;quot;cancelOrder not submitted by order owner&amp;quot;);
        bytes32 orderHash = calculateOrderHash(order);
        verifySignature(
            order.owner,
            orderHash,
            v,
            r,
            s
        );
        cancelled[orderHash] = cancelled[orderHash].add(cancelAmount);
        cancelledOrFilled[orderHash] = cancelledOrFilled[orderHash].add(cancelAmount);
        OrderCancelled(orderHash, cancelAmount);
    }
    function cancelAllOrdersByTradingPair(
        address token1,
        address token2,
        uint    cutoff
        )
        external
    {
        uint t = (cutoff == 0 || cutoff &amp;gt;= block.timestamp) ? block.timestamp : cutoff;
        bytes20 tokenPair = bytes20(token1) ^ bytes20(token2);
        require(tradingPairCutoffs[msg.sender][tokenPair] &amp;lt; t); // &amp;quot;attempted to set cutoff to a smaller value&amp;quot;
        tradingPairCutoffs[msg.sender][tokenPair] = t;
        OrdersCancelled(
            msg.sender,
            token1,
            token2,
            t
        );
    }
    function cancelAllOrders(uint cutoff)
        external
    {
        uint t = (cutoff == 0 || cutoff &amp;gt;= block.timestamp) ? block.timestamp : cutoff;
        require(cutoffs[msg.sender] &amp;lt; t); // &amp;quot;attempted to set cutoff to a smaller value&amp;quot;
        cutoffs[msg.sender] = t;
        AllOrdersCancelled(msg.sender, t);
    }
    function submitRing(
        address[3][]  addressList,
        uint[7][]     uintArgsList,
        uint8[1][]    uint8ArgsList,
        bool[]        buyNoMoreThanAmountBList,
        uint8[]       vList,
        bytes32[]     rList,
        bytes32[]     sList,
        uint          minerId,
        uint16        feeSelections
        )
        public
    {
        // Check if the highest bit of ringIndex is &amp;#39;1&amp;#39;.
        require(ringIndex &amp;amp; ENTERED_MASK != ENTERED_MASK); // &amp;quot;attempted to re-ent submitRing function&amp;quot;);
        // Set the highest bit of ringIndex to &amp;#39;1&amp;#39;.
        ringIndex |= ENTERED_MASK;
        RingParams memory params = RingParams(
            addressList,
            uintArgsList,
            uint8ArgsList,
            buyNoMoreThanAmountBList,
            vList,
            rList,
            sList,
            minerId,
            addressList.length,
            feeSelections,
            0x0,        // ringMiner
            0x0,        // feeRecipient
            0x0         // ringHash
        );
        verifyInputDataIntegrity(params);
        updateFeeRecipient(params);
        // Assemble input data into structs so we can pass them to other functions.
        // This method also calculates ringHash, therefore it must be called before
        // calling `verifyRingSignatures`.
        OrderState[] memory orders = assembleOrders(params);
        verifyRingSignatures(params);
        verifyTokensRegistered(params);
        handleRing(params, orders);
        ringIndex = (ringIndex ^ ENTERED_MASK) + 1;
    }
    ////////////////////////////////////////////////////////////////////////////
    /// Internal &amp;amp; Private Functions                                         ///
    ////////////////////////////////////////////////////////////////////////////
    /// @dev Validate a ring.
    function verifyRingHasNoSubRing(
        uint          ringSize,
        OrderState[]  orders
        )
        private
        pure
    {
        // Check the ring has no sub-ring.
        for (uint i = 0; i &amp;lt; ringSize - 1; i++) {
            address tokenS = orders[i].order.tokenS;
            for (uint j = i + 1; j &amp;lt; ringSize; j++) {
                require(tokenS != orders[j].order.tokenS); // &amp;quot;found sub-ring&amp;quot;);
            }
        }
    }
    /// @dev Verify the ringHash has been signed with each order&amp;#39;s auth private
    ///      keys as well as the miner&amp;#39;s private key.
    function verifyRingSignatures(RingParams params)
        private
        pure
    {
        uint j;
        for (uint i = 0; i &amp;lt; params.ringSize; i++) {
            j = i + params.ringSize;
            verifySignature(
                params.addressList[i][2],  // authAddr
                params.ringHash,
                params.vList[j],
                params.rList[j],
                params.sList[j]
            );
        }
        if (params.ringMiner != 0x0) {
            j++;
            verifySignature(
                params.ringMiner,
                params.ringHash,
                params.vList[j],
                params.rList[j],
                params.sList[j]
            );
        }
    }
    function verifyTokensRegistered(RingParams params)
        private
        view
    {
        // Extract the token addresses
        address[] memory tokens = new address[](params.ringSize);
        for (uint i = 0; i &amp;lt; params.ringSize; i++) {
            tokens[i] = params.addressList[i][1];
        }
        // Test all token addresses at once
        require(
            TokenRegistry(tokenRegistryAddress).areAllTokensRegistered(tokens)
        ); // &amp;quot;token not registered&amp;quot;);
    }
    function updateFeeRecipient(RingParams params)
        private
        view
    {
        if (params.minerId == 0) {
            params.feeRecipient = msg.sender;
        } else {
            (params.feeRecipient, params.ringMiner) = NameRegistry(
                nameRegistryAddress
            ).getParticipantById(
                params.minerId
            );
            if (params.feeRecipient == 0x0) {
                params.feeRecipient = msg.sender;
            }
        }
        uint sigSize = params.ringSize * 2;
        if (params.ringMiner != 0x0) {
            sigSize += 1;
        }
        require(sigSize == params.vList.length); // &amp;quot;ring data is inconsistent - vList&amp;quot;);
        require(sigSize == params.rList.length); // &amp;quot;ring data is inconsistent - rList&amp;quot;);
        require(sigSize == params.sList.length); // &amp;quot;ring data is inconsistent - sList&amp;quot;);
    }
    function handleRing(
        RingParams    params,
        OrderState[]  orders
        )
        private
    {
        uint64 _ringIndex = ringIndex ^ ENTERED_MASK;
        address _lrcTokenAddress = lrcTokenAddress;
        TokenTransferDelegate delegate = TokenTransferDelegate(delegateAddress);
        // Do the hard work.
        verifyRingHasNoSubRing(params.ringSize, orders);
        // Exchange rates calculation are performed by ring-miners as solidity
        // cannot get power-of-1/n operation, therefore we have to verify
        // these rates are correct.
        verifyMinerSuppliedFillRates(params.ringSize, orders);
        // Scale down each order independently by substracting amount-filled and
        // amount-cancelled. Order owner&amp;#39;s current balance and allowance are
        // not taken into consideration in these operations.
        scaleRingBasedOnHistoricalRecords(delegate, params.ringSize, orders);
        // Based on the already verified exchange rate provided by ring-miners,
        // we can furthur scale down orders based on token balance and allowance,
        // then find the smallest order of the ring, then calculate each order&amp;#39;s
        // `fillAmountS`.
        calculateRingFillAmount(params.ringSize, orders);
        // Calculate each order&amp;#39;s `lrcFee` and `lrcRewrard` and splict how much
        // of `fillAmountS` shall be paid to matching order or miner as margin
        // split.
        calculateRingFees(
            delegate,
            params.ringSize,
            orders,
            params.feeRecipient,
            _lrcTokenAddress
        );
        /// Make transfers.
        var (orderHashList, amountsList) = settleRing(
            delegate,
            params.ringSize,
            orders,
            params.feeRecipient,
            _lrcTokenAddress
        );
        RingMined(
            _ringIndex,
            params.ringHash,
            params.ringMiner,
            params.feeRecipient,
            orderHashList,
            amountsList
        );
    }
    function settleRing(
        TokenTransferDelegate delegate,
        uint          ringSize,
        OrderState[]  orders,
        address       feeRecipient,
        address       _lrcTokenAddress
        )
        private
        returns(
        bytes32[] memory orderHashList,
        uint[6][] memory amountsList)
    {
        bytes32[] memory batch = new bytes32[](ringSize * 7); // ringSize * (owner + tokenS + 4 amounts)
        orderHashList = new bytes32[](ringSize);
        amountsList = new uint[6][](ringSize);
        uint p = 0;
        for (uint i = 0; i &amp;lt; ringSize; i++) {
            OrderState memory state = orders[i];
            Order memory order = state.order;
            uint prevSplitB = orders[(i + ringSize - 1) % ringSize].splitB;
            uint nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;
            // Store owner and tokenS of every order
            batch[p] = bytes32(order.owner);
            batch[p + 1] = bytes32(order.tokenS);
            // Store all amounts
            batch[p + 2] = bytes32(state.fillAmountS - prevSplitB);
            batch[p + 3] = bytes32(prevSplitB + state.splitS);
            batch[p + 4] = bytes32(state.lrcReward);
            batch[p + 5] = bytes32(state.lrcFee);
            if (order.walletId != 0) {
                batch[p + 6] = bytes32(NameRegistry(nameRegistryAddress).getFeeRecipientById(order.walletId));
            } else {
                batch[p + 6] = bytes32(0x0);
            }
            p += 7;
            // Update fill records
            if (order.buyNoMoreThanAmountB) {
                cancelledOrFilled[state.orderHash] += nextFillAmountS;
            } else {
                cancelledOrFilled[state.orderHash] += state.fillAmountS;
            }
            orderHashList[i] = state.orderHash;
            amountsList[i][0] = state.fillAmountS + state.splitS;
            amountsList[i][1] = nextFillAmountS - state.splitB;
            amountsList[i][2] = state.lrcReward;
            amountsList[i][3] = state.lrcFee;
            amountsList[i][4] = state.splitS;
            amountsList[i][5] = state.splitB;
        }
        // Do all transactions
        delegate.batchTransferToken(
            _lrcTokenAddress,
            feeRecipient,
            walletSplitPercentage,
            batch
        );
    }
    /// @dev Verify miner has calculte the rates correctly.
    function verifyMinerSuppliedFillRates(
        uint          ringSize,
        OrderState[]  orders
        )
        private
        view
    {
        uint[] memory rateRatios = new uint[](ringSize);
        uint _rateRatioScale = RATE_RATIO_SCALE;
        for (uint i = 0; i &amp;lt; ringSize; i++) {
            uint s1b0 = orders[i].rate.amountS.mul(orders[i].order.amountB);
            uint s0b1 = orders[i].order.amountS.mul(orders[i].rate.amountB);
            require(s1b0 &amp;lt;= s0b1); // &amp;quot;miner supplied exchange rate provides invalid discount&amp;quot;);
            rateRatios[i] = _rateRatioScale.mul(s1b0) / s0b1;
        }
        uint cvs = MathUint.cvsquare(rateRatios, _rateRatioScale);
        require(cvs &amp;lt;= rateRatioCVSThreshold); // &amp;quot;miner supplied exchange rate is not evenly discounted&amp;quot;);
    }
    /// @dev Calculate each order&amp;#39;s fee or LRC reward.
    function calculateRingFees(
        TokenTransferDelegate delegate,
        uint            ringSize,
        OrderState[]    orders,
        address         feeRecipient,
        address         _lrcTokenAddress
        )
        private
        view
    {
        bool checkedMinerLrcSpendable = false;
        uint minerLrcSpendable = 0;
        uint8 _marginSplitPercentageBase = MARGIN_SPLIT_PERCENTAGE_BASE;
        uint nextFillAmountS;
        for (uint i = 0; i &amp;lt; ringSize; i++) {
            OrderState memory state = orders[i];
            uint lrcReceiable = 0;
            if (state.lrcFee == 0) {
                // When an order&amp;#39;s LRC fee is 0 or smaller than the specified fee,
                // we help miner automatically select margin-split.
                state.marginSplitAsFee = true;
                state.order.marginSplitPercentage = _marginSplitPercentageBase;
            } else {
                uint lrcSpendable = getSpendable(
                    delegate,
                    _lrcTokenAddress,
                    state.order.owner
                );
                // If the order is selling LRC, we need to calculate how much LRC
                // is left that can be used as fee.
                if (state.order.tokenS == _lrcTokenAddress) {
                    lrcSpendable -= state.fillAmountS;
                }
                // If the order is buyign LRC, it will has more to pay as fee.
                if (state.order.tokenB == _lrcTokenAddress) {
                    nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;
                    lrcReceiable = nextFillAmountS;
                }
                uint lrcTotal = lrcSpendable + lrcReceiable;
                // If order doesn&amp;#39;t have enough LRC, set margin split to 100%.
                if (lrcTotal &amp;lt; state.lrcFee) {
                    state.lrcFee = lrcTotal;
                    state.order.marginSplitPercentage = _marginSplitPercentageBase;
                }
                if (state.lrcFee == 0) {
                    state.marginSplitAsFee = true;
                }
            }
            if (!state.marginSplitAsFee) {
                if (lrcReceiable &amp;gt; 0) {
                    if (lrcReceiable &amp;gt;= state.lrcFee) {
                        state.splitB = state.lrcFee;
                        state.lrcFee = 0;
                    } else {
                        state.splitB = lrcReceiable;
                        state.lrcFee -= lrcReceiable;
                    }
                }
            } else {
                // Only check the available miner balance when absolutely needed
                if (!checkedMinerLrcSpendable &amp;amp;&amp;amp; minerLrcSpendable &amp;lt; state.lrcFee) {
                    checkedMinerLrcSpendable = true;
                    minerLrcSpendable = getSpendable(delegate, _lrcTokenAddress, feeRecipient);
                }
                // Only calculate split when miner has enough LRC;
                // otherwise all splits are 0.
                if (minerLrcSpendable &amp;gt;= state.lrcFee) {
                    nextFillAmountS = orders[(i + 1) % ringSize].fillAmountS;
                    uint split;
                    if (state.order.buyNoMoreThanAmountB) {
                        split = (nextFillAmountS.mul(
                            state.order.amountS
                        ) / state.order.amountB).sub(
                            state.fillAmountS
                        );
                    } else {
                        split = nextFillAmountS.sub(
                            state.fillAmountS.mul(
                                state.order.amountB
                            ) / state.order.amountS
                        );
                    }
                    if (state.order.marginSplitPercentage != _marginSplitPercentageBase) {
                        split = split.mul(
                            state.order.marginSplitPercentage
                        ) / _marginSplitPercentageBase;
                    }
                    if (state.order.buyNoMoreThanAmountB) {
                        state.splitS = split;
                    } else {
                        state.splitB = split;
                    }
                    // This implicits order with smaller index in the ring will
                    // be paid LRC reward first, so the orders in the ring does
                    // mater.
                    if (split &amp;gt; 0) {
                        minerLrcSpendable -= state.lrcFee;
                        state.lrcReward = state.lrcFee;
                    }
                }
                state.lrcFee = 0;
            }
        }
    }
    /// @dev Calculate each order&amp;#39;s fill amount.
    function calculateRingFillAmount(
        uint          ringSize,
        OrderState[]  orders
        )
        private
        pure
    {
        uint smallestIdx = 0;
        uint i;
        uint j;
        for (i = 0; i &amp;lt; ringSize; i++) {
            j = (i + 1) % ringSize;
            smallestIdx = calculateOrderFillAmount(
                orders[i],
                orders[j],
                i,
                j,
                smallestIdx
            );
        }
        for (i = 0; i &amp;lt; smallestIdx; i++) {
            calculateOrderFillAmount(
                orders[i],
                orders[(i + 1) % ringSize],
                0,               // Not needed
                0,               // Not needed
                0                // Not needed
            );
        }
    }
    /// @return The smallest order&amp;#39;s index.
    function calculateOrderFillAmount(
        OrderState        state,
        OrderState        next,
        uint              i,
        uint              j,
        uint              smallestIdx
        )
        private
        pure
        returns (uint newSmallestIdx)
    {
        // Default to the same smallest index
        newSmallestIdx = smallestIdx;
        uint fillAmountB = state.fillAmountS.mul(
            state.rate.amountB
        ) / state.rate.amountS;
        if (state.order.buyNoMoreThanAmountB) {
            if (fillAmountB &amp;gt; state.order.amountB) {
                fillAmountB = state.order.amountB;
                state.fillAmountS = fillAmountB.mul(
                    state.rate.amountS
                ) / state.rate.amountB;
                newSmallestIdx = i;
            }
            state.lrcFee = state.order.lrcFee.mul(
                fillAmountB
            ) / state.order.amountB;
        } else {
            state.lrcFee = state.order.lrcFee.mul(
                state.fillAmountS
            ) / state.order.amountS;
        }
        if (fillAmountB &amp;lt;= next.fillAmountS) {
            next.fillAmountS = fillAmountB;
        } else {
            newSmallestIdx = j;
        }
    }
    /// @dev Scale down all orders based on historical fill or cancellation
    ///      stats but key the order&amp;#39;s original exchange rate.
    function scaleRingBasedOnHistoricalRecords(
        TokenTransferDelegate delegate,
        uint ringSize,
        OrderState[] orders
        )
        private
        view
    {
        for (uint i = 0; i &amp;lt; ringSize; i++) {
            OrderState memory state = orders[i];
            Order memory order = state.order;
            uint amount;
            if (order.buyNoMoreThanAmountB) {
                amount = order.amountB.tolerantSub(
                    cancelledOrFilled[state.orderHash]
                );
                order.amountS = amount.mul(order.amountS) / order.amountB;
                order.lrcFee = amount.mul(order.lrcFee) / order.amountB;
                order.amountB = amount;
            } else {
                amount = order.amountS.tolerantSub(
                    cancelledOrFilled[state.orderHash]
                );
                order.amountB = amount.mul(order.amountB) / order.amountS;
                order.lrcFee = amount.mul(order.lrcFee) / order.amountS;
                order.amountS = amount;
            }
            require(order.amountS &amp;gt; 0); // &amp;quot;amountS is zero&amp;quot;);
            require(order.amountB &amp;gt; 0); // &amp;quot;amountB is zero&amp;quot;);
            uint availableAmountS = getSpendable(delegate, order.tokenS, order.owner);
            require(availableAmountS &amp;gt; 0); // &amp;quot;order spendable amountS is zero&amp;quot;);
            state.fillAmountS = (
                order.amountS &amp;lt; availableAmountS ?
                order.amountS : availableAmountS
            );
        }
    }
    /// @return Amount of ERC20 token that can be spent by this contract.
    function getSpendable(
        TokenTransferDelegate delegate,
        address tokenAddress,
        address tokenOwner
        )
        private
        view
        returns (uint)
    {
        ERC20 token = ERC20(tokenAddress);
        uint allowance = token.allowance(
            tokenOwner,
            address(delegate)
        );
        uint balance = token.balanceOf(tokenOwner);
        return (allowance &amp;lt; balance ? allowance : balance);
    }
    /// @dev verify input data&amp;#39;s basic integrity.
    function verifyInputDataIntegrity(RingParams params)
        private
        pure
    {
        require(params.ringSize == params.addressList.length); // &amp;quot;ring data is inconsistent - addressList&amp;quot;);
        require(params.ringSize == params.uintArgsList.length); // &amp;quot;ring data is inconsistent - uintArgsList&amp;quot;);
        require(params.ringSize == params.uint8ArgsList.length); // &amp;quot;ring data is inconsistent - uint8ArgsList&amp;quot;);
        require(params.ringSize == params.buyNoMoreThanAmountBList.length); // &amp;quot;ring data is inconsistent - buyNoMoreThanAmountBList&amp;quot;);
        // Validate ring-mining related arguments.
        for (uint i = 0; i &amp;lt; params.ringSize; i++) {
            require(params.uintArgsList[i][5] &amp;gt; 0); // &amp;quot;order rateAmountS is zero&amp;quot;);
        }
        //Check ring size
        require(params.ringSize &amp;gt; 1 &amp;amp;&amp;amp; params.ringSize &amp;lt;= MAX_RING_SIZE); // &amp;quot;invalid ring size&amp;quot;);
    }
    /// @dev        assmble order parameters into Order struct.
    /// @return     A list of orders.
    function assembleOrders(RingParams params)
        private
        view
        returns (OrderState[] memory orders)
    {
        orders = new OrderState[](params.ringSize);
        for (uint i = 0; i &amp;lt; params.ringSize; i++) {
            Order memory order = Order(
                params.addressList[i][0],
                params.addressList[i][1],
                params.addressList[(i + 1) % params.ringSize][1],
                params.addressList[i][2],
                params.uintArgsList[i][2],
                params.uintArgsList[i][3],
                params.uintArgsList[i][0],
                params.uintArgsList[i][1],
                params.uintArgsList[i][4],
                params.buyNoMoreThanAmountBList[i],
                params.uintArgsList[i][6],
                params.uint8ArgsList[i][0]
            );
            validateOrder(order);
            bytes32 orderHash = calculateOrderHash(order);
            verifySignature(
                order.owner,
                orderHash,
                params.vList[i],
                params.rList[i],
                params.sList[i]
            );
            bool marginSplitAsFee = (params.feeSelections &amp;amp; (uint16(1) &amp;lt;&amp;lt; i)) &amp;gt; 0;
            orders[i] = OrderState(
                order,
                orderHash,
                marginSplitAsFee,
                Rate(params.uintArgsList[i][5], order.amountB),
                0,   // fillAmountS
                0,   // lrcReward
                0,   // lrcFee
                0,   // splitS
                0    // splitB
            );
            params.ringHash ^= orderHash;
        }
        params.ringHash = keccak256(
            params.ringHash,
            params.minerId,
            params.feeSelections
        );
    }
    /// @dev validate order&amp;#39;s parameters are OK.
    function validateOrder(Order order)
        private
        view
    {
        require(order.owner != 0x0); // invalid order owner
        require(order.tokenS != 0x0); // invalid order tokenS
        require(order.tokenB != 0x0); // invalid order tokenB
        require(order.amountS != 0); // invalid order amountS
        require(order.amountB != 0); // invalid order amountB
        require(order.marginSplitPercentage &amp;lt;= MARGIN_SPLIT_PERCENTAGE_BASE); // invalid order marginSplitPercentage
        require(order.validSince &amp;lt;= block.timestamp); // order is too early to match
        require(order.validUntil &amp;gt; block.timestamp); // order is expired
        bytes20 tradingPair = bytes20(order.tokenS) ^ bytes20(order.tokenB);
        require(order.validSince &amp;gt; tradingPairCutoffs[order.owner][tradingPair]); // order trading pair is cut off
        require(order.validSince &amp;gt; cutoffs[order.owner]); // order is cut off
    }
    /// @dev Get the Keccak-256 hash of order with specified parameters.
    function calculateOrderHash(Order order)
        private
        view
        returns (bytes32)
    {
        return keccak256(
            address(this),
            order.owner,
            order.tokenS,
            order.tokenB,
            order.authAddr,
            order.amountS,
            order.amountB,
            order.validSince,
            order.validUntil,
            order.lrcFee,
            order.buyNoMoreThanAmountB,
            order.walletId,
            order.marginSplitPercentage
        );
    }
    /// @dev Verify signer&amp;#39;s signature.
    function verifySignature(
        address signer,
        bytes32 hash,
        uint8   v,
        bytes32 r,
        bytes32 s
        )
        private
        pure
    {
        require(
            signer == ecrecover(
                keccak256(&amp;quot;\x19Ethereum Signed Message:\n32&amp;quot;, hash),
                v,
                r,
                s
            )
        ); // &amp;quot;invalid signature&amp;quot;);
    }
    function getTradingPairCutoffs(address orderOwner, address token1, address token2)
        public
        view
        returns (uint)
    {
        bytes20 tokenPair = bytes20(token1) ^ bytes20(token2);
        return tradingPairCutoffs[orderOwner][tokenPair];
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x729c2bAC7fFEf4330607e49C67364C28E8515c9d.sol" target="_blank" title="show github file">0x729c2bAC7fFEf4330607e49C67364C28E8515c9d.sol</a>
        </div>
        <div class="path">solidity-files/0x729c2bAC7fFEf4330607e49C67364C28E8515c9d.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

/*
100tokens.com Smart Contract Crowdsale
*/

// File: zeppelin-solidity/contracts/math/SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

// File: zeppelin-solidity/contracts/ownership/Ownable.sol

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

// File: zeppelin-solidity/contracts/token/ERC20Basic.sol

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

// File: zeppelin-solidity/contracts/token/BasicToken.sol

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address =&amp;gt; uint256) balances;

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}

// File: zeppelin-solidity/contracts/token/ERC20.sol

/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: zeppelin-solidity/contracts/token/StandardToken.sol

/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

  mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[_from]);
    require(_value &amp;lt;= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue &amp;gt; oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}

// File: zeppelin-solidity/contracts/token/MintableToken.sol

/**
 * @title Mintable token
 * @dev Simple ERC20 Token example, with mintable token creation
 * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
 */

contract MintableToken is StandardToken, Ownable {
  event Mint(address indexed to, uint256 amount);
  event MintFinished();

  bool public mintingFinished = false;


  modifier canMint() {
    require(!mintingFinished);
    _;
  }

  /**
   * @dev Function to mint tokens
   * @param _to The address that will receive the minted tokens.
   * @param _amount The amount of tokens to mint.
   * @return A boolean that indicates if the operation was successful.
   */
  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    Transfer(address(0), _to, _amount);
    return true;
  }

  /**
   * @dev Function to stop minting new tokens.
   * @return True if the operation was successful.
   */
  function finishMinting() onlyOwner canMint public returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
}

// File: zeppelin-solidity/contracts/crowdsale/Crowdsale.sol

/**
 * @title Crowdsale
 * @dev Crowdsale is a base contract for managing a token crowdsale.
 * Crowdsales have a start and end timestamps, where investors can make
 * token purchases and the crowdsale will assign them tokens based
 * on a token per ETH rate. Funds collected are forwarded to a wallet
 * as they arrive.
 */
contract Crowdsale {
  using SafeMath for uint256;

  // The token being sold
  MintableToken public token;

  // start and end timestamps where investments are allowed (both inclusive)
  uint256 public startTime;
  uint256 public endTime;

  // address where funds are collected
  address public wallet;

  // how many token units a buyer gets per wei
  uint256 public rate;

  // amount of raised money in wei
  uint256 public weiRaised;

  /**
   * event for token purchase logging
   * @param purchaser who paid for the tokens
   * @param beneficiary who got the tokens
   * @param value weis paid for purchase
   * @param amount amount of tokens purchased
   */
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime &amp;gt;= now);
    require(_endTime &amp;gt;= _startTime);
    require(_rate &amp;gt; 0);
    require(_wallet != address(0));

    token = createTokenContract();
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }

  // creates the token to be sold.
  // override this method to have crowdsale of a specific mintable token.
  function createTokenContract() internal returns (MintableToken) {
    return new MintableToken();
  }


  // fallback function can be used to buy tokens
  function () external payable {
    buyTokens(msg.sender);
  }

  // low level token purchase function
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    // calculate token amount to be created
    uint256 tokens = weiAmount.mul(rate);

    // update state
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  // send ether to the fund collection wallet
  // override to create custom fund forwarding mechanisms
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  // @return true if the transaction can buy tokens
  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now &amp;gt;= startTime &amp;amp;&amp;amp; now &amp;lt;= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod &amp;amp;&amp;amp; nonZeroPurchase;
  }

  // @return true if crowdsale event has ended
  function hasEnded() public view returns (bool) {
    return now &amp;gt; endTime;
  }


}


contract OHC_CrowdsaleToken is MintableToken {
  string public constant name = &amp;quot;One Hundred Coin&amp;quot;;
  string public constant symbol = &amp;quot;OHC&amp;quot;;
  uint8 public constant decimals = 18;

  // overriding BasicToken#transfer
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[msg.sender]);
    require(now &amp;gt;= 1521795600);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  event Burn(address indexed burner, uint256 value);

  function burn(address _burner, uint256 _value) onlyOwner public {
    require(_value &amp;lt;= balances[_burner]);

    balances[_burner] = balances[_burner].sub(_value);
    totalSupply = totalSupply.sub(_value);
    Burn(_burner, _value);
    Transfer(_burner, address(0), _value);
  }

}

contract OHC_Crowdsale is Crowdsale, Ownable {

  uint256 constant CAP =  1000000000000000000000000000;
  uint256 constant CAP_PRE_SALE = 200000000000000000000000000;
  uint256 constant CAP_ICO_SALE = 400000000000000000000000000;

  uint256 constant RATE1 = 70000;
  uint256 constant RATE2 = 65000;
  uint256 constant RATE3 = 60000;
  uint256 constant RATE4 = 55000;
  uint256 constant RATE5 = 35000;
  uint256 constant RATE6 = 30000;
  uint256 constant RATE7 = 25000;
  uint256 constant RATE8 = 20000;

  uint256 public totalSupplyIco;

  function OHC_Crowdsale (
    uint256 _startTime,
    uint256 _endTime,
    uint256 _rate,
    address _wallet
  ) public
    Crowdsale(_startTime, _endTime, _rate, _wallet)
  {

  }

  function createTokenContract() internal returns (MintableToken) {
    return new OHC_CrowdsaleToken();
  }

  // overriding Crowdsale#validPurchase
  function validPurchase() internal constant returns (bool) {
    if (msg.value &amp;lt; 20000000000000000) {
      return false;
    }

    if (token.totalSupply().add(msg.value.mul(getRate())) &amp;gt;= CAP) {
      return false;
    }

    if (now &amp;gt; 1525939200 &amp;amp;&amp;amp; now &amp;lt; 1539158400) {
      return false;
    }

    if (1523347200 &amp;gt;= now &amp;amp;&amp;amp; 1525939200 &amp;lt;= now) {
      if (token.totalSupply().add(msg.value.mul(getRate())) &amp;gt;= CAP_PRE_SALE) {
        return false;
      }
    }

    if (1539158400 &amp;gt;= now &amp;amp;&amp;amp; 1541840400 &amp;lt;= now) {
      if (totalSupplyIco.add(msg.value.mul(getRate())) &amp;gt;= CAP_ICO_SALE) {
        return false;
      }
    }

    if (getRate() == 0) {
      return false;
    }

    return super.validPurchase();
  }

  function buyTokens(address beneficiary) payable public {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;
    uint256 tokens = weiAmount.mul(getRate());
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  function getRate() public constant returns (uint256) {
    if (1523347200 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1523952000) {
      return RATE1;
    }

    if (1523952001 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1524556800) {
      return RATE2;
    }

    if (1524556805 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1525161600) {
      return RATE3;
    }

    if (1525161601 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1525939200) {
      return RATE4;
    }

    if (1539158400 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1539763200) {
      return RATE5;
    }

    if (1539763201 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1540368000) {
      return RATE6;
    }

    if (1540368001 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1540976400) {
      return RATE7;
    }

    if (1540976401 &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt;= 1541840400) {
      return RATE8;
    }

    return 0;
  }

  function mintTokens(address walletToMint, uint256 t) onlyOwner payable public {
    require(token.totalSupply().add(t) &amp;lt; CAP);

    token.mint(walletToMint, t);
  }

  function tokenTransferOwnership(address newOwner) onlyOwner payable public {
    token.transferOwnership(newOwner);
  }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x6917d70f5622da6b4e88681892444ffdd552df5f.sol" target="_blank" title="show github file">0x6917d70f5622da6b4e88681892444ffdd552df5f.sol</a>
        </div>
        <div class="path">solidity-files/0x6917d70f5622da6b4e88681892444ffdd552df5f.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

/**
 * @title ERC20 Basic smart contract
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;1578747b6070797467747a6f557278747c793b767a78&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @author modification: Dmitriy Khizhinskiy @McFly.aero
 */
contract ERC20Basic {
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

/**
 * @title LengthValidator smart contract - fix ERC20 short address attack
 * @author Copyright (c) 2018 McFly.aero
 * @author Dmitriy Khizhinskiy
 * @author &amp;quot;MIT&amp;quot;
 */
contract LengthValidator {
    modifier valid_short(uint _cntArgs) {
        assert(msg.data.length == (_cntArgs * 32 + 4));
        _;
    }
}

/**
 * @title Ownable smart contract
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;9bf6faf5eefef7fae9faf4e1dbfcf6faf2f7b5f8f4f6&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @author modification: Dmitriy Khizhinskiy @McFly.aero
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
    address public owner;
    address public candidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
    * account.
    */
    function Ownable() public {
        owner = msg.sender;
    }


    /**
    * @dev Throws if called by any account other than the owner.
    */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }


    /**
    * @dev Allows the current owner to _request_ transfer control of the contract to a newOwner.
    * @param newOwner The address to transfer ownership to.
    */
    function requestOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        candidate = newOwner;
    }


    /**
    * @dev Allows the _NEW_ candidate to complete transfer control of the contract to him.
    */
    function confirmOwnership() public {
        require(candidate == msg.sender);
        owner = candidate;
        OwnershipTransferred(owner, candidate);        
    }
}


/**
 * @title MultiOwners smart contract
 * @author Copyright (c) 2018 McFly.aero
 * @author Dmitriy Khizhinskiy
 * @author &amp;quot;MIT&amp;quot;
 */
contract MultiOwners {

    event AccessGrant(address indexed owner);
    event AccessRevoke(address indexed owner);
    
    mapping(address =&amp;gt; bool) owners;
    address public publisher;


    function MultiOwners() public {
        owners[msg.sender] = true;
        publisher = msg.sender;
    }


    modifier onlyOwner() { 
        require(owners[msg.sender] == true);
        _; 
    }


    function isOwner() constant public returns (bool) {
        return owners[msg.sender] ? true : false;
    }


    function checkOwner(address maybe_owner) constant public returns (bool) {
        return owners[maybe_owner] ? true : false;
    }


    function grant(address _owner) onlyOwner public {
        owners[_owner] = true;
        AccessGrant(_owner);
    }


    function revoke(address _owner) onlyOwner public {
        require(_owner != publisher);
        require(msg.sender != _owner);

        owners[_owner] = false;
        AccessRevoke(_owner);
    }
}




/**
 * @title SafeMath
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;731e121d06161f1201121c0933141e121a1f5d101c1e&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    /**
    * @dev Multiplies two numbers, throws on overflow.
    */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }


    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
        return c;
    }


    /**
    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b &amp;lt;= a);
        return a - b;
    }


    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c &amp;gt;= a);
        return c;
    }
}











/**
 * @title BasicToken smart contract
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;96fbf7f8e3f3faf7e4f7f9ecd6f1fbf7fffab8f5f9fb&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @author modification: Dmitriy Khizhinskiy @McFly.aero
 */






/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic, LengthValidator {
    using SafeMath for uint256;

    mapping(address =&amp;gt; uint256) balances;

    uint256 totalSupply_;

    /**
    * @dev total number of tokens in existence
    */
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }


    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) valid_short(2) public returns (bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }


    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

}


/**
 * @title ERC20 smart contract
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;5a373b342f3f363b283b35201a3d373b333674393537&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @author modification: Dmitriy Khizhinskiy @McFly.aero
 */




/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

/**
 * @title Standard ERC20 token
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;1479757a6171787566757b6e547379757d783a777b79&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @author modification: Dmitriy Khizhinskiy @McFly.aero
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;
  
    /** 
    * @dev Transfer tokens from one address to another
    * @param _from address The address which you want to send tokens from
    * @param _to address The address which you want to transfer to
    * @param _value uint256 the amount of tokens to be transferred
    */
    function transferFrom(address _from, address _to, uint256 _value) valid_short(3) public returns (bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[_from]);
        require(_value &amp;lt;= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }


    /**
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    *
    * Beware that changing an allowance with this method brings the risk that someone may use both the old
    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
    * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    * @param _spender The address which will spend the funds.
    * @param _value The amount of tokens to be spent.
    */
    function approve(address _spender, uint256 _value) valid_short(2) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }


    /**
    * @dev Function to check the amount of tokens that an owner allowed to a spender.
    * @param _owner address The address which owns the funds.
    * @param _spender address The address which will spend the funds.
    * @return A uint256 specifying the amount of tokens still available for the spender.
    */
    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }


    /**
    * @dev Increase the amount of tokens that an owner allowed to a spender.
    *
    * approve should be called when allowed[_spender] == 0. To increment
    * allowed value is better to use this function to avoid 2 calls (and wait until
    * the first transaction is mined)
    * From MonolithDAO Token.sol
    * @param _spender The address which will spend the funds.
    * @param _addedValue The amount of tokens to increase the allowance by.
    */
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }


    /**
    * @dev Decrease the amount of tokens that an owner allowed to a spender.
    *
    * approve should be called when allowed[_spender] == 0. To decrement
    * allowed value is better to use this function to avoid 2 calls (and wait until
    * the first transaction is mined)
    * From MonolithDAO Token.sol
    * @param _spender The address which will spend the funds.
    * @param _subtractedValue The amount of tokens to decrease the allowance by.
    */
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue &amp;gt; oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}


/**
 * @title Mintable token smart contract
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author &amp;quot;Manuel Araoz &amp;lt;&lt;a href=&quot;/cdn-cgi/l/email-protection&quot; class=&quot;__cf_email__&quot; data-cfemail=&quot;a2cfc3ccd7c7cec3d0c3cdd8e2c5cfc3cbce8cc1cdcf&quot;&gt;[email&amp;#160;protected]&lt;/a&gt;&amp;gt;&amp;quot;
 * @dev license: &amp;quot;MIT&amp;quot;, source: https://github.com/OpenZeppelin/zeppelin-solidity
 * @author modification: Dmitriy Khizhinskiy @McFly.aero
 * @dev Simple ERC20 Token example, with mintable token creation
 * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
 */
contract MintableToken is StandardToken, Ownable {
    event Mint(address indexed to, uint256 amount);
    event MintFinished();

    bool public mintingFinished = false;

    modifier canMint() {
        require(!mintingFinished);
        _;
    }


    /**
    * @dev Function to mint tokens
    * @param _to The address that will receive the minted tokens.
    * @param _amount The amount of tokens to mint.
    * @return A boolean that indicates if the operation was successful.
    */
    function mint(address _to, uint256 _amount) onlyOwner canMint valid_short(2) public returns (bool) {
        totalSupply_ = totalSupply_.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        Mint(_to, _amount);
        Transfer(address(0), _to, _amount);
        return true;
    }


    /**
    * @dev Function to stop minting new tokens.
    * @return True if the operation was successful.
    */
    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        MintFinished();
        return true;
    }
}


/**
 * @title McFly token smart contract
 * @author Copyright (c) 2018 McFly.aero
 * @author Dmitriy Khizhinskiy
 * @author &amp;quot;MIT&amp;quot;
 */
contract McFlyToken is MintableToken {
    string public constant name = &amp;quot;McFlyToken&amp;quot;;
    string public constant symbol = &amp;quot;McFly&amp;quot;;
    uint8 public constant decimals = 18;

    /// @dev mapping for whitelist
    mapping(address=&amp;gt;bool) whitelist;

    /// @dev event throw when allowed to transfer address added to whitelist
    /// @param from address
    event AllowTransfer(address from);

    /// @dev check for allowence of transfer
    modifier canTransfer() {
        require(mintingFinished || whitelist[msg.sender]);
        _;        
    }

    /// @dev add address to whitelist
    /// @param from address to add
    function allowTransfer(address from) onlyOwner public {
        whitelist[from] = true;
        AllowTransfer(from);
    }

    /// @dev Do the transfer from address to address value
    /// @param from address from
    /// @param to address to
    /// @param value uint256
    function transferFrom(address from, address to, uint256 value) canTransfer public returns (bool) {
        return super.transferFrom(from, to, value);
    }

    /// @dev Do the transfer from token address to &amp;quot;to&amp;quot; address value
    /// @param to address to
    /// @param value uint256 value
    function transfer(address to, uint256 value) canTransfer public returns (bool) {
        return super.transfer(to, value);
    }
}







/**
 * @title Haltable smart contract - controls owner access
 * @author Copyright (c) 2018 McFly.aero
 * @author Dmitriy Khizhinskiy
 * @author &amp;quot;MIT&amp;quot;
 */
contract Haltable is MultiOwners {
    bool public halted;

    modifier stopInEmergency {
        require(!halted);
        _;
    }


    modifier onlyInEmergency {
        require(halted);
        _;
    }


    /// @dev called by the owner on emergency, triggers stopped state
    function halt() external onlyOwner {
        halted = true;
    }


    /// @dev called by the owner on end of emergency, returns to normal state
    function unhalt() external onlyOwner onlyInEmergency {
        halted = false;
    }

}



/**
 * @title McFly crowdsale smart contract
 * @author Copyright (c) 2018 McFly.aero
 * @author Dmitriy Khizhinskiy
 * @author &amp;quot;MIT&amp;quot;
 * @dev inherited from MultiOwners &amp;amp; Haltable
 */
contract McFlyCrowd is MultiOwners, Haltable {
    using SafeMath for uint256;

    /// @dev Total ETH received during WAVES, TLP1.2 &amp;amp; window[1-5]
    uint256 public counter_in; // tlp2
    
    /// @dev minimum ETH to partisipate in window 1-5
    uint256 public minETHin = 1e18; // 1 ETH

    /// @dev Token
    McFlyToken public token;

    /// @dev Withdraw wallet
    address public wallet;

    /// @dev start and end timestamp for TLP 1.2, other values callculated
    uint256 public sT2; // startTimeTLP2
    uint256 constant dTLP2 = 118 days; // days of TLP2
    uint256 constant dBt = 60 days; // days between Windows
    uint256 constant dW = 12 days; // 12 days for 3,4,5,6,7 windows;

    /// @dev Cap maximum possible tokens for minting
    uint256 public constant hardCapInTokens = 1800e24; // 1,800,000,000 MFL

    /// @dev maximum possible tokens for sell 
    uint256 public constant mintCapInTokens = 1260e24; // 1,260,000,000 MFL

    /// @dev tokens crowd within TLP2
    uint256 public crowdTokensTLP2;

    /// @dev tokens crowd before this contract (MFL tokens)
    uint256 preMcFlyTotalSupply;

    /// @dev maximum possible tokens for fund minting
    uint256 constant fundTokens = 270e24; // 270,000,000 MFL
    uint256 public fundTotalSupply;
    address public fundMintingAgent;
                                                          
    /// @dev maximum possible tokens to convert from WAVES
    uint256 wavesTokens = 100e24; // 100,000,000 MFL
    address public wavesAgent;
    address public wavesGW;

    /// @dev Vesting param for team, advisory, reserve.
    uint256 VestingPeriodInSeconds = 30 days; // 24 month
    uint256 VestingPeriodsCount = 24;

    /// @dev Team 10%
    uint256 _teamTokens;
    uint256 public teamTotalSupply;
    address public teamWallet;

    /// @dev Bounty 5% (2% + 3%)
    /// @dev Bounty online 2%
    uint256 _bountyOnlineTokens;
    address public bountyOnlineWallet;
    address public bountyOnlineGW;

    /// @dev Bounty offline 3%
    uint256 _bountyOfflineTokens;
    address public bountyOfflineWallet;

    /// @dev Advisory 5%
    uint256 _advisoryTokens;
    uint256 public advisoryTotalSupply;
    address public advisoryWallet;

    /// @dev Reserved for future 9%
    uint256 _reservedTokens;
    uint256 public reservedTotalSupply;
    address public reservedWallet;

    /// @dev AirDrop 1%
    uint256 _airdropTokens;
    address public airdropWallet;
    address public airdropGW;

    /// @dev PreMcFly wallet (MFL)
    uint256 _preMcFlyTokens;
    address public preMcFlyWallet;

    /// @dev Ppl structure for Win1-5
    struct Ppl {
        address addr;
        uint256 amount;
    }
    mapping (uint32 =&amp;gt; Ppl) public ppls;

    /// @dev Window structure for Win1-5
    struct Window {
        bool active;
        uint256 totalEthInWindow;
        uint32 totalTransCnt;
        uint32 refundIndex;
        uint256 tokenPerWindow;
    } 
    mapping (uint8 =&amp;gt; Window) public ww;


    /// @dev Events
    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
    event TokenPurchaseInWindow(address indexed beneficiary, uint256 value, uint8 winnum, uint32 totalcnt, uint256 totaleth1);
    event TransferOddEther(address indexed beneficiary, uint256 value);
    event FundMinting(address indexed beneficiary, uint256 value);
    event WithdrawVesting(address indexed beneficiary, uint256 period, uint256 value, uint256 valueTotal);
    event TokenWithdrawAtWindow(address indexed beneficiary, uint256 value);
    event SetFundMintingAgent(address newAgent);
    event SetTeamWallet(address newTeamWallet);
    event SetAdvisoryWallet(address newAdvisoryWallet);
    event SetReservedWallet(address newReservedWallet);
    event SetStartTimeTLP2(uint256 newStartTimeTLP2);
    event SetMinETHincome(uint256 newMinETHin);
    event NewWindow(uint8 winNum, uint256 amountTokensPerWin);
    event TokenETH(uint256 totalEth, uint32 totalCnt);


    /// @dev check for Non zero value
    modifier validPurchase() {
        bool nonZeroPurchase = msg.value != 0;
        require(nonZeroPurchase);
        _;        
    }

    // comment this functions after test passed !!
    /*function getPpls(uint32 index) constant public returns (uint256) {
        return (ppls[index].amount);
    }
    function getPplsAddr(uint32 index) constant public returns (address) {
        return (ppls[index].addr);
    }
    function getWtotalEth(uint8 winNum) constant public returns (uint256) {
        return (ww[winNum].totalEthInWindow);
    }
    function getWtoken(uint8 winNum) constant public returns (uint256) {
        return (ww[winNum].tokenPerWindow);
    }
    function getWactive(uint8 winNum) constant public returns (bool) {
        return (ww[winNum].active);
    }
    function getWtotalTransCnt(uint8 winNum) constant public returns (uint32) {
        return (ww[winNum].totalTransCnt);
    }
    function getWrefundIndex(uint8 winNum) constant public returns (uint32) {
        return (ww[winNum].refundIndex);
    }*/
    // END comment this functions after test passed !!


    /**
     * @dev conctructor of contract, set main params, create new token, do minting for some wallets
     * @param _startTimeTLP2 - set date time of starting of TLP2 (main date!)
     * @param _preMcFlyTotalSupply - set amount in wei total supply of previouse contract (MFL)
     * @param _wallet - wallet for transfer ETH to it
     * @param _wavesAgent - wallet for WAVES gw
     * @param _wavesGW    - wallet for WAVES gw
     * @param _fundMintingAgent - wallet who allowed to mint before TLP2
     * @param _teamWallet - wallet for team vesting
     * @param _bountyOnlineWallet - wallet for online bounty
     * @param _bountyOnlineGW - wallet for online bounty GW
     * @param _bountyOfflineWallet - wallet for offline bounty
     * @param _advisoryWallet - wallet for advisory vesting
     * @param _reservedWallet - wallet for reserved vesting
     * @param _airdropWallet - wallet for airdrop
     * @param _airdropGW - wallet for airdrop GW
     * @param _preMcFlyWallet - wallet for transfer old MFL-&amp;gt;McFly (once)
     */
    function McFlyCrowd(
        uint256 _startTimeTLP2,
        uint256 _preMcFlyTotalSupply,
        address _wallet,
        address _wavesAgent,
        address _wavesGW,
        address _fundMintingAgent,
        address _teamWallet,
        address _bountyOnlineWallet,
        address _bountyOnlineGW,
        address _bountyOfflineWallet,
        address _advisoryWallet,
        address _reservedWallet,
        address _airdropWallet,
        address _airdropGW,
        address _preMcFlyWallet
    ) public 
    {   
        require(_startTimeTLP2 &amp;gt;= block.timestamp);
        require(_preMcFlyTotalSupply &amp;gt; 0);
        require(_wallet != 0x0);
        require(_wavesAgent != 0x0);
        require(_wavesGW != 0x0);
        require(_fundMintingAgent != 0x0);
        require(_teamWallet != 0x0);
        require(_bountyOnlineWallet != 0x0);
        require(_bountyOnlineGW != 0x0);
        require(_bountyOfflineWallet != 0x0);
        require(_advisoryWallet != 0x0);
        require(_reservedWallet != 0x0);
        require(_airdropWallet != 0x0);
        require(_airdropGW != 0x0);
        require(_preMcFlyWallet != 0x0);

        token = new McFlyToken();

        wallet = _wallet;

        sT2 = _startTimeTLP2;
        setStartEndTimeTLP(_startTimeTLP2);

        wavesAgent = _wavesAgent;
        wavesGW = _wavesGW;

        fundMintingAgent = _fundMintingAgent;

        teamWallet = _teamWallet;
        bountyOnlineWallet = _bountyOnlineWallet;
        bountyOnlineGW = _bountyOnlineGW;
        bountyOfflineWallet = _bountyOfflineWallet;
        advisoryWallet = _advisoryWallet;
        reservedWallet = _reservedWallet;
        airdropWallet = _airdropWallet;
        airdropGW = _airdropGW;
        preMcFlyWallet = _preMcFlyWallet;

        /// @dev Mint all tokens and than control it by vesting
        _preMcFlyTokens = _preMcFlyTotalSupply; // McFly for thansfer to old MFL owners
        token.mint(preMcFlyWallet, _preMcFlyTokens);
        token.allowTransfer(preMcFlyWallet);
        crowdTokensTLP2 = crowdTokensTLP2.add(_preMcFlyTokens);

        token.mint(wavesAgent, wavesTokens); // 100,000,000 MFL
        token.allowTransfer(wavesAgent);
        token.allowTransfer(wavesGW);
        crowdTokensTLP2 = crowdTokensTLP2.add(wavesTokens);

        _teamTokens = 180e24; // 180,000,000 MFL
        token.mint(this, _teamTokens); // mint to contract address

        _bountyOnlineTokens = 36e24; // 36,000,000 MFL
        token.mint(bountyOnlineWallet, _bountyOnlineTokens);
        token.allowTransfer(bountyOnlineWallet);
        token.allowTransfer(bountyOnlineGW);

        _bountyOfflineTokens = 54e24; // 54,000,000 MFL
        token.mint(bountyOfflineWallet, _bountyOfflineTokens);
        token.allowTransfer(bountyOfflineWallet);

        _advisoryTokens = 90e24; // 90,000,000 MFL
        token.mint(this, _advisoryTokens);

        _reservedTokens = 162e24; // 162,000,000 MFL
        token.mint(this, _reservedTokens);

        _airdropTokens = 18e24; // 18,000,000 MFL
        token.mint(airdropWallet, _airdropTokens);
        token.allowTransfer(airdropWallet);
        token.allowTransfer(airdropGW);
    }


    /**
     * @dev check is TLP2 is active?
     * @return false if crowd TLP2 event was ended
     */
    function withinPeriod() constant public returns (bool) {
        bool withinPeriodTLP2 = (now &amp;gt;= sT2 &amp;amp;&amp;amp; now &amp;lt;= (sT2+dTLP2));
        return withinPeriodTLP2;
    }


    /**
     * @dev check is TLP2 is active and minting Not finished
     * @return false if crowd event was ended
     */
    function running() constant public returns (bool) {
        return withinPeriod() &amp;amp;&amp;amp; !token.mintingFinished();
    }


    /**
     * @dev check current stage name
     * @return uint8 stage number
     */
    function stageName() constant public returns (uint8) {
        uint256 eT2 = sT2+dTLP2;

        if (now &amp;lt; sT2) {return 101;} // not started
        if (now &amp;gt;= sT2 &amp;amp;&amp;amp; now &amp;lt;= eT2) {return (102);} // TLP1.2

        if (now &amp;gt; eT2 &amp;amp;&amp;amp; now &amp;lt; eT2+dBt) {return (103);} // preTLP1.3
        if (now &amp;gt;= (eT2+dBt) &amp;amp;&amp;amp; now &amp;lt;= (eT2+dBt+dW)) {return (0);} // TLP1.3
        if (now &amp;gt; (eT2+dBt+dW) &amp;amp;&amp;amp; now &amp;lt; (eT2+dBt+dW+dBt)) {return (104);} // preTLP1.4
        if (now &amp;gt;= (eT2+dBt+dW+dBt) &amp;amp;&amp;amp; now &amp;lt;= (eT2+dBt+dW+dBt+dW)) {return (1);} // TLP1.4
        if (now &amp;gt; (eT2+dBt+dW+dBt+dW) &amp;amp;&amp;amp; now &amp;lt; (eT2+dBt+dW+dBt+dW+dBt)) {return (105);} // preTLP1.5
        if (now &amp;gt;= (eT2+dBt+dW+dBt+dW+dBt) &amp;amp;&amp;amp; now &amp;lt;= (eT2+dBt+dW+dBt+dW+dBt+dW)) {return (2);} // TLP1.5
        if (now &amp;gt; (eT2+dBt+dW+dBt+dW+dBt+dW) &amp;amp;&amp;amp; now &amp;lt; (eT2+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (106);} // preTLP1.6
        if (now &amp;gt;= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt) &amp;amp;&amp;amp; now &amp;lt;= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (3);} // TLP1.6
        if (now &amp;gt; (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW) &amp;amp;&amp;amp; now &amp;lt; (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (107);} // preTLP1.7
        if (now &amp;gt;= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt) &amp;amp;&amp;amp; now &amp;lt;= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (4);} // TLP1.7&amp;quot;
        if (now &amp;gt; (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (200);} // Finished
        return (201); // unknown
    }


    /** 
     * @dev change agent for minting
     * @param agent - new agent address
     */
    function setFundMintingAgent(address agent) onlyOwner public {
        fundMintingAgent = agent;
        SetFundMintingAgent(agent);
    }


    /** 
     * @dev change wallet for team vesting (this make possible to set smart-contract address later)
     * @param _newTeamWallet - new wallet address
     */
    function setTeamWallet(address _newTeamWallet) onlyOwner public {
        teamWallet = _newTeamWallet;
        SetTeamWallet(_newTeamWallet);
    }


    /** 
     * @dev change wallet for advisory vesting (this make possible to set smart-contract address later)
     * @param _newAdvisoryWallet - new wallet address
     */
    function setAdvisoryWallet(address _newAdvisoryWallet) onlyOwner public {
        advisoryWallet = _newAdvisoryWallet;
        SetAdvisoryWallet(_newAdvisoryWallet);
    }


    /** 
     * @dev change wallet for reserved vesting (this make possible to set smart-contract address later)
     * @param _newReservedWallet - new wallet address
     */
    function setReservedWallet(address _newReservedWallet) onlyOwner public {
        reservedWallet = _newReservedWallet;
        SetReservedWallet(_newReservedWallet);
    }


    /**
     * @dev change min ETH income during Window1-5
     * @param _minETHin - new limit
     */
    function setMinETHin(uint256 _minETHin) onlyOwner public {
        minETHin = _minETHin;
        SetMinETHincome(_minETHin);
    }


    /**
     * @dev set TLP1.X (2-7) start &amp;amp; end dates
     * @param _at - new or old start date
     */
    function setStartEndTimeTLP(uint256 _at) onlyOwner public {
        require(block.timestamp &amp;lt; sT2); // forbid change time when TLP1.2 is active
        require(block.timestamp &amp;lt; _at); // should be great than current block timestamp

        sT2 = _at;
        SetStartTimeTLP2(_at);
    }


    /**
     * @dev Large Token Holder minting 
     * @param to - mint to address
     * @param amount - how much mint
     */
    function fundMinting(address to, uint256 amount) stopInEmergency public {
        require(msg.sender == fundMintingAgent || isOwner());
        require(block.timestamp &amp;lt; sT2);
        require(fundTotalSupply + amount &amp;lt;= fundTokens);
        require(token.totalSupply() + amount &amp;lt;= hardCapInTokens);

        fundTotalSupply = fundTotalSupply.add(amount);
        token.mint(to, amount);
        FundMinting(to, amount);
    }


    /**
     * @dev calculate amount
     * @param  amount - ether to be converted to tokens
     * @param  at - current time
     * @param  _totalSupply - total supplied tokens
     * @return tokens amount that we should send to our dear ppl
     * @return odd ethers amount, which contract should send back
     */
    function calcAmountAt(
        uint256 amount,
        uint256 at,
        uint256 _totalSupply
    ) public constant returns (uint256, uint256) 
    {
        uint256 estimate;
        uint256 price;
        
        if (at &amp;gt;= sT2 &amp;amp;&amp;amp; at &amp;lt;= (sT2+dTLP2)) {
            if (at &amp;lt;= sT2 + 15 days) {price = 12e13;} else if (at &amp;lt;= sT2 + 30 days) {
                price = 14e13;} else if (at &amp;lt;= sT2 + 45 days) {
                    price = 16e13;} else if (at &amp;lt;= sT2 + 60 days) {
                        price = 18e13;} else if (at &amp;lt;= sT2 + 75 days) {
                            price = 20e13;} else if (at &amp;lt;= sT2 + 90 days) {
                                price = 22e13;} else if (at &amp;lt;= sT2 + 105 days) {
                                    price = 24e13;} else if (at &amp;lt;= sT2 + 118 days) {
                                        price = 26e13;} else {revert();}
        } else {revert();}

        estimate = _totalSupply.add(amount.mul(1e18).div(price));

        if (estimate &amp;gt; hardCapInTokens) {
            return (
                hardCapInTokens.sub(_totalSupply),
                estimate.sub(hardCapInTokens).mul(price).div(1e18)
            );
        }
        return (estimate.sub(_totalSupply), 0);
    }


    /**
     * @dev fallback for processing ether
     */
    function() payable public {
        return getTokens(msg.sender);
    }


    /**
     * @dev sell token and send to contributor address
     * @param contributor address
     */
    function getTokens(address contributor) payable stopInEmergency validPurchase public {
        uint256 amount;
        uint256 oddEthers;
        uint256 ethers;
        uint256 _at;
        uint8 _winNum;

        _at = block.timestamp;

        require(contributor != 0x0);
       
        if (withinPeriod()) {
        
            (amount, oddEthers) = calcAmountAt(msg.value, _at, token.totalSupply());  // recheck!!!
  
            require(amount + token.totalSupply() &amp;lt;= hardCapInTokens);

            ethers = msg.value.sub(oddEthers);

            token.mint(contributor, amount); // fail if minting is finished
            TokenPurchase(contributor, ethers, amount);
            counter_in = counter_in.add(ethers);
            crowdTokensTLP2 = crowdTokensTLP2.add(amount);

            if (oddEthers &amp;gt; 0) {
                require(oddEthers &amp;lt; msg.value);
                contributor.transfer(oddEthers);
                TransferOddEther(contributor, oddEthers);
            }

            wallet.transfer(ethers);
        } else {
            require(msg.value &amp;gt;= minETHin); // checks min ETH income
            _winNum = stageName();
            require(_winNum &amp;gt;= 0 &amp;amp;&amp;amp; _winNum &amp;lt; 5);
            Window storage w = ww[_winNum];

            require(w.tokenPerWindow &amp;gt; 0); // check that we have tokens!

            w.totalEthInWindow = w.totalEthInWindow.add(msg.value);
            ppls[w.totalTransCnt].addr = contributor;
            ppls[w.totalTransCnt].amount = msg.value;
            w.totalTransCnt++;
            TokenPurchaseInWindow(contributor, msg.value, _winNum, w.totalTransCnt, w.totalEthInWindow);
        }
    }


    /**
     * @dev close Window and transfer Eth to wallet address
     * @param _winNum - number of window 0-4 to close
     */
    function closeWindow(uint8 _winNum) onlyOwner stopInEmergency public {
        require(ww[_winNum].active);
        ww[_winNum].active = false;

        wallet.transfer(this.balance);
    }


    /**
     * @dev transfer tokens to ppl accts (window1-5)
     * @param _winNum - number of window 0-4 to close
     */
    function sendTokensWindow(uint8 _winNum) onlyOwner stopInEmergency public {
        uint256 _tokenPerETH;
        uint256 _tokenToSend = 0;
        address _tempAddr;
        uint32 index = ww[_winNum].refundIndex;

        TokenETH(ww[_winNum].totalEthInWindow, ww[_winNum].totalTransCnt);

        require(ww[_winNum].active);
        require(ww[_winNum].totalEthInWindow &amp;gt; 0);
        require(ww[_winNum].totalTransCnt &amp;gt; 0);

        _tokenPerETH = ww[_winNum].tokenPerWindow.div(ww[_winNum].totalEthInWindow); // max McFly in window / ethInWindow

        while (index &amp;lt; ww[_winNum].totalTransCnt &amp;amp;&amp;amp; msg.gas &amp;gt; 100000) {
            _tokenToSend = _tokenPerETH.mul(ppls[index].amount);
            ppls[index].amount = 0;
            _tempAddr = ppls[index].addr;
            ppls[index].addr = 0;
            index++;
            token.transfer(_tempAddr, _tokenToSend);
            TokenWithdrawAtWindow(_tempAddr, _tokenToSend);
        }
        ww[_winNum].refundIndex = index;
    }


    /**
     * @dev open new window 0-5 and write totl token per window in structure
     * @param _winNum - number of window 0-4 to close
     * @param _tokenPerWindow - total token for window 0-4
     */
    function newWindow(uint8 _winNum, uint256 _tokenPerWindow) private {
        ww[_winNum] = Window(true, 0, 0, 0, _tokenPerWindow);
        NewWindow(_winNum, _tokenPerWindow);
    }


    /**
     * @dev Finish crowdsale TLP1.2 period and open window1-5 crowdsale
     */
    function finishCrowd() onlyOwner public {
        uint256 _tokenPerWindow;
        require(now &amp;gt; (sT2.add(dTLP2)) || hardCapInTokens == token.totalSupply());
        require(!token.mintingFinished());

        _tokenPerWindow = (mintCapInTokens.sub(crowdTokensTLP2).sub(fundTotalSupply)).div(5);
        token.mint(this, _tokenPerWindow.mul(5)); // mint to contract address
        // shoud be MAX tokens minted!!! 1,800,000,000
        for (uint8 y = 0; y &amp;lt; 5; y++) {
            newWindow(y, _tokenPerWindow);
        }

        token.finishMinting();
    }


    /**
     * @dev withdraw tokens amount within vesting rules for team, advisory and reserved
     * @param withdrawWallet - wallet to transfer tokens
     * @param withdrawTokens - amount of tokens to transfer to
     * @param withdrawTotalSupply - total amount of tokens transfered to account
     * @return unit256 total amount of tokens after transfer
     */
    function vestingWithdraw(address withdrawWallet, uint256 withdrawTokens, uint256 withdrawTotalSupply) private returns (uint256) {
        require(token.mintingFinished());
        require(msg.sender == withdrawWallet || isOwner());

        uint256 currentPeriod = (block.timestamp.sub(sT2.add(dTLP2))).div(VestingPeriodInSeconds);
        if (currentPeriod &amp;gt; VestingPeriodsCount) {
            currentPeriod = VestingPeriodsCount;
        }
        uint256 tokenAvailable = withdrawTokens.mul(currentPeriod).div(VestingPeriodsCount).sub(withdrawTotalSupply);  // RECHECK!!!!!

        require(withdrawTotalSupply + tokenAvailable &amp;lt;= withdrawTokens);

        uint256 _withdrawTotalSupply = withdrawTotalSupply + tokenAvailable;

        token.transfer(withdrawWallet, tokenAvailable);
        WithdrawVesting(withdrawWallet, currentPeriod, tokenAvailable, _withdrawTotalSupply);

        return _withdrawTotalSupply;
    }


    /**
     * @dev withdraw tokens amount within vesting rules for team
     */
    function teamWithdraw() public {
        teamTotalSupply = vestingWithdraw(teamWallet, _teamTokens, teamTotalSupply);
    }


    /**
     * @dev withdraw tokens amount within vesting rules for advisory
     */
    function advisoryWithdraw() public {
        advisoryTotalSupply = vestingWithdraw(advisoryWallet, _advisoryTokens, advisoryTotalSupply);
    }


    /**
     * @dev withdraw tokens amount within vesting rules for reserved wallet
     */
    function reservedWithdraw() public {
        reservedTotalSupply = vestingWithdraw(reservedWallet, _reservedTokens, reservedTotalSupply);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x35b59527647cff6be6dfca8c9519feb77dc575ea.sol" target="_blank" title="show github file">0x35b59527647cff6be6dfca8c9519feb77dc575ea.sol</a>
        </div>
        <div class="path">solidity-files/0x35b59527647cff6be6dfca8c9519feb77dc575ea.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}

contract BigbomContributorWhiteList is Ownable {
    mapping(address=&amp;gt;uint) public addressMinCap;
    mapping(address=&amp;gt;uint) public addressMaxCap;

    function BigbomContributorWhiteList() public  {}

    event ListAddress( address _user, uint _mincap, uint _maxcap, uint _time );

    // Owner can delist by setting cap = 0.
    // Onwer can also change it at any time
    function listAddress( address _user, uint _mincap, uint _maxcap ) public onlyOwner {
        require(_mincap &amp;lt;= _maxcap);
        require(_user != address(0x0));

        addressMinCap[_user] = _mincap;
        addressMaxCap[_user] = _maxcap;
        ListAddress( _user, _mincap, _maxcap, now );
    }

    // an optimization in case of network congestion
    function listAddresses( address[] _users, uint[] _mincap, uint[] _maxcap ) public  onlyOwner {
        require(_users.length == _mincap.length );
        require(_users.length == _maxcap.length );
        for( uint i = 0 ; i &amp;lt; _users.length ; i++ ) {
            listAddress( _users[i], _mincap[i], _maxcap[i] );
        }
    }

    function getMinCap( address _user ) public constant returns(uint) {
        return addressMinCap[_user];
    }
    function getMaxCap( address _user ) public constant returns(uint) {
        return addressMaxCap[_user];
    }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x6faa826af0568d1866fca570da79b318ef114dab.sol" target="_blank" title="show github file">0x6faa826af0568d1866fca570da79b318ef114dab.sol</a>
        </div>
        <div class="path">solidity-files/0x6faa826af0568d1866fca570da79b318ef114dab.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity 0.4.21;


/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        require(a == 0 || c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b &amp;lt;= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &amp;gt;= a);
        return c;
    }
}

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
    uint256 public totalSupply;
    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {
    using SafeMath for uint256;

    mapping(address =&amp;gt; uint256) public balances;

    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint256 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

}

/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;


    /**
     * @dev Transfer tokens from one address to another
     * @param _from address The address which you want to send tokens from
     * @param _to address The address which you want to transfer to
     * @param _value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_value &amp;lt;= balances[_from]);
        require(_value &amp;lt;= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     *
     * Beware that changing an allowance with this method brings the risk that someone may use both the old
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
     * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param _spender The address which will spend the funds.
     * @param _value The amount of tokens to be spent.
     */
    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param _owner address The address which owns the funds.
     * @param _spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /**
     * approve should be called when allowed[_spender] == 0. To increment
     * allowed value is better to use this function to avoid 2 calls (and wait until
     * the first transaction is mined)
     * From MonolithDAO Token.sol
     */
    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue &amp;gt; oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }
}

/**
 * @title Burnable Token
 * @dev Token that can be irreversibly burned (destroyed).
 */
contract BurnableToken is StandardToken {

    event Burn(address indexed burner, uint256 value);

    /**
     * @dev Burns a specific amount of tokens.
     * @param _value The amount of token to be burned.
     */
    function burn(uint256 _value) public {
        require(_value &amp;gt; 0);
        require(_value &amp;lt;= balances[msg.sender]);
        // no need to require value &amp;lt;= totalSupply, since that would imply the
        // sender&amp;#39;s balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(burner, _value);
        emit Transfer(burner, 0x0, _value);
    }
}

contract B21Token is BurnableToken {
    string public constant name = &amp;quot;B21 Token&amp;quot;;
    string public constant symbol = &amp;quot;B21&amp;quot;;
    uint8 public constant decimals = 18;

    /// Maximum tokens to be allocated (500 million)
    uint256 public constant HARD_CAP = 500000000 * 10**uint256(decimals);

    /// The owner of this address are the B21 team
    address public b21TeamTokensAddress;

    /// This address is used to keep the bounty tokens
    address public bountyTokensAddress;

    /// This address is used to keep the tokens for sale
    address public saleTokensVault;

    /// This address is used to distribute the tokens for sale
    address public saleDistributorAddress;

    /// This address is used to distribute the bounty tokens
    address public bountyDistributorAddress;

    /// This address which deployed the token contract
    address public owner;

    /// when the token sale is closed, the trading is open
    bool public saleClosed = false;

    /// Only allowed to execute before the token sale is closed
    modifier beforeSaleClosed {
        require(!saleClosed);
        _;
    }

    /// Limiting functions to the admins of the token only
    modifier onlyAdmin {
        require(msg.sender == owner || msg.sender == saleTokensVault);
        _;
    }

    function B21Token(address _b21TeamTokensAddress, address _bountyTokensAddress,
    address _saleTokensVault, address _saleDistributorAddress, address _bountyDistributorAddress) public {
        require(_b21TeamTokensAddress != address(0));
        require(_bountyTokensAddress != address(0));
        require(_saleTokensVault != address(0));
        require(_saleDistributorAddress != address(0));
        require(_bountyDistributorAddress != address(0));

        owner = msg.sender;

        b21TeamTokensAddress = _b21TeamTokensAddress;
        bountyTokensAddress = _bountyTokensAddress;
        saleTokensVault = _saleTokensVault;
        saleDistributorAddress = _saleDistributorAddress;
        bountyDistributorAddress = _bountyDistributorAddress;

        /// Maximum tokens to be allocated on the sale
        /// 250M B21
        uint256 saleTokens = 250000000 * 10**uint256(decimals);
        totalSupply = saleTokens;
        balances[saleTokensVault] = saleTokens;
        emit Transfer(0x0, saleTokensVault, saleTokens);

        /// Team tokens - 200M B21
        uint256 teamTokens = 200000000 * 10**uint256(decimals);
        totalSupply = totalSupply.add(teamTokens);
        balances[b21TeamTokensAddress] = teamTokens;
        emit Transfer(0x0, b21TeamTokensAddress, teamTokens);

        /// Bounty tokens - 50M B21
        uint256 bountyTokens = 50000000 * 10**uint256(decimals);
        totalSupply = totalSupply.add(bountyTokens);
        balances[bountyTokensAddress] = bountyTokens;
        emit Transfer(0x0, bountyTokensAddress, bountyTokens);

        require(totalSupply &amp;lt;= HARD_CAP);
    }

    /// @dev Close the token sale
    function closeSale() public onlyAdmin beforeSaleClosed {
        saleClosed = true;
    }

    /// @dev Trading limited - requires the token sale to have closed
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        if(saleClosed) {
            return super.transferFrom(_from, _to, _value);
        }
        return false;
    }

    /// @dev Trading limited - requires the token sale to have closed
    function transfer(address _to, uint256 _value) public returns (bool) {
        if(saleClosed || msg.sender == saleDistributorAddress || msg.sender == bountyDistributorAddress
        || (msg.sender == saleTokensVault &amp;amp;&amp;amp; _to == saleDistributorAddress)
        || (msg.sender == bountyTokensAddress &amp;amp;&amp;amp; _to == bountyDistributorAddress)) {
            return super.transfer(_to, _value);
        }
        return false;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x955263e4c3166e254517365b06cc420621149cf4.sol" target="_blank" title="show github file">0x955263e4c3166e254517365b06cc420621149cf4.sol</a>
        </div>
        <div class="path">solidity-files/0x955263e4c3166e254517365b06cc420621149cf4.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }

contract TokenERC20 {
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address =&amp;gt; uint256) public balanceOf;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);

    /**
     * Constructor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] &amp;gt;= _value);
        // Check for overflows
        require(balanceOf[_to] + _value &amp;gt; balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` on behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value &amp;lt;= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] &amp;gt;= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] &amp;gt;= _value);                // Check if the targeted balance is enough
        require(_value &amp;lt;= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender&amp;#39;s allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x599e4466aa2cbcf85a54f9d51841988419f3531a.sol" target="_blank" title="show github file">0x599e4466aa2cbcf85a54f9d51841988419f3531a.sol</a>
        </div>
        <div class="path">solidity-files/0x599e4466aa2cbcf85a54f9d51841988419f3531a.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;ACT222097&amp;#39; token contract
//
// Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
// Symbol      : ACT222097
// Name        : ADZbuzz Cision.com Community Token
// Total supply: 2000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function ADZbuzzCommunityToken() public {
        symbol = &amp;quot;ACT222097&amp;quot;;
        name = &amp;quot;ADZbuzz Cision.com Community Token&amp;quot;;
        decimals = 8;
        _totalSupply = 200000000000000;
        balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
        emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x8227cf5171bfdafad9110775c4dce2cc5897b5dd.sol" target="_blank" title="show github file">0x8227cf5171bfdafad9110775c4dce2cc5897b5dd.sol</a>
        </div>
        <div class="path">solidity-files/0x8227cf5171bfdafad9110775c4dce2cc5897b5dd.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  
  event Transfer(address indexed _from, address indexed _to, uint _value);
  //event Transfer(address indexed from, address indexed to, uint256 value);
}


/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  
  event Approval(address indexed _owner, address indexed _spender, uint _value);
  //event Approval(address indexed owner, address indexed spender, uint256 value);
}




/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances. 
 */
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address =&amp;gt; uint256) balances;

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of. 
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }

}


/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

  mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amout of tokens to be transfered
   */
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value &amp;lt;= _allowance);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    //balances[_from] = balances[_from].sub(_value); // this was removed
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifing the amount of tokens still avaible for the spender.
   */
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

}


/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}
contract BigbomPrivateSaleList is Ownable {
    mapping(address=&amp;gt;uint) public addressCap;

    function BigbomPrivateSaleList() public  {}

    event ListAddress( address _user, uint _amount, uint _time );

    // Owner can delist by setting amount = 0.
    // Onwer can also change it at any time
    function listAddress( address _user, uint _amount ) public onlyOwner {
        require(_user != address(0x0));

        addressCap[_user] = _amount;
        ListAddress( _user, _amount, now );
    }

    // an optimization in case of network congestion
    function listAddresses( address[] _users, uint[] _amount ) public onlyOwner {
        require(_users.length == _amount.length );
        for( uint i = 0 ; i &amp;lt; _users.length ; i++ ) {
            listAddress( _users[i], _amount[i] );
        }
    }

    function getCap( address _user ) public constant returns(uint) {
        return addressCap[_user];
    }

}

contract BigbomToken is StandardToken, Ownable {
    
    string  public  constant name = &amp;quot;Bigbom&amp;quot;;
    string  public  constant symbol = &amp;quot;BBO&amp;quot;;
    uint    public  constant decimals = 18;
    uint    public   totalSupply = 2000000000 * 1e18; //2,000,000,000

    uint    public  constant founderAmount = 200000000 * 1e18; // 200,000,000
    uint    public  constant coreStaffAmount = 60000000 * 1e18; // 60,000,000
    uint    public  constant advisorAmount = 140000000 * 1e18; // 140,000,000
    uint    public  constant networkGrowthAmount = 600000000 * 1e18; //600,000,000
    uint    public  constant reserveAmount = 635000000 * 1e18; // 635,000,000
    uint    public  constant bountyAmount = 40000000 * 1e18; // 40,000,000
    uint    public  constant publicSaleAmount = 275000000 * 1e18; // 275,000,000

    address public   bbFounderCoreStaffWallet ;
    address public   bbAdvisorWallet;
    address public   bbAirdropWallet;
    address public   bbNetworkGrowthWallet;
    address public   bbReserveWallet;
    address public   bbPublicSaleWallet;

    uint    public  saleStartTime;
    uint    public  saleEndTime;

    address public  tokenSaleContract;
    BigbomPrivateSaleList public privateSaleList;

    mapping (address =&amp;gt; bool) public frozenAccount;
    mapping (address =&amp;gt; uint) public frozenTime;
    mapping (address =&amp;gt; uint) public maxAllowedAmount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen, uint _seconds);
   

    function checkMaxAllowed(address target)  public constant  returns (uint) {
        var maxAmount  = balances[target];
        if(target == bbFounderCoreStaffWallet){
            maxAmount = 10000000 * 1e18;
        }
        if(target == bbAdvisorWallet){
            maxAmount = 10000000 * 1e18;
        }
        if(target == bbAirdropWallet){
            maxAmount = 40000000 * 1e18;
        }
        if(target == bbNetworkGrowthWallet){
            maxAmount = 20000000 * 1e18;
        }
        if(target == bbReserveWallet){
            maxAmount = 6350000 * 1e18;
        }
        return maxAmount;
    }

    function selfFreeze(bool freeze, uint _seconds) public {
        // selfFreeze cannot more than 7 days
        require(_seconds &amp;lt;= 7 * 24 * 3600);
        // if unfreeze
        if(!freeze){
            // get End time of frozenAccount
            var frozenEndTime = frozenTime[msg.sender];
            // if now &amp;gt; frozenEndTime
            require (now &amp;gt;= frozenEndTime);
            // unfreeze account
            frozenAccount[msg.sender] = freeze;
            // set time to 0
            _seconds = 0;           
        }else{
            frozenAccount[msg.sender] = freeze;
            
        }
        // set endTime = now + _seconds to freeze
        frozenTime[msg.sender] = now + _seconds;
        FrozenFunds(msg.sender, freeze, _seconds);
        
    }

    function freezeAccount(address target, bool freeze, uint _seconds) onlyOwner public {
        
        // if unfreeze
        if(!freeze){
            // get End time of frozenAccount
            var frozenEndTime = frozenTime[target];
            // if now &amp;gt; frozenEndTime
            require (now &amp;gt;= frozenEndTime);
            // unfreeze account
            frozenAccount[target] = freeze;
            // set time to 0
            _seconds = 0;           
        }else{
            frozenAccount[target] = freeze;
            
        }
        // set endTime = now + _seconds to freeze
        frozenTime[target] = now + _seconds;
        FrozenFunds(target, freeze, _seconds);
        
    }

    modifier validDestination( address to ) {
        require(to != address(0x0));
        require(to != address(this) );
        require(!frozenAccount[to]);                       // Check if recipient is frozen
        _;
    }
    modifier validFrom(address from){
        require(!frozenAccount[from]);                     // Check if sender is frozen
        _;
    }
    modifier onlyWhenTransferEnabled() {
        if( now &amp;lt;= saleEndTime &amp;amp;&amp;amp; now &amp;gt;= saleStartTime ) {
            require( msg.sender == tokenSaleContract );
        }
        _;
    }
    modifier onlyPrivateListEnabled(address _to){
        require(now &amp;lt;= saleStartTime);
        uint allowcap = privateSaleList.getCap(_to);
        require (allowcap &amp;gt; 0);
        _;
    }
    function setPrivateList(BigbomPrivateSaleList _privateSaleList)   onlyOwner public {
        require(_privateSaleList != address(0x0));
        privateSaleList = _privateSaleList;

    }
    
    function BigbomToken(uint startTime, uint endTime, address admin, address _bbFounderCoreStaffWallet, address _bbAdvisorWallet,
        address _bbAirdropWallet,
        address _bbNetworkGrowthWallet,
        address _bbReserveWallet, 
        address _bbPublicSaleWallet
        ) public {

        require(admin!=address(0x0));
        require(_bbAirdropWallet!=address(0x0));
        require(_bbAdvisorWallet!=address(0x0));
        require(_bbReserveWallet!=address(0x0));
        require(_bbNetworkGrowthWallet!=address(0x0));
        require(_bbFounderCoreStaffWallet!=address(0x0));
        require(_bbPublicSaleWallet!=address(0x0));

        // Mint all tokens. Then disable minting forever.
        balances[msg.sender] = totalSupply;
        Transfer(address(0x0), msg.sender, totalSupply);
        // init internal amount limit
        // set address when deploy
        bbAirdropWallet = _bbAirdropWallet;
        bbAdvisorWallet = _bbAdvisorWallet;
        bbReserveWallet = _bbReserveWallet;
        bbNetworkGrowthWallet = _bbNetworkGrowthWallet;
        bbFounderCoreStaffWallet = _bbFounderCoreStaffWallet;
        bbPublicSaleWallet = _bbPublicSaleWallet;
        
        saleStartTime = startTime;
        saleEndTime = endTime;
        transferOwnership(admin); // admin could drain tokens that were sent here by mistake
    }

    function setTimeSale(uint startTime, uint endTime) onlyOwner public {
        require (now &amp;lt; saleStartTime || now &amp;gt; saleEndTime);
        require (now &amp;lt; startTime);
        require ( startTime &amp;lt; endTime);
        saleStartTime = startTime;
        saleEndTime = endTime;
    }

    function setTokenSaleContract(address _tokenSaleContract) onlyOwner public {
        // check address ! 0
        require(_tokenSaleContract != address(0x0));
        // do not allow run when saleStartTime &amp;lt;= now &amp;lt;= saleEndTime
        require (now &amp;lt; saleStartTime || now &amp;gt; saleEndTime);

        tokenSaleContract = _tokenSaleContract;
    }
    function transfer(address _to, uint _value)
        onlyWhenTransferEnabled
        validDestination(_to)
        validFrom(msg.sender)
        public 
        returns (bool) {
        if (msg.sender == bbFounderCoreStaffWallet || msg.sender == bbAdvisorWallet|| 
            msg.sender == bbAirdropWallet|| msg.sender == bbNetworkGrowthWallet|| msg.sender == bbReserveWallet){

            // check maxAllowedAmount
            var withdrawAmount =  maxAllowedAmount[msg.sender]; 
            var defaultAllowAmount = checkMaxAllowed(msg.sender);
            var maxAmount = defaultAllowAmount - withdrawAmount;
            // _value transfer must &amp;lt;= maxAmount
            require(maxAmount &amp;gt;= _value); // 

            // if maxAmount = 0, need to block this msg.sender
            if(maxAmount==_value){
               
                var isTransfer = super.transfer(_to, _value);
                 // freeze account
                selfFreeze(true, 24 * 3600); // temp freeze account 24h
                maxAllowedAmount[msg.sender] = 0;
                return isTransfer;
            }else{
                // set max withdrawAmount
                maxAllowedAmount[msg.sender] = maxAllowedAmount[msg.sender].add(_value); // 
                
            }
        }
        return  super.transfer(_to, _value);
            
    }

    function transferPrivateSale(address _to, uint _value)
        onlyOwner
        onlyPrivateListEnabled(_to) 
        public 
        returns (bool) {
         return transfer( _to,  _value);
    }

    function transferFrom(address _from, address _to, uint _value)
        onlyWhenTransferEnabled
        validDestination(_to)
        validFrom(_from)
        public 
        returns (bool) {
            if (_from == bbFounderCoreStaffWallet || _from == bbAdvisorWallet|| 
                _from == bbAirdropWallet|| _from == bbNetworkGrowthWallet|| _from == bbReserveWallet){

                  // check maxAllowedAmount
                var withdrawAmount =  maxAllowedAmount[_from]; 
                var defaultAllowAmount = checkMaxAllowed(_from);
                var maxAmount = defaultAllowAmount - withdrawAmount; 
                // _value transfer must &amp;lt;= maxAmount
                require(maxAmount &amp;gt;= _value); 

                // if maxAmount = 0, need to block this _from
                if(maxAmount==_value){
                   
                    var isTransfer = super.transfer(_to, _value);
                     // freeze account
                    selfFreeze(true, 24 * 3600); 
                    maxAllowedAmount[_from] = 0;
                    return isTransfer;
                }else{
                    // set max withdrawAmount
                    maxAllowedAmount[_from] = maxAllowedAmount[_from].add(_value); 
                    
                }
            }
            return super.transferFrom(_from, _to, _value);
    }

    event Burn(address indexed _burner, uint _value);

    function burn(uint _value) onlyWhenTransferEnabled
        public 
        returns (bool){
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(msg.sender, _value);
        Transfer(msg.sender, address(0x0), _value);
        return true;
    }

    // save some gas by making only one contract call
    function burnFrom(address _from, uint256 _value) onlyWhenTransferEnabled
        public 
        returns (bool) {
        assert( transferFrom( _from, msg.sender, _value ) );
        return burn(_value);
    }

    function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner public {
        token.transfer( owner, amount );
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xd582ec4ed8da08fb519b38950276a6a16f33c020.sol" target="_blank" title="show github file">0xd582ec4ed8da08fb519b38950276a6a16f33c020.sol</a>
        </div>
        <div class="path">solidity-files/0xd582ec4ed8da08fb519b38950276a6a16f33c020.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.4;
 
contract Token {
 
    /// @return total amount of tokens
    function totalSupply() constant returns (uint256 supply) {}
 
    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) constant returns (uint256 balance) {}
 
    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint256 _value) returns (bool success) {}
 
    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}
 
    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint256 _value) returns (bool success) {}
 
    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}
 
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
   
}
 
 
 
contract StandardToken is Token {
 
    function transfer(address _to, uint256 _value) returns (bool success) {
        //Default assumes totalSupply can&amp;#39;t be over max (2^256 - 1).
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&amp;#39;t wrap.
        //Replace the if with this one instead.
        //if (balances[msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; balances[_to] + _value &amp;gt; balances[_to]) {
        if (balances[msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; _value &amp;gt; 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
 
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] &amp;gt;= _value &amp;amp;&amp;amp; allowed[_from][msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; balances[_to] + _value &amp;gt; balances[_to]) {
        if (balances[_from] &amp;gt;= _value &amp;amp;&amp;amp; allowed[_from][msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; _value &amp;gt; 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
 
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
 
    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
 
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
 
    mapping (address =&amp;gt; uint256) balances;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;
    uint256 public totalSupply;
}
 
 
//name this contract whatever you&amp;#39;d like
contract ERC20Token is StandardToken {
 
    function () {
        //if ether is sent to this address, send it back.
        throw;
    }
 
    /* Public variables of the token */
 
    /*
    NOTE:
    The following variables are OPTIONAL vanities. One does not have to include them.
    They allow one to customise the token contract &amp;amp; in no way influences the core functionality.
    Some wallets/interfaces might not even bother to look at this information.
    */
    string public name;                   //fancy name: eg Simon Bucks
    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It&amp;#39;s like comparing 1 wei to 1 ether.
    string public symbol;                 //An identifier: eg SBX
    string public version = &amp;#39;H1.0&amp;#39;;       //human 0.1 standard. Just an arbitrary versioning scheme.
 
//
// CHANGE THESE VALUES FOR YOUR TOKEN
//
 
//make sure this function name matches the contract name above. So if you&amp;#39;re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token
 
    function ERC20Token(
        ) {
        balances[msg.sender] = 1000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 1000000000000;                        // Update total supply (100000 for example)
        name = &amp;quot;INOOVI&amp;quot;;                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = &amp;quot;IVI&amp;quot;;                               // Set the symbol for display purposes
    }
 
    /* Approves and then calls the receiving contract */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
 
        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn&amp;#39;t have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3(&amp;quot;receiveApproval(address,uint256,address,bytes)&amp;quot;))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x9b55cbb00af7ef313ea49a5aef1f28f01dd262dc.sol" target="_blank" title="show github file">0x9b55cbb00af7ef313ea49a5aef1f28f01dd262dc.sol</a>
        </div>
        <div class="path">solidity-files/0x9b55cbb00af7ef313ea49a5aef1f28f01dd262dc.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.17;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}



/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}

/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  /**
   * @dev Modifier to make a function callable only when the contract is paused.
   */
  modifier whenPaused() {
    require(paused);
    _;
  }

  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
    paused = false;
    Unpause();
  }
}

contract BonumPreICO is Pausable{
    using SafeMath for uint;

    string public constant name = &amp;quot;Bonum PreICO&amp;quot;;

    uint public fiatValueMultiplier = 10**6;
    uint public tokenDecimals = 10**18;

    address public beneficiary;

    uint public ethUsdRate;
    uint public collected = 0;
    uint public tokensSold = 0;
    uint public tokensSoldWithBonus = 0;


    event NewContribution(address indexed holder, uint tokenAmount, uint etherAmount);

    function BonumPreICO(
        address _beneficiary,
        uint _baseEthUsdRate
    ) public {
        beneficiary = _beneficiary;

        ethUsdRate = _baseEthUsdRate;
    }


    function setNewBeneficiary(address newBeneficiary) external onlyOwner {
        require(newBeneficiary != 0x0);
        beneficiary = newBeneficiary;
    }

    function setEthUsdRate(uint rate) external onlyOwner {
        require(rate &amp;gt; 0);
        ethUsdRate = rate;
    }

    modifier underCap(){
        require(tokensSold &amp;lt; uint(750000).mul(tokenDecimals));
        _;
    }

    modifier minimumAmount(){
        require(msg.value.mul(ethUsdRate).div(fiatValueMultiplier.mul(1 ether)) &amp;gt;= 100);
        _;
    }

    mapping (address =&amp;gt; uint) public investors;

    function() payable public whenNotPaused minimumAmount underCap{
        uint tokens = msg.value.mul(ethUsdRate).div(fiatValueMultiplier);
        tokensSold = tokensSold.add(tokens);
        
        tokens = tokens.add(tokens.mul(25).div(100));
        tokensSoldWithBonus =  tokensSoldWithBonus.add(tokens);
        
        investors[msg.sender] = investors[msg.sender].add(tokens);
        NewContribution(msg.sender, tokens, msg.value);

        collected = collected.add(msg.value);

        beneficiary.transfer(msg.value);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x857a73ccb3e0b56bdb2510ae161854a48079e109.sol" target="_blank" title="show github file">0x857a73ccb3e0b56bdb2510ae161854a48079e109.sol</a>
        </div>
        <div class="path">solidity-files/0x857a73ccb3e0b56bdb2510ae161854a48079e109.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT104806&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT104806
    // Name        : ADZbuzz Mywebsearch.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT104806&amp;quot;;
            name = &amp;quot;ADZbuzz Mywebsearch.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x37dc39d1bf668e7747ad9a9493455b4867550b8d.sol" target="_blank" title="show github file">0x37dc39d1bf668e7747ad9a9493455b4867550b8d.sol</a>
        </div>
        <div class="path">solidity-files/0x37dc39d1bf668e7747ad9a9493455b4867550b8d.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

// File: contracts/BdpBaseData.sol

contract BdpBaseData {

	address public ownerAddress;

	address public managerAddress;

	address[16] public contracts;

	bool public paused = false;

	bool public setupCompleted = false;

	bytes8 public version;

}

// File: contracts/libraries/BdpContracts.sol

library BdpContracts {

	function getBdpEntryPoint(address[16] _contracts) pure internal returns (address) {
		return _contracts[0];
	}

	function getBdpController(address[16] _contracts) pure internal returns (address) {
		return _contracts[1];
	}

	function getBdpControllerHelper(address[16] _contracts) pure internal returns (address) {
		return _contracts[3];
	}

	function getBdpDataStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[4];
	}

	function getBdpImageStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[5];
	}

	function getBdpOwnershipStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[6];
	}

	function getBdpPriceStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[7];
	}

}

// File: contracts/BdpBase.sol

contract BdpBase is BdpBaseData {

	modifier onlyOwner() {
		require(msg.sender == ownerAddress);
		_;
	}

	modifier onlyAuthorized() {
		require(msg.sender == ownerAddress || msg.sender == managerAddress);
		_;
	}

	modifier whileContractIsActive() {
		require(!paused &amp;amp;&amp;amp; setupCompleted);
		_;
	}

	modifier storageAccessControl() {
		require(
			(! setupCompleted &amp;amp;&amp;amp; (msg.sender == ownerAddress || msg.sender == managerAddress))
			|| (setupCompleted &amp;amp;&amp;amp; !paused &amp;amp;&amp;amp; (msg.sender == BdpContracts.getBdpEntryPoint(contracts)))
		);
		_;
	}

	function setOwner(address _newOwner) external onlyOwner {
		require(_newOwner != address(0));
		ownerAddress = _newOwner;
	}

	function setManager(address _newManager) external onlyOwner {
		require(_newManager != address(0));
		managerAddress = _newManager;
	}

	function setContracts(address[16] _contracts) external onlyOwner {
		contracts = _contracts;
	}

	function pause() external onlyAuthorized {
		paused = true;
	}

	function unpause() external onlyOwner {
		paused = false;
	}

	function setSetupCompleted() external onlyOwner {
		setupCompleted = true;
	}

	function kill() public onlyOwner {
		selfdestruct(ownerAddress);
	}

}

// File: contracts/libraries/SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

	/**
	* @dev Multiplies two numbers, throws on overflow.
	*/
	function mul(uint256 a, uint256 b) internal pure returns (uint256) {
		if (a == 0) {
			return 0;
		}
		uint256 c = a * b;
		assert(c / a == b);
		return c;
	}

	/**
	* @dev Integer division of two numbers, truncating the quotient.
	*/
	function div(uint256 a, uint256 b) internal pure returns (uint256) {
		// assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
		uint256 c = a / b;
		// assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
		return c;
	}

	/**
	* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
	*/
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
		assert(b &amp;lt;= a);
		return a - b;
	}

	/**
	* @dev Adds two numbers, throws on overflow.
	*/
	function add(uint256 a, uint256 b) internal pure returns (uint256) {
		uint256 c = a + b;
		assert(c &amp;gt;= a);
		return c;
	}
}

// File: contracts/storage/BdpDataStorage.sol

contract BdpDataStorage is BdpBase {

	using SafeMath for uint256;

	struct Region {
		uint256 x1;
		uint256 y1;
		uint256 x2;
		uint256 y2;
		uint256 currentImageId;
		uint256 nextImageId;
		uint8[128] url;
		uint256 currentPixelPrice;
		uint256 blockUpdatedAt;
		uint256 updatedAt;
		uint256 purchasedAt;
		uint256 purchasedPixelPrice;
	}

	uint256 public lastRegionId = 0;

	mapping (uint256 =&amp;gt; Region) public data;


	function getLastRegionId() view public returns (uint256) {
		return lastRegionId;
	}

	function getNextRegionId() public storageAccessControl returns (uint256) {
		lastRegionId = lastRegionId.add(1);
		return lastRegionId;
	}

	function deleteRegionData(uint256 _id) public storageAccessControl {
		delete data[_id];
	}

	function getRegionCoordinates(uint256 _id) view public returns (uint256, uint256, uint256, uint256) {
		return (data[_id].x1, data[_id].y1, data[_id].x2, data[_id].y2);
	}

	function setRegionCoordinates(uint256 _id, uint256 _x1, uint256 _y1, uint256 _x2, uint256 _y2) public storageAccessControl {
		data[_id].x1 = _x1;
		data[_id].y1 = _y1;
		data[_id].x2 = _x2;
		data[_id].y2 = _y2;
	}

	function getRegionCurrentImageId(uint256 _id) view public returns (uint256) {
		return data[_id].currentImageId;
	}

	function setRegionCurrentImageId(uint256 _id, uint256 _currentImageId) public storageAccessControl {
		data[_id].currentImageId = _currentImageId;
	}

	function getRegionNextImageId(uint256 _id) view public returns (uint256) {
		return data[_id].nextImageId;
	}

	function setRegionNextImageId(uint256 _id, uint256 _nextImageId) public storageAccessControl {
		data[_id].nextImageId = _nextImageId;
	}

	function getRegionUrl(uint256 _id) view public returns (uint8[128]) {
		return data[_id].url;
	}

	function setRegionUrl(uint256 _id, uint8[128] _url) public storageAccessControl {
		data[_id].url = _url;
	}

	function getRegionCurrentPixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].currentPixelPrice;
	}

	function setRegionCurrentPixelPrice(uint256 _id, uint256 _currentPixelPrice) public storageAccessControl {
		data[_id].currentPixelPrice = _currentPixelPrice;
	}

	function getRegionBlockUpdatedAt(uint256 _id) view public returns (uint256) {
		return data[_id].blockUpdatedAt;
	}

	function setRegionBlockUpdatedAt(uint256 _id, uint256 _blockUpdatedAt) public storageAccessControl {
		data[_id].blockUpdatedAt = _blockUpdatedAt;
	}

	function getRegionUpdatedAt(uint256 _id) view public returns (uint256) {
		return data[_id].updatedAt;
	}

	function setRegionUpdatedAt(uint256 _id, uint256 _updatedAt) public storageAccessControl {
		data[_id].updatedAt = _updatedAt;
	}

	function getRegionPurchasedAt(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedAt;
	}

	function setRegionPurchasedAt(uint256 _id, uint256 _purchasedAt) public storageAccessControl {
		data[_id].purchasedAt = _purchasedAt;
	}

	function getRegionUpdatedAtPurchasedAt(uint256 _id) view public returns (uint256 _updatedAt, uint256 _purchasedAt) {
		return (data[_id].updatedAt, data[_id].purchasedAt);
	}

	function getRegionPurchasePixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedPixelPrice;
	}

	function setRegionPurchasedPixelPrice(uint256 _id, uint256 _purchasedPixelPrice) public storageAccessControl {
		data[_id].purchasedPixelPrice = _purchasedPixelPrice;
	}

	function BdpDataStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/storage/BdpImageStorage.sol

contract BdpImageStorage is BdpBase {

	using SafeMath for uint256;

	struct Image {
		address owner;
		uint256 regionId;
		uint256 currentRegionId;
		mapping(uint16 =&amp;gt; uint256[1000]) data;
		mapping(uint16 =&amp;gt; uint16) dataLength;
		uint16 partsCount;
		uint16 width;
		uint16 height;
		uint16 imageDescriptor;
		uint256 blurredAt;
	}

	uint256 public lastImageId = 0;

	mapping(uint256 =&amp;gt; Image) public images;


	function getLastImageId() view public returns (uint256) {
		return lastImageId;
	}

	function getNextImageId() public storageAccessControl returns (uint256) {
		lastImageId = lastImageId.add(1);
		return lastImageId;
	}

	function createImage(address _owner, uint256 _regionId, uint16 _width, uint16 _height, uint16 _partsCount, uint16 _imageDescriptor) public storageAccessControl returns (uint256) {
		require(_owner != address(0) &amp;amp;&amp;amp; _width &amp;gt; 0 &amp;amp;&amp;amp; _height &amp;gt; 0 &amp;amp;&amp;amp; _partsCount &amp;gt; 0 &amp;amp;&amp;amp; _imageDescriptor &amp;gt; 0);
		uint256 id = getNextImageId();
		images[id].owner = _owner;
		images[id].regionId = _regionId;
		images[id].width = _width;
		images[id].height = _height;
		images[id].partsCount = _partsCount;
		images[id].imageDescriptor = _imageDescriptor;
		return id;
	}

	function imageExists(uint256 _imageId) view public returns (bool) {
		return _imageId &amp;gt; 0 &amp;amp;&amp;amp; images[_imageId].owner != address(0);
	}

	function deleteImage(uint256 _imageId) public storageAccessControl {
		require(imageExists(_imageId));
		delete images[_imageId];
	}

	function getImageOwner(uint256 _imageId) public view returns (address) {
		require(imageExists(_imageId));
		return images[_imageId].owner;
	}

	function setImageOwner(uint256 _imageId, address _owner) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].owner = _owner;
	}

	function getImageRegionId(uint256 _imageId) public view returns (uint256) {
		require(imageExists(_imageId));
		return images[_imageId].regionId;
	}

	function setImageRegionId(uint256 _imageId, uint256 _regionId) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].regionId = _regionId;
	}

	function getImageCurrentRegionId(uint256 _imageId) public view returns (uint256) {
		require(imageExists(_imageId));
		return images[_imageId].currentRegionId;
	}

	function setImageCurrentRegionId(uint256 _imageId, uint256 _currentRegionId) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].currentRegionId = _currentRegionId;
	}

	function getImageData(uint256 _imageId, uint16 _part) view public returns (uint256[1000]) {
		require(imageExists(_imageId));
		return images[_imageId].data[_part];
	}

	function setImageData(uint256 _imageId, uint16 _part, uint256[] _data) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].dataLength[_part] = uint16(_data.length);
		for (uint256 i = 0; i &amp;lt; _data.length; i++) {
			images[_imageId].data[_part][i] = _data[i];
		}
	}

	function getImageDataLength(uint256 _imageId, uint16 _part) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].dataLength[_part];
	}

	function setImageDataLength(uint256 _imageId, uint16 _part, uint16 _dataLength) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].dataLength[_part] = _dataLength;
	}

	function getImagePartsCount(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].partsCount;
	}

	function setImagePartsCount(uint256 _imageId, uint16 _partsCount) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].partsCount = _partsCount;
	}

	function getImageWidth(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].width;
	}

	function setImageWidth(uint256 _imageId, uint16 _width) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].width = _width;
	}

	function getImageHeight(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].height;
	}

	function setImageHeight(uint256 _imageId, uint16 _height) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].height = _height;
	}

	function getImageDescriptor(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].imageDescriptor;
	}

	function setImageDescriptor(uint256 _imageId, uint16 _imageDescriptor) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].imageDescriptor = _imageDescriptor;
	}

	function getImageBlurredAt(uint256 _imageId) view public returns (uint256) {
		return images[_imageId].blurredAt;
	}

	function setImageBlurredAt(uint256 _imageId, uint256 _blurredAt) public storageAccessControl {
		images[_imageId].blurredAt = _blurredAt;
	}

	function imageUploadComplete(uint256 _imageId) view public returns (bool) {
		require(imageExists(_imageId));
		for (uint16 i = 1; i &amp;lt;= images[_imageId].partsCount; i++) {
			if(images[_imageId].data[i].length == 0) {
				return false;
			}
		}
		return true;
	}

	function BdpImageStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/storage/BdpPriceStorage.sol

contract BdpPriceStorage is BdpBase {

	uint64[1001] public pricePoints;

	uint256 public pricePointsLength = 0;

	address public forwardPurchaseFeesTo = address(0);

	address public forwardUpdateFeesTo = address(0);


	function getPricePointsLength() view public returns (uint256) {
		return pricePointsLength;
	}

	function getPricePoint(uint256 _i) view public returns (uint256) {
		return pricePoints[_i];
	}

	function setPricePoints(uint64[] _pricePoints) public storageAccessControl {
		pricePointsLength = 0;
		appendPricePoints(_pricePoints);
	}

	function appendPricePoints(uint64[] _pricePoints) public storageAccessControl {
		for (uint i = 0; i &amp;lt; _pricePoints.length; i++) {
			pricePoints[pricePointsLength++] = _pricePoints[i];
		}
	}

	function getForwardPurchaseFeesTo() view public returns (address) {
		return forwardPurchaseFeesTo;
	}

	function setForwardPurchaseFeesTo(address _forwardPurchaseFeesTo) public storageAccessControl {
		forwardPurchaseFeesTo = _forwardPurchaseFeesTo;
	}

	function getForwardUpdateFeesTo() view public returns (address) {
		return forwardUpdateFeesTo;
	}

	function setForwardUpdateFeesTo(address _forwardUpdateFeesTo) public storageAccessControl {
		forwardUpdateFeesTo = _forwardUpdateFeesTo;
	}

	function BdpPriceStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/libraries/BdpCalculator.sol

library BdpCalculator {

	using SafeMath for uint256;

	function calculateArea(address[16] _contracts, uint256 _regionId) view public returns (uint256 _area, uint256 _width, uint256 _height) {
		var (x1, y1, x2, y2) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCoordinates(_regionId);
		_width = x2 - x1 + 1;
		_height = y2 - y1 + 1;
		_area = _width * _height;
	}

	function countPurchasedPixels(address[16] _contracts) view public returns (uint256 _count) {
		var lastRegionId = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getLastRegionId();
		for (uint256 i = 0; i &amp;lt;= lastRegionId; i++) {
			if(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionPurchasedAt(i) &amp;gt; 0) { // region is purchased
				var (area,,) = calculateArea(_contracts, i);
				_count += area;
			}
		}
	}

	function calculateCurrentMarketPixelPrice(address[16] _contracts) view public returns(uint) {
		return calculateMarketPixelPrice(_contracts, countPurchasedPixels(_contracts));
	}

	function calculateMarketPixelPrice(address[16] _contracts, uint _pixelsSold) view public returns(uint) {
		var pricePointsLength = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePointsLength();
		uint mod = _pixelsSold % (1000000 / (pricePointsLength - 1));
		uint div = _pixelsSold * (pricePointsLength - 1) / 1000000;
		var divPoint = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div);
		if(mod == 0) return divPoint;
		return divPoint + mod * (BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div+1) - divPoint) * (pricePointsLength - 1) / 1000000;
	}

	function calculateAveragePixelPrice(address[16] _contracts, uint _a, uint _b) view public returns (uint _price) {
		_price = (calculateMarketPixelPrice(_contracts, _a) + calculateMarketPixelPrice(_contracts, _b)) / 2;
	}

	/** Current market price per pixel for this region if it is the first sale of this region
	  */
	function calculateRegionInitialSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		require(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAt(_regionId) &amp;gt; 0); // region exists
		var purchasedPixels = countPurchasedPixels(_contracts);
		var (area,,) = calculateArea(_contracts, _regionId);
		return calculateAveragePixelPrice(_contracts, purchasedPixels, purchasedPixels + area);
	}

	/** Current market price or (Current market price)*3 if the region was sold
	  */
	function calculateRegionSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		var pixelPrice = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCurrentPixelPrice(_regionId);
		if(pixelPrice &amp;gt; 0) {
			return pixelPrice * 3;
		} else {
			return calculateRegionInitialSalePixelPrice(_contracts, _regionId);
		}
	}

	/** Setup is allowed one whithin one day after purchase
	  */
	function calculateSetupAllowedUntil(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		var (updatedAt, purchasedAt) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAtPurchasedAt(_regionId);
		if(updatedAt != purchasedAt) {
			return 0;
		} else {
			return purchasedAt + 1 days;
		}
	}

}

// File: contracts/storage/BdpOwnershipStorage.sol

contract BdpOwnershipStorage is BdpBase {

	using SafeMath for uint256;

	// Mapping from token ID to owner
	mapping (uint256 =&amp;gt; address) public tokenOwner;

	// Mapping from token ID to approved address
	mapping (uint256 =&amp;gt; address) public tokenApprovals;

	// Mapping from owner to the sum of owned area
	mapping (address =&amp;gt; uint256) public ownedArea;

	// Mapping from owner to list of owned token IDs
	mapping (address =&amp;gt; uint256[]) public ownedTokens;

	// Mapping from token ID to index of the owner tokens list
	mapping(uint256 =&amp;gt; uint256) public ownedTokensIndex;

	// All tokens list tokens ids
	uint256[] public tokenIds;

	// Mapping from tokenId to index of the tokens list
	mapping (uint256 =&amp;gt; uint256) public tokenIdsIndex;


	function getTokenOwner(uint256 _tokenId) view public returns (address) {
		return tokenOwner[_tokenId];
	}

	function setTokenOwner(uint256 _tokenId, address _owner) public storageAccessControl {
		tokenOwner[_tokenId] = _owner;
	}

	function getTokenApproval(uint256 _tokenId) view public returns (address) {
		return tokenApprovals[_tokenId];
	}

	function setTokenApproval(uint256 _tokenId, address _to) public storageAccessControl {
		tokenApprovals[_tokenId] = _to;
	}

	function getOwnedArea(address _owner) view public returns (uint256) {
		return ownedArea[_owner];
	}

	function setOwnedArea(address _owner, uint256 _area) public storageAccessControl {
		ownedArea[_owner] = _area;
	}

	function incrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].add(_area);
		return ownedArea[_owner];
	}

	function decrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].sub(_area);
		return ownedArea[_owner];
	}

	function getOwnedTokensLength(address _owner) view public returns (uint256) {
		return ownedTokens[_owner].length;
	}

	function getOwnedToken(address _owner, uint256 _index) view public returns (uint256) {
		return ownedTokens[_owner][_index];
	}

	function setOwnedToken(address _owner, uint256 _index, uint256 _tokenId) public storageAccessControl {
		ownedTokens[_owner][_index] = _tokenId;
	}

	function pushOwnedToken(address _owner, uint256 _tokenId) public storageAccessControl returns (uint256) {
		ownedTokens[_owner].push(_tokenId);
		return ownedTokens[_owner].length;
	}

	function decrementOwnedTokensLength(address _owner) public storageAccessControl {
		ownedTokens[_owner].length--;
	}

	function getOwnedTokensIndex(uint256 _tokenId) view public returns (uint256) {
		return ownedTokensIndex[_tokenId];
	}

	function setOwnedTokensIndex(uint256 _tokenId, uint256 _tokenIndex) public storageAccessControl {
		ownedTokensIndex[_tokenId] = _tokenIndex;
	}

	function getTokenIdsLength() view public returns (uint256) {
		return tokenIds.length;
	}

	function getTokenIdByIndex(uint256 _index) view public returns (uint256) {
		return tokenIds[_index];
	}

	function setTokenIdByIndex(uint256 _index, uint256 _tokenId) public storageAccessControl {
		tokenIds[_index] = _tokenId;
	}

	function pushTokenId(uint256 _tokenId) public storageAccessControl returns (uint256) {
		tokenIds.push(_tokenId);
		return tokenIds.length;
	}

	function decrementTokenIdsLength() public storageAccessControl {
		tokenIds.length--;
	}

	function getTokenIdsIndex(uint256 _tokenId) view public returns (uint256) {
		return tokenIdsIndex[_tokenId];
	}

	function setTokenIdsIndex(uint256 _tokenId, uint256 _tokenIdIndex) public storageAccessControl {
		tokenIdsIndex[_tokenId] = _tokenIdIndex;
	}

	function BdpOwnershipStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/libraries/BdpOwnership.sol

/**
 * Ownership manager
 * Does not check if the caller is allowed to call functions
 * State changing methods are not intended to be called from controller
 */
library BdpOwnership {

	using SafeMath for uint256;

	event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

	event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

	function ownerOf(address[16] _contracts, uint256 _tokenId) public view returns (address) {
		var owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);
		require(owner != address(0));
		return owner;
	}

	function balanceOf(address[16] _contracts, address _owner) public view returns (uint256) {
		return BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getOwnedTokensLength(_owner);
	}

	function approve(address[16] _contracts, address _to, uint256 _tokenId) public {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		address owner = ownerOf(_contracts, _tokenId);
		require(_to != owner);
		if (ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0) {
			ownStorage.setTokenApproval(_tokenId, _to);
			Approval(owner, _to, _tokenId);
		}
	}

	/**
	 * @dev Clear current approval of a given token ID
	 * @param _tokenId uint256 ID of the token to be transferred
	 */
	function clearApproval(address[16] _contracts, address _owner, uint256 _tokenId) public {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownerOf(_contracts, _tokenId) == _owner);
		if (ownStorage.getTokenApproval(_tokenId) != 0) {
			BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).setTokenApproval(_tokenId, 0);
			Approval(_owner, 0, _tokenId);
		}
	}

	/**
	 * @dev Clear current approval and transfer the ownership of a given token ID
	 * @param _from address which you want to send tokens from
	 * @param _to address which you want to transfer the token to
	 * @param _tokenId uint256 ID of the token to be transferred
	 */
	function clearApprovalAndTransfer(address[16] _contracts, address _from, address _to, uint256 _tokenId) public {
		require(_to != address(0));
		require(_to != ownerOf(_contracts, _tokenId));
		require(ownerOf(_contracts, _tokenId) == _from);

		clearApproval(_contracts, _from, _tokenId);
		removeToken(_contracts, _from, _tokenId);
		addToken(_contracts, _to, _tokenId);
		Transfer(_from, _to, _tokenId);
	}

	/**
	 * @dev Internal function to add a token ID to the list of a given address
	 * @param _to address representing the new owner of the given token ID
	 * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address
	 */
	function addToken(address[16] _contracts, address _to, uint256 _tokenId) private {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownStorage.getTokenOwner(_tokenId) == address(0));

		// Set token owner
		ownStorage.setTokenOwner(_tokenId, _to);

		// Add token to tokenIds list
		var tokenIdsLength = ownStorage.pushTokenId(_tokenId);
		ownStorage.setTokenIdsIndex(_tokenId, tokenIdsLength.sub(1));

		uint256 ownedTokensLength = ownStorage.getOwnedTokensLength(_to);

		// Add token to ownedTokens list
		ownStorage.pushOwnedToken(_to, _tokenId);
		ownStorage.setOwnedTokensIndex(_tokenId, ownedTokensLength);

		// Increment total owned area
		var (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);
		ownStorage.incrementOwnedArea(_to, area);
	}

	/**
	 * @dev Internal function to remove a token ID from the list of a given address
	 * @param _from address representing the previous owner of the given token ID
	 * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address
	 */
	function removeToken(address[16] _contracts, address _from, uint256 _tokenId) private {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownerOf(_contracts, _tokenId) == _from);

		// Clear token owner
		ownStorage.setTokenOwner(_tokenId, 0);

		removeFromTokenIds(ownStorage, _tokenId);
		removeFromOwnedToken(ownStorage, _from, _tokenId);

		// Decrement total owned area
		var (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);
		ownStorage.decrementOwnedArea(_from, area);
	}

	/**
	 * @dev Remove token from ownedTokens list
	 * Note that this will handle single-element arrays. In that case, both ownedTokenIndex and lastOwnedTokenIndex are going to
	 * be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping
	 * the lastOwnedToken to the first position, and then dropping the element placed in the last position of the list
	 */
	function removeFromOwnedToken(BdpOwnershipStorage _ownStorage, address _from, uint256 _tokenId) private {
		var ownedTokenIndex = _ownStorage.getOwnedTokensIndex(_tokenId);
		var lastOwnedTokenIndex = _ownStorage.getOwnedTokensLength(_from).sub(1);
		var lastOwnedToken = _ownStorage.getOwnedToken(_from, lastOwnedTokenIndex);
		_ownStorage.setOwnedToken(_from, ownedTokenIndex, lastOwnedToken);
		_ownStorage.setOwnedToken(_from, lastOwnedTokenIndex, 0);
		_ownStorage.decrementOwnedTokensLength(_from);
		_ownStorage.setOwnedTokensIndex(_tokenId, 0);
		_ownStorage.setOwnedTokensIndex(lastOwnedToken, ownedTokenIndex);
	}

	/**
	 * @dev Remove token from tokenIds list
	 */
	function removeFromTokenIds(BdpOwnershipStorage _ownStorage, uint256 _tokenId) private {
		var tokenIndex = _ownStorage.getTokenIdsIndex(_tokenId);
		var lastTokenIdIndex = _ownStorage.getTokenIdsLength().sub(1);
		var lastTokenId = _ownStorage.getTokenIdByIndex(lastTokenIdIndex);
		_ownStorage.setTokenIdByIndex(tokenIndex, lastTokenId);
		_ownStorage.setTokenIdByIndex(lastTokenIdIndex, 0);
		_ownStorage.decrementTokenIdsLength();
		_ownStorage.setTokenIdsIndex(_tokenId, 0);
		_ownStorage.setTokenIdsIndex(lastTokenId, tokenIndex);
	}

	/**
	 * @dev Mint token function
	 * @param _to The address that will own the minted token
	 * @param _tokenId uint256 ID of the token to be minted by the msg.sender
	 */
	function mint(address[16] _contracts, address _to, uint256 _tokenId) public {
		require(_to != address(0));
		addToken(_contracts, _to, _tokenId);
		Transfer(address(0), _to, _tokenId);
	}

	/**
	 * @dev Burns a specific token
	 * @param _tokenId uint256 ID of the token being burned
	 */
	function burn(address[16] _contracts, uint256 _tokenId) public {
		address owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);
		clearApproval(_contracts, owner, _tokenId);
		removeToken(_contracts, owner, _tokenId);
		Transfer(owner, address(0), _tokenId);
	}

}

// File: contracts/libraries/BdpImage.sol

library BdpImage {

	function checkImageInput(address[16] _contracts, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, bool _clearImage) view public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));

		require( (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage) // Only one way to change image can be specified
			|| (_imageId != 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage) // If image has to be changed
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length != 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage)
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; _swapImages &amp;amp;&amp;amp; !_clearImage)
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; _clearImage) );

		require(_imageId == 0 || // Can use only own images not used by other regions
			( (msg.sender == imageStorage.getImageOwner(_imageId)) &amp;amp;&amp;amp; (imageStorage.getImageCurrentRegionId(_imageId) == 0) ) );

		var nextImageId = dataStorage.getRegionNextImageId(_regionId);
		require(!_swapImages || imageUploadComplete(_contracts, nextImageId)); // Can swap images if next image upload is complete
	}

	function setNextImagePart(address[16] _contracts, uint256 _regionId, uint16 _part, uint16 _partsCount, uint16 _imageDescriptor, uint256[] _imageData) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));

		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		require(_imageData.length != 0);
		require(_part &amp;gt; 0);
		require(_part &amp;lt;= _partsCount);

		var nextImageId = dataStorage.getRegionNextImageId(_regionId);
		if(nextImageId == 0 || _imageDescriptor != imageStorage.getImageDescriptor(nextImageId)) {
			var (, width, height) = BdpCalculator.calculateArea(_contracts, _regionId);
			nextImageId = imageStorage.createImage(msg.sender, _regionId, uint16(width), uint16(height), _partsCount, _imageDescriptor);
			dataStorage.setRegionNextImageId(_regionId, nextImageId);
		}

		imageStorage.setImageData(nextImageId, _part, _imageData);
	}

	function setImageOwner(address[16] _contracts, uint256 _imageId, address _owner) public {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		require(imageStorage.getImageOwner(_imageId) == msg.sender);
		require(_owner != address(0));

		imageStorage.setImageOwner(_imageId, _owner);
	}

	function setImageData(address[16] _contracts, uint256 _imageId, uint16 _part, uint256[] _imageData) public returns (address) {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		require(imageStorage.getImageOwner(_imageId) == msg.sender);
		require(imageStorage.getImageCurrentRegionId(_imageId) == 0);
		require(_imageData.length != 0);
		require(_part &amp;gt; 0);
		require(_part &amp;lt;= imageStorage.getImagePartsCount(_imageId));

		imageStorage.setImageData(_imageId, _part, _imageData);
	}

	function imageUploadComplete(address[16] _contracts, uint256 _imageId) view public returns (bool) {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		var partsCount = imageStorage.getImagePartsCount(_imageId);
		for (uint16 i = 1; i &amp;lt;= partsCount; i++) {
			if(imageStorage.getImageDataLength(_imageId, i) == 0) {
				return false;
			}
		}
		return true;
	}

}

// File: contracts/libraries/BdpCrud.sol

library BdpCrud {

	function createRegion(address[16] _contracts, address _to, uint256 _x1, uint256 _y1, uint256 _x2, uint256 _y2) public returns (uint256) {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		require(_x2 &amp;lt; 1000 &amp;amp;&amp;amp; _x1 &amp;lt;= _x2);
		require(_y2 &amp;lt; 1000 &amp;amp;&amp;amp; _y1 &amp;lt;= _y2);

		var regionId = dataStorage.getNextRegionId();
		dataStorage.setRegionCoordinates(regionId, _x1, _y1, _x2, _y2);
		dataStorage.setRegionBlockUpdatedAt(regionId, block.number);
		dataStorage.setRegionUpdatedAt(regionId, block.timestamp);

		BdpOwnership.mint(_contracts, _to, regionId);

		return regionId;
	}

	function deleteRegion(address[16] _contracts, uint256 _regionId) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		var regionPurchasePixelPrice = dataStorage.getRegionPurchasePixelPrice(_regionId);
		require(regionPurchasePixelPrice == 0);
		BdpOwnership.burn(_contracts, _regionId);
		dataStorage.deleteRegionData(_regionId);
	}

	function setupRegion(address[16] _contracts, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, uint8[128] _url) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		require(_imageId != 0 || _imageData.length != 0 || _swapImages || _url.length != 0); // Only if image or url is specified
		require(block.timestamp &amp;lt; BdpCalculator.calculateSetupAllowedUntil(_contracts, _regionId)); // Can only execute if setup is allowed
		BdpImage.checkImageInput(_contracts, _regionId, _imageId, _imageData, _swapImages, false);

		_updateRegionImage(_contracts, dataStorage, _regionId, _imageId, _imageData, _swapImages, false);
		_updateRegionUrl(dataStorage, _regionId, _url, false);

		dataStorage.setRegionBlockUpdatedAt(_regionId, block.number);
		dataStorage.setRegionUpdatedAt(_regionId, block.timestamp);
	}

	function updateRegion(address[16] _contracts, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, bool _clearImage, uint8[128] _url, bool _deleteUrl, address _newOwner) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		BdpImage.checkImageInput(_contracts, _regionId, _imageId, _imageData, _swapImages, _clearImage);
		var regionCurrentPixelPrice = dataStorage.getRegionCurrentPixelPrice(_regionId);
		require(regionCurrentPixelPrice != 0); // region was purchased

		var marketPixelPrice = BdpCalculator.calculateCurrentMarketPixelPrice(_contracts);

		var (area,,) = BdpCalculator.calculateArea(_contracts, _regionId);
		_processUpdateFee(_contracts, marketPixelPrice * area / 20);

		_updateRegionImage(_contracts, dataStorage, _regionId, _imageId, _imageData, _swapImages, _clearImage);
		_updateRegionUrl(dataStorage, _regionId, _url, _deleteUrl);
		_updateRegionOwner(_contracts, _regionId, _newOwner);
		if(marketPixelPrice &amp;gt; regionCurrentPixelPrice) {
			dataStorage.setRegionCurrentPixelPrice(_regionId, marketPixelPrice);
		}
		dataStorage.setRegionBlockUpdatedAt(_regionId, block.number);
		dataStorage.setRegionUpdatedAt(_regionId, block.timestamp);
	}

	function updateRegionPixelPrice(address[16] _contracts, uint256 _regionId, uint256 _pixelPrice) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		var regionCurrentPixelPrice = dataStorage.getRegionCurrentPixelPrice(_regionId);
		require(regionCurrentPixelPrice != 0); // region was purchased

		var marketPixelPrice = BdpCalculator.calculateCurrentMarketPixelPrice(_contracts);
		require(_pixelPrice &amp;gt;= marketPixelPrice);

		var (area,,) = BdpCalculator.calculateArea(_contracts, _regionId);
		_processUpdateFee(_contracts, _pixelPrice * area / 20);

		dataStorage.setRegionCurrentPixelPrice(_regionId, _pixelPrice);
	}

	function _processUpdateFee(address[16] _contracts, uint256 _updateFee) internal {
		require(msg.value &amp;gt;= _updateFee);

		if(msg.value &amp;gt; _updateFee) {
			var change = msg.value - _updateFee;
			msg.sender.transfer(change);
		}

		var forwardUpdateFeesTo = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getForwardUpdateFeesTo();
		if(forwardUpdateFeesTo != address(0)) {
			forwardUpdateFeesTo.transfer(_updateFee);
		}
	}

	function _updateRegionImage(address[16] _contracts, BdpDataStorage _dataStorage, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, bool _clearImage) internal {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		var currentImageId = _dataStorage.getRegionCurrentImageId(_regionId);
		if(_imageId != 0) {
			if(currentImageId != 0) {
				imageStorage.setImageCurrentRegionId(currentImageId, 0);
			}
			_dataStorage.setRegionCurrentImageId(_regionId, _imageId);
			imageStorage.setImageCurrentRegionId(_imageId, _regionId);
		}

		if(_imageData.length &amp;gt; 0) {
			if(currentImageId != 0) {
				imageStorage.setImageCurrentRegionId(currentImageId, 0);
			}
			var (, width, height) = BdpCalculator.calculateArea(_contracts, _regionId);
			var imageId = imageStorage.createImage(msg.sender, _regionId, uint16(width), uint16(height), 1, 1);
			imageStorage.setImageData(imageId, 1, _imageData);
			_dataStorage.setRegionCurrentImageId(_regionId, imageId);
			imageStorage.setImageCurrentRegionId(imageId, _regionId);
		}

		if(_swapImages) {
			if(currentImageId != 0) {
				imageStorage.setImageCurrentRegionId(currentImageId, 0);
			}
			var nextImageId = _dataStorage.getRegionNextImageId(_regionId);
			_dataStorage.setRegionCurrentImageId(_regionId, nextImageId);
			imageStorage.setImageCurrentRegionId(nextImageId, _regionId);
			_dataStorage.setRegionNextImageId(_regionId, 0);
		}

		if(_clearImage) {
			if(currentImageId != 0) {
				imageStorage.setImageCurrentRegionId(currentImageId, 0);
			}
			_dataStorage.setRegionCurrentImageId(_regionId, 0);
		}
	}

	function _updateRegionUrl(BdpDataStorage _dataStorage, uint256 _regionId, uint8[128] _url, bool _deleteUrl) internal {
		if(_url[0] != 0) {
			_dataStorage.setRegionUrl(_regionId, _url);
		}
		if(_deleteUrl) {
			uint8[128] memory emptyUrl;
			_dataStorage.setRegionUrl(_regionId, emptyUrl);
		}
	}

	function _updateRegionOwner(address[16] _contracts, uint256 _regionId, address _newOwner) internal {
		if(_newOwner != address(0)) {
			BdpOwnership.clearApprovalAndTransfer(_contracts, msg.sender, _newOwner, _regionId);
		}
	}

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x8b27bae0dbee6070fe9950123726ba40e80539b0.sol" target="_blank" title="show github file">0x8b27bae0dbee6070fe9950123726ba40e80539b0.sol</a>
        </div>
        <div class="path">solidity-files/0x8b27bae0dbee6070fe9950123726ba40e80539b0.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT353342&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT353342
    // Name        : ADZbuzz Truepundit.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT353342&amp;quot;;
            name = &amp;quot;ADZbuzz Truepundit.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xb8492994391efc41c6eb9d2ec84f3016a87cecce.sol" target="_blank" title="show github file">0xb8492994391efc41c6eb9d2ec84f3016a87cecce.sol</a>
        </div>
        <div class="path">solidity-files/0xb8492994391efc41c6eb9d2ec84f3016a87cecce.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

library SafeMath {
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) constant returns (uint256);
  function transfer(address to, uint256 value) returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address =&amp;gt; uint256) balances;

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) /* internal? */ returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of. 
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

}

contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) returns (bool);
  function approve(address spender, uint256 value) returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract Ownable {
  address public owner;


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner {
    require(newOwner != address(0));      
    owner = newOwner;
  }

}

contract ReleasableToken is ERC20, Ownable {

  /* The finalizer contract that allows unlift the transfer limits on this token */
  address public releaseAgent;

  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/
  bool public released = false;

  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */
  mapping (address =&amp;gt; bool) public transferAgents;
  
  //dtco : time lock with specific address
  mapping(address =&amp;gt; uint) public lock_addresses;
  
  event AddLockAddress(address addr, uint lock_time);  

  /**
   * Limit token transfer until the crowdsale is over.
   *
   */
  modifier canTransfer(address _sender) {

    if(!released) {
        if(!transferAgents[_sender]) {
            revert();
        }
    }
	else {
		//check time lock with team
		if(now &amp;lt; lock_addresses[_sender]) {
			revert();
		}
	}
    _;
  }
  
  function ReleasableToken() {
	releaseAgent = msg.sender;
  }
  
  //lock new team release time
  function addLockAddressInternal(address addr, uint lock_time) inReleaseState(false) internal {
	if(addr == 0x0) revert();
	lock_addresses[addr]= lock_time;
	AddLockAddress(addr, lock_time);
  }
  
  
  /**
   * Set the contract that can call release and make the token transferable.
   *
   * Design choice. Allow reset the release agent to fix fat finger mistakes.
   */
  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {

    // We don&amp;#39;t do interface check here as we might want to a normal wallet address to act as a release agent
    releaseAgent = addr;
  }

  /**
   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.
   */
  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
    transferAgents[addr] = state;
  }
  
  /** The function can be called only by a whitelisted release agent. */
  modifier onlyReleaseAgent() {
    if(msg.sender != releaseAgent) {
        revert();
    }
    _;
  }

  /**
   * One way function to release the tokens to the wild.
   *
   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
    released = true;
  }

  /** The function can be called only before or after the tokens have been releasesd */
  modifier inReleaseState(bool releaseState) {
    if(releaseState != released) {
        revert();
    }
    _;
  }  

  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {
    // Call StandardToken.transfer()
   return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
    // Call StandardToken.transferForm()
    return super.transferFrom(_from, _to, _value);
  }

}

contract StandardToken is ERC20, BasicToken {

  mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amout of tokens to be transfered
   */
  function transferFrom(address _from, address _to, uint256 _value) /* internal */ returns (bool) {
    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value &amp;lt;= _allowance);

    balances[_to] = balances[_to].add(_value);
    balances[_from] = balances[_from].sub(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) returns (bool) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifing the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

}

contract MintableToken is StandardToken, Ownable {
  bool public mintingFinished = false;
  
  /** List of agents that are allowed to create new tokens */
  mapping (address =&amp;gt; bool) public mintAgents;

  event MintingAgentChanged(address addr, bool state  );
  event Mint(address indexed to, uint256 amount);
  event MintFinished();

  modifier onlyMintAgent() {
    // Only crowdsale contracts are allowed to mint new tokens
    if(!mintAgents[msg.sender]) {
        revert();
    }
    _;
  }
  
  modifier canMint() {
    require(!mintingFinished);
    _;
  }
  
  /**
   * Owner can allow a crowdsale contract to mint new tokens.
   */
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
    mintAgents[addr] = state;
    MintingAgentChanged(addr, state);
  }

  /**
   * @dev Function to mint tokens
   * @param _to The address that will recieve the minted tokens.
   * @param _amount The amount of tokens to mint.
   * @return A boolean that indicates if the operation was successful.
   */
  function mint(address _to, uint256 _amount) onlyMintAgent canMint returns (bool) {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    return true;
  }

  /**
   * @dev Function to stop minting new tokens.
   * @return True if the operation was successful.
   */
  function finishMinting() onlyMintAgent returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
}

contract CrowdsaleToken is ReleasableToken, MintableToken {

  string public name;

  string public symbol;

  uint public decimals;
    
  /**
   * Construct the token.
   *
   * @param _name Token name
   * @param _symbol Token symbol - should be all caps
   * @param _initialSupply How many tokens we start with
   * @param _decimals Number of decimal places
   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.
   */
  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable) {

    owner = msg.sender;

    name = _name;
    symbol = _symbol;

    totalSupply = _initialSupply;

    decimals = _decimals;

    balances[owner] = totalSupply;

    if(totalSupply &amp;gt; 0) {
      Mint(owner, totalSupply);
    }

    // No more new supply allowed after the token creation
    if(!_mintable) {
      mintingFinished = true;
      if(totalSupply == 0) {
        revert(); // Cannot create a token without supply and no minting
      }
    }
  }

  /**
   * When token is released to be transferable, enforce no new tokens can be created.
   */
   
  function releaseTokenTransfer() public onlyReleaseAgent {
    mintingFinished = true;
    super.releaseTokenTransfer();
  }
  
  //lock team address by crowdsale
  function addLockAddress(address addr, uint lock_time) onlyMintAgent inReleaseState(false) public {
	super.addLockAddressInternal(addr, lock_time);
  }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x4C4543Cc519bD78167137E95df55470dEB3a44Bf.sol" target="_blank" title="show github file">0x4C4543Cc519bD78167137E95df55470dEB3a44Bf.sol</a>
        </div>
        <div class="path">solidity-files/0x4C4543Cc519bD78167137E95df55470dEB3a44Bf.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network 
pragma solidity ^0.4.11;


/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}



/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
// Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin




/**
 * Math operations with safety checks
 */
contract SafeMath {
  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b &amp;gt; 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c&amp;gt;=a &amp;amp;&amp;amp; c&amp;gt;=b);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a &amp;gt;= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a &amp;lt; b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a &amp;gt;= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a &amp;lt; b ? a : b;
  }

}
/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */










/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}




/**
 * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.
 *
 * Based on code by FirstBlood:
 * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, SafeMath {

  /* Token supply got increased and a new owner received these tokens */
  event Minted(address receiver, uint amount);

  /* Actual balances of token holders */
  mapping(address =&amp;gt; uint) balances;

  /* approve() allowances */
  mapping (address =&amp;gt; mapping (address =&amp;gt; uint)) allowed;

  /* Interface declaration */
  function isToken() public constant returns (bool weAre) {
    return true;
  }

  function transfer(address _to, uint _value) returns (bool success) {
    balances[msg.sender] = safeSub(balances[msg.sender], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
    uint _allowance = allowed[_from][msg.sender];

    balances[_to] = safeAdd(balances[_to], _value);
    balances[_from] = safeSub(balances[_from], _value);
    allowed[_from][msg.sender] = safeSub(_allowance, _value);
    Transfer(_from, _to, _value);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint _value) returns (bool success) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    if ((_value != 0) &amp;amp;&amp;amp; (allowed[msg.sender][_spender] != 0)) throw;

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint remaining) {
    return allowed[_owner][_spender];
  }

}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */





/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * Upgrade agent interface inspired by Lunyr.
 *
 * Upgrade agent transfers tokens to a new contract.
 * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.
 */
contract UpgradeAgent {

  uint public originalSupply;

  /** Interface marker */
  function isUpgradeAgent() public constant returns (bool) {
    return true;
  }

  function upgradeFrom(address _from, uint256 _value) public;

}


/**
 * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.
 *
 * First envisioned by Golem and Lunyr projects.
 */
contract UpgradeableToken is StandardToken {

  /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */
  address public upgradeMaster;

  /** The next contract where the tokens will be migrated. */
  UpgradeAgent public upgradeAgent;

  /** How many tokens we have upgraded by now. */
  uint256 public totalUpgraded;

  /**
   * Upgrade states.
   *
   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun
   * - WaitingForAgent: Token allows upgrade, but we don&amp;#39;t have a new agent yet
   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet
   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens
   *
   */
  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}

  /**
   * Somebody has upgraded some of his tokens.
   */
  event Upgrade(address indexed _from, address indexed _to, uint256 _value);

  /**
   * New upgrade agent available.
   */
  event UpgradeAgentSet(address agent);

  /**
   * Do not allow construction without upgrade master set.
   */
  function UpgradeableToken(address _upgradeMaster) {
    upgradeMaster = _upgradeMaster;
  }

  /**
   * Allow the token holder to upgrade some of their tokens to a new contract.
   */
  function upgrade(uint256 value) public {

      UpgradeState state = getUpgradeState();
      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {
        // Called in a bad state
        throw;
      }

      // Validate input value.
      if (value == 0) throw;

      balances[msg.sender] = safeSub(balances[msg.sender], value);

      // Take tokens out from circulation
      totalSupply = safeSub(totalSupply, value);
      totalUpgraded = safeAdd(totalUpgraded, value);

      // Upgrade agent reissues the tokens
      upgradeAgent.upgradeFrom(msg.sender, value);
      Upgrade(msg.sender, upgradeAgent, value);
  }

  /**
   * Set an upgrade agent that handles
   */
  function setUpgradeAgent(address agent) external {

      if(!canUpgrade()) {
        // The token is not yet in a state that we could think upgrading
        throw;
      }

      if (agent == 0x0) throw;
      // Only a master can designate the next agent
      if (msg.sender != upgradeMaster) throw;
      // Upgrade has already begun for an agent
      if (getUpgradeState() == UpgradeState.Upgrading) throw;

      upgradeAgent = UpgradeAgent(agent);

      // Bad interface
      if(!upgradeAgent.isUpgradeAgent()) throw;
      // Make sure that token supplies match in source and target
      if (upgradeAgent.originalSupply() != totalSupply) throw;

      UpgradeAgentSet(upgradeAgent);
  }

  /**
   * Get the state of the token upgrade.
   */
  function getUpgradeState() public constant returns(UpgradeState) {
    if(!canUpgrade()) return UpgradeState.NotAllowed;
    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;
    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;
    else return UpgradeState.Upgrading;
  }

  /**
   * Change the upgrade master.
   *
   * This allows us to set a new owner for the upgrade mechanism.
   */
  function setUpgradeMaster(address master) public {
      if (master == 0x0) throw;
      if (msg.sender != upgradeMaster) throw;
      upgradeMaster = master;
  }

  /**
   * Child contract can enable to provide the condition when the upgrade can begun.
   */
  function canUpgrade() public constant returns(bool) {
     return true;
  }

}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */







/**
 * Define interface for releasing the token transfer after a successful crowdsale.
 */
contract ReleasableToken is ERC20, Ownable {

  /* The finalizer contract that allows unlift the transfer limits on this token */
  address public releaseAgent;

  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/
  bool public released = false;

  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */
  mapping (address =&amp;gt; bool) public transferAgents;

  /**
   * Limit token transfer until the crowdsale is over.
   *
   */
  modifier canTransfer(address _sender) {

    if(!released) {
        if(!transferAgents[_sender]) {
            throw;
        }
    }

    _;
  }

  /**
   * Set the contract that can call release and make the token transferable.
   *
   * Design choice. Allow reset the release agent to fix fat finger mistakes.
   */
  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {

    // We don&amp;#39;t do interface check here as we might want to a normal wallet address to act as a release agent
    releaseAgent = addr;
  }

  /**
   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.
   */
  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
    transferAgents[addr] = state;
  }

  /**
   * One way function to release the tokens to the wild.
   *
   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
    released = true;
  }

  /** The function can be called only before or after the tokens have been releasesd */
  modifier inReleaseState(bool releaseState) {
    if(releaseState != released) {
        throw;
    }
    _;
  }

  /** The function can be called only by a whitelisted release agent. */
  modifier onlyReleaseAgent() {
    if(msg.sender != releaseAgent) {
        throw;
    }
    _;
  }

  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {
    // Call StandardToken.transfer()
   return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
    // Call StandardToken.transferForm()
    return super.transferFrom(_from, _to, _value);
  }

}

/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */




/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */



/**
 * Safe unsigned safe math.
 *
 * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli
 *
 * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol
 *
 * Maintained here until merged to mainline zeppelin-solidity.
 *
 */
library SafeMathLibExt {

  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
    assert(b &amp;gt; 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c&amp;gt;=a);
    return c;
  }

}




/**
 * A token that can increase its supply by another contract.
 *
 * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.
 * Only mint agents, contracts whitelisted by owner, can mint new tokens.
 *
 */
contract MintableTokenExt is StandardToken, Ownable {

  using SafeMathLibExt for uint;

  bool public mintingFinished = false;

  /** List of agents that are allowed to create new tokens */
  mapping (address =&amp;gt; bool) public mintAgents;

  event MintingAgentChanged(address addr, bool state  );

  /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals.
  * For example, for reserved tokens in percents 2.54%
  * inPercentageUnit = 254
  * inPercentageDecimals = 2
  */
  struct ReservedTokensData {
    uint inTokens;
    uint inPercentageUnit;
    uint inPercentageDecimals;
    bool isReserved;
    bool isDistributed;
  }

  mapping (address =&amp;gt; ReservedTokensData) public reservedTokensList;
  address[] public reservedTokensDestinations;
  uint public reservedTokensDestinationsLen = 0;
  bool reservedTokensDestinationsAreSet = false;

  modifier onlyMintAgent() {
    // Only crowdsale contracts are allowed to mint new tokens
    if(!mintAgents[msg.sender]) {
        throw;
    }
    _;
  }

  /** Make sure we are not done yet. */
  modifier canMint() {
    if(mintingFinished) throw;
    _;
  }

  function finalizeReservedAddress(address addr) public onlyMintAgent canMint {
    ReservedTokensData storage reservedTokensData = reservedTokensList[addr];
    reservedTokensData.isDistributed = true;
  }

  function isAddressReserved(address addr) public constant returns (bool isReserved) {
    return reservedTokensList[addr].isReserved;
  }

  function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {
    return reservedTokensList[addr].isDistributed;
  }

  function getReservedTokens(address addr) public constant returns (uint inTokens) {
    return reservedTokensList[addr].inTokens;
  }

  function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {
    return reservedTokensList[addr].inPercentageUnit;
  }

  function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {
    return reservedTokensList[addr].inPercentageDecimals;
  }

  function setReservedTokensListMultiple(
    address[] addrs, 
    uint[] inTokens, 
    uint[] inPercentageUnit, 
    uint[] inPercentageDecimals
  ) public canMint onlyOwner {
    assert(!reservedTokensDestinationsAreSet);
    assert(addrs.length == inTokens.length);
    assert(inTokens.length == inPercentageUnit.length);
    assert(inPercentageUnit.length == inPercentageDecimals.length);
    for (uint iterator = 0; iterator &amp;lt; addrs.length; iterator++) {
      if (addrs[iterator] != address(0)) {
        setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);
      }
    }
    reservedTokensDestinationsAreSet = true;
  }

  /**
   * Create new tokens and allocate them to an address..
   *
   * Only callably by a crowdsale contract (mint agent).
   */
  function mint(address receiver, uint amount) onlyMintAgent canMint public {
    totalSupply = totalSupply.plus(amount);
    balances[receiver] = balances[receiver].plus(amount);

    // This will make the mint transaction apper in EtherScan.io
    // We can remove this after there is a standardized minting event
    Transfer(0, receiver, amount);
  }

  /**
   * Owner can allow a crowdsale contract to mint new tokens.
   */
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
    mintAgents[addr] = state;
    MintingAgentChanged(addr, state);
  }

  function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {
    assert(addr != address(0));
    if (!isAddressReserved(addr)) {
      reservedTokensDestinations.push(addr);
      reservedTokensDestinationsLen++;
    }

    reservedTokensList[addr] = ReservedTokensData({
      inTokens: inTokens, 
      inPercentageUnit: inPercentageUnit, 
      inPercentageDecimals: inPercentageDecimals,
      isReserved: true,
      isDistributed: false
    });
  }
}


/**
 * A crowdsaled token.
 *
 * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.
 *
 * - The token transfer() is disabled until the crowdsale is over
 * - The token contract gives an opt-in upgrade path to a new contract
 * - The same token can be part of several crowdsales through approve() mechanism
 * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)
 *
 */
contract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {

  /** Name and symbol were updated. */
  event UpdatedTokenInformation(string newName, string newSymbol);

  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);

  string public name;

  string public symbol;

  uint public decimals;

  /* Minimum ammount of tokens every buyer can buy. */
  uint public minCap;

  /**
   * Construct the token.
   *
   * This token must be created through a team multisig wallet, so that it is owned by that wallet.
   *
   * @param _name Token name
   * @param _symbol Token symbol - should be all caps
   * @param _initialSupply How many tokens we start with
   * @param _decimals Number of decimal places
   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.
   */
  function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)
    UpgradeableToken(msg.sender) {

    // Create any address, can be transferred
    // to team multisig via changeOwner(),
    // also remember to call setUpgradeMaster()
    owner = msg.sender;

    name = _name;
    symbol = _symbol;

    totalSupply = _initialSupply;

    decimals = _decimals;

    minCap = _globalMinCap;

    // Create initially all balance on the team multisig
    balances[owner] = totalSupply;

    if(totalSupply &amp;gt; 0) {
      Minted(owner, totalSupply);
    }

    // No more new supply allowed after the token creation
    if(!_mintable) {
      mintingFinished = true;
      if(totalSupply == 0) {
        throw; // Cannot create a token without supply and no minting
      }
    }
  }

  /**
   * When token is released to be transferable, enforce no new tokens can be created.
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
    mintingFinished = true;
    super.releaseTokenTransfer();
  }

  /**
   * Allow upgrade agent functionality kick in only if the crowdsale was success.
   */
  function canUpgrade() public constant returns(bool) {
    return released &amp;amp;&amp;amp; super.canUpgrade();
  }

  /**
   * Owner can update token information here.
   *
   * It is often useful to conceal the actual token association, until
   * the token operations, like central issuance or reissuance have been completed.
   *
   * This function allows the token owner to rename the token after the operations
   * have been completed and then point the audience to use the token contract.
   */
  function setTokenInformation(string _name, string _symbol) onlyOwner {
    name = _name;
    symbol = _symbol;

    UpdatedTokenInformation(name, symbol);
  }

  /**
   * Claim tokens that were accidentally sent to this contract.
   *
   * @param _token The address of the token contract that you want to recover.
   */
  function claimTokens(address _token) public onlyOwner {
    require(_token != address(0));

    ERC20 token = ERC20(_token);
    uint balance = token.balanceOf(this);
    token.transfer(owner, balance);

    ClaimedTokens(_token, owner, balance);
  }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x48d47d9041733592a8bb5db7d3b3053e0d6c1f51.sol" target="_blank" title="show github file">0x48d47d9041733592a8bb5db7d3b3053e0d6c1f51.sol</a>
        </div>
        <div class="path">solidity-files/0x48d47d9041733592a8bb5db7d3b3053e0d6c1f51.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT137629&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT137629
    // Name        : ADZbuzz Businessinsider.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT137629&amp;quot;;
            name = &amp;quot;ADZbuzz Businessinsider.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xbf409362f6ec3c2e327fd4d2056c237ec6da02fd.sol" target="_blank" title="show github file">0xbf409362f6ec3c2e327fd4d2056c237ec6da02fd.sol</a>
        </div>
        <div class="path">solidity-files/0xbf409362f6ec3c2e327fd4d2056c237ec6da02fd.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.16;

interface tokenRecipient { 
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; 
}

contract TokenERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 8;
    uint256 public totalSupply;
    mapping (address =&amp;gt; uint256) public balanceOf;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) public allowance;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);
    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
    }
    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] &amp;gt;= _value);
        require(balanceOf[_to] + _value &amp;gt; balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {        
        require(_value &amp;lt;= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);        
        return true;
    }
    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;        
        return true;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x49260d35e599a119102ca5b7ad1e7a931d9d8498.sol" target="_blank" title="show github file">0x49260d35e599a119102ca5b7ad1e7a931d9d8498.sol</a>
        </div>
        <div class="path">solidity-files/0x49260d35e599a119102ca5b7ad1e7a931d9d8498.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------
// &amp;#39;ACT217377&amp;#39; token contract
//
// Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
// Symbol      : ACT217377
// Name        : ADZbuzz Express.co.uk Community Token
// Total supply: 2000000
// Decimals    : 8
//
// Enjoy.
//
// (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
// (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}


// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
// ----------------------------------------------------------------------------
contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}


// ----------------------------------------------------------------------------
// Contract function to receive approval and execute function in one call
//
// Borrowed from MiniMeToken
// ----------------------------------------------------------------------------
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}


// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}


// ----------------------------------------------------------------------------
// ERC20 Token, with the addition of symbol, name and decimals and assisted
// token transfers
// ----------------------------------------------------------------------------
contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;


    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------
    function ADZbuzzCommunityToken() public {
        symbol = &amp;quot;ACT217377&amp;quot;;
        name = &amp;quot;ADZbuzz Express.co.uk Community Token&amp;quot;;
        decimals = 8;
        _totalSupply = 200000000000000;
        balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
        emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
    }


    // ------------------------------------------------------------------------
    // Total supply
    // ------------------------------------------------------------------------
    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }


    // ------------------------------------------------------------------------
    // Get the token balance for account tokenOwner
    // ------------------------------------------------------------------------
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner&amp;#39;s account to to account
    // - Owner&amp;#39;s account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces 
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    // 
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender&amp;#39;s account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner&amp;#39;s account. The spender contract function
    // receiveApproval(...) is then executed
    // ------------------------------------------------------------------------
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }


    // ------------------------------------------------------------------------
    // Don&amp;#39;t accept ETH
    // ------------------------------------------------------------------------
    function () public payable {
        revert();
    }


    // ------------------------------------------------------------------------
    // Owner can transfer out any accidentally sent ERC20 tokens
    // ------------------------------------------------------------------------
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x43c264a5df8717fa5a185006429266ef15193edc.sol" target="_blank" title="show github file">0x43c264a5df8717fa5a185006429266ef15193edc.sol</a>
        </div>
        <div class="path">solidity-files/0x43c264a5df8717fa5a185006429266ef15193edc.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) constant public returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}
 
/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract BasicToken is ERC20Basic {
    
  using SafeMath for uint256;
 
  mapping(address =&amp;gt; uint256) balances;
 
  
 
}


contract StandardToken is ERC20, BasicToken {
 
  mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;
 
  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amout of tokens to be transfered
   */

 
  /**
   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
 
    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));
 
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
 
  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifing the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
 
}

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
    
  address public owner;

  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }
 
  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  
  

 
  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function  transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));      
    owner = newOwner;
  }
  

 
}
 
 
 
 

 

library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  
  
   function pow(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    if(b==0) return 1;
    assert(b&amp;gt;=0);
    uint256 c = a ** b;
    assert(c&amp;gt;=a );
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }
  


  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
  
function compoundInterest(uint256 depo, uint256 stage2, uint256 start, uint256 current)  internal pure returns (uint256)  {
            if(current&amp;lt;start || start&amp;lt;stage2 || current&amp;lt;stage2) return depo;

            uint256 ret=depo; uint256 g; uint256 d;
            stage2=stage2/1 days;
            start=start/1 days;
            current=current/1 days;
    
			uint256 dpercent=100;
			uint256 i=start;
			
			if(i-stage2&amp;gt;365) dpercent=200;
			if(i-stage2&amp;gt;730) dpercent=1000;			
			
			while(i&amp;lt;current)
			{

				g=i-stage2;			
				if(g&amp;gt;265 &amp;amp;&amp;amp; g&amp;lt;=365) 
				{		
				    d=365-g;
					if(d&amp;gt;=(current-start))  d=(current-start);
					ret=fracExp(ret, dpercent, d, 8);
				    i+=d;
					dpercent=200;
				}
				if(g&amp;gt;630 &amp;amp;&amp;amp; g&amp;lt;=730) 
				{				
					d=730-g;	
					if(d&amp;gt;=(current-start))  d=(current-start);					
					ret=fracExp(ret, dpercent, d, 8);
					i+=d;
					dpercent=1000;					
				}
				else if(g&amp;gt;730) dpercent=1000;				
				else if(g&amp;gt;365) dpercent=200;
				
				if(i+100&amp;lt;current) ret=fracExp(ret, dpercent, 100, 8);
				else return fracExp(ret, dpercent, current-i, 8);
				i+=100;
				
			}

			return ret;
			
			
    
    
	}


function fracExp(uint256 depo, uint256 percent, uint256 period, uint256 p)  internal pure returns (uint256) {
  uint256 s = 0;
  uint256 N = 1;
  uint256 B = 1;
  

  
  for (uint256 i = 0; i &amp;lt; p; ++i){
    s += depo * N / B / (percent**i);
    N  = N * (period-i);
    B  = B * (i+1);
  }
  return s;
}







}



contract MMMTokenCoin is StandardToken, Ownable {
    using SafeMath for uint256;
    
    string public constant name = &amp;quot;Make More Money&amp;quot;;
    string public constant symbol = &amp;quot;MMM&amp;quot;;
    uint32 public constant decimals = 2;
    
	
	// Dates
	uint256 public stage2StartTime;					// timestamp when compound interest will begin
    uint256 globalInterestDate;             // last date when amount of tokens with interest was changed
    uint256 globalInterestAmount;           // amount of tokens with interest
	mapping(address =&amp;gt; uint256) dateOfStart;     // timestamp of last operation, from which interest calc will be started
	uint256 public currentDate;						// current date timestamp
	uint256 public debugNow=0;



    // Crowdsale 
    uint256 public totalSupply=99900000000;			
 uint256 public  softcap;
    uint256 public  step0Rate=100000;       // rate of our tokens. 1 eth = 1000 MMM coins = 100000 tokens (seen as 1000,00 because of decimals)
    uint256 public  currentRate=100000;   
    uint256 public constant tokensForOwner=2000000000;   // tokens for owner won&amp;#39;t dealt with compound interest
    uint256 public tokensFromEther=0;
    uint public saleStatus=0;      // 0 - sale is running, 1 - sale failed, 2 - sale successful
    address multisig=0x8216A5958f05ad61898e3A6F97ae5118C0e4b1A6;
    // counters of tokens for futher refund
    mapping(address =&amp;gt; uint256) boughtWithEther;                // tokens, bought with ether. can be refunded to ether
    mapping(address =&amp;gt; uint256) boughtWithOther;    			// tokens, bought with other payment systems. can be refunded to other payment systems, using site
    mapping(address =&amp;gt; uint256) bountyAndRefsWithEther;  		// bounty tokens, given to some people. can be converted to ether, if ico is succeed
  
    

		
		
    // events
    event RefundEther(address indexed to, uint256 tokens, uint256 eth); 
    event DateUpdated(uint256 cdate);    
    event DebugLog(string what, uint256 param);
    event Sale(address indexed to, uint256 amount);
    event Step0Finished();
    event RateSet(uint256 newRate);	
    event Burn(address indexed who, uint256 amount);
   // DEBUG

    bool bDbgEnabled=false;
	
	
	
    function MMMTokenCoin() public   {  
        // Crowdsale     
        currentDate=(getNow()/1 days)*1 days;
        stage2StartTime=getNow()+61 days;
        
        balances[owner]=tokensForOwner;
        globalInterestAmount=0;
        
        if(bDbgEnabled) softcap=20000;
        else  softcap=50000000;
    }
	
	
	function debugSetNow(uint256 n) public
	{
	    require(bDbgEnabled);
		debugNow=n;
	}
	
	
	 /**
     * @dev Returns current timestamp. In case of debugging, this function can return timestamp representing any other time
     */
     
     
	function getNow() public view returns (uint256)
	{
	    
	    if(!bDbgEnabled) return now;
	    
	    if(debugNow==0) return now;
		else return debugNow;
//		return now;
	}
   
    /**
     * @dev Sets date from which interest will be calculated for specified address
     * @param _owner - address of balance owner
     */
   
    
    function updateDate(address _owner) private {
        if(currentDate&amp;lt;stage2StartTime) dateOfStart[_owner]=stage2StartTime;
        else dateOfStart[_owner]=currentDate;
    }
    

	
    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of. 
    * @return An uint25664 representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public constant returns (uint256 balance) 
    { 
        
         return balanceWithInterest(_owner);
    }   
   
	
    /**
     * @dev Gets balance including interest for specified address
   	 * @param _owner The address to query the the balance of. 
     */
		
		
    function balanceWithInterest(address _owner)  private constant returns (uint256 ret)
    {
        if( _owner==owner || saleStatus!=2) return balances[_owner]; 
        return balances[_owner].compoundInterest(stage2StartTime, dateOfStart[_owner], currentDate);
    }
    
    
    
    
    


    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
		 
  function transfer(address _to, uint256 _value)  public returns (bool) {
    if(msg.sender==owner) {
    	// if owner sends tokens before sale finish, consider then as ether-refundable bonus
    	// else as simple transfer
        if(saleStatus==0) {
            	transferFromOwner(_to, _value,1);
            	tokensFromEther=tokensFromEther.add(_value);
				bountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].add(_value);
        	}
        	else transferFromOwner(_to, _value,0);
        	
        	increaseGlobalInterestAmount(_value);
        	return true;   
    }
    
    balances[msg.sender] = balanceWithInterest(msg.sender).sub(_value);

    emit Transfer(msg.sender, _to, _value);
    if(_to==address(this)) {
		// make refund if tokens sent to contract
        uint256 left; left=processRefundEther(msg.sender, _value);
        balances[msg.sender]=balances[msg.sender].add(left);
    }
    else {
        balances[_to] = balanceWithInterest(_to).add(_value);
        updateDate(_to);
    }
    
    if(_to==owner) 
    {
    	// before sale finish, tokens can&amp;#39;t be sent to owner
        require(saleStatus!=0);
        decreaseGlobalInterestAmount(_value);
    }
    
    updateDate(msg.sender);
    return true;
  }
  
  
  /**
    * @dev Transfer tokens from one address to another
    * @param _from address The address which you want to send tokens from
    * @param _to address The address which you want to transfer to
    * @param _value uint256 the amount of tokens to be transfered
    */
	  
  
   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
           require(_to!=owner);
    uint256 _allowance = allowed[_from][msg.sender];

     allowed[_from][msg.sender] = _allowance.sub(_value);

    if(_from==owner) {
        if(saleStatus==0) {
            transferFromOwner(_to, _value,1);
            tokensFromEther=tokensFromEther.add(_value);
			bountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].add(_value);			
        }
        else transferFromOwner(_to, _value,0);
      
        increaseGlobalInterestAmount(_value);
        return true;
    }
     
     
    balances[_from] = balanceWithInterest(_from).sub(_value);

     emit Transfer(_from, _to, _value);

    if(_to==address(this)) {
		// make refund if tokens sent to contract		   
        uint256 left; left=processRefundEther(_from, _value);
        balances[_from]=balances[_from].add(left);
    }
    else {
        balances[_to] = balanceWithInterest(_to).add(_value);
        updateDate(_to);
    }
    
    if(_to==owner) 
    {
        require(saleStatus!=0);
        decreaseGlobalInterestAmount(_value);
    }

    updateDate(_from);

    return true;
  }
  
  
  
    /**
    * @dev Burns tokens
    * @param _amount amount of tokens to burn
    */
	  
	  
	  
  function burn(uint256 _amount) public 
  {
	  	require(_amount&amp;gt;0);
        balances[msg.sender]=balanceOf(msg.sender).sub(_amount);
		decreaseGlobalInterestAmount(_amount);
        emit Burn(msg.sender, _amount);
  }
   
   //// SALE ////
   
    /**
     * @dev updates rate with whic tokens are being sold
     */

 	function setRate(uint256 r) public {
		require(saleStatus!=0);
		currentRate=r;
		emit RateSet(currentRate);
	}

    /**
     * @dev updates current date value. For compound interest calculation
     */
    
    function newDay() public   returns (bool b)
    {
        
       uint256 g; uint256 newDate;
       require(getNow()&amp;gt;=stage2StartTime);
       require(getNow()&amp;gt;=currentDate);
       newDate=(getNow()/1 days)*1 days;
        if(getNow()&amp;gt;=stage2StartTime &amp;amp;&amp;amp; saleStatus==0)
        {
            if(tokensForOwner.sub(balances[owner])&amp;gt;=softcap) saleStatus=2;
            else saleStatus=1;
         
            emit Step0Finished();
        }
      
	   // check if overall compound interest of tokens will be less than total supply
	  
       g=globalInterestAmount.compoundInterest(stage2StartTime, globalInterestDate, newDate);
       if(g&amp;lt;=totalSupply &amp;amp;&amp;amp; saleStatus==2) {
             currentDate=(getNow()/1 days)*1 days; 
             globalInterestAmount=g;
             globalInterestDate=currentDate;
             emit DateUpdated(currentDate);
             return true;
       }
       else if(saleStatus==1) currentDate=(getNow()/1 days)*1 days; 
       
       return false;
    }
    
    
    /**
     * @dev Sends collected ether to owner. If sale is not success, contract will hold ether for half year, and after, ether can be sent to owner
     * @return amount of owner&amp;#39;s ether
     */
     
    function sendEtherToMultisig() public  returns(uint256 e) {
        uint256 req;
        require(msg.sender==owner || msg.sender==multisig);
        require(saleStatus!=0);

        if(saleStatus==2) {
        	// calculate ether for refunds
        	req=tokensFromEther.mul(1 ether).div(step0Rate).div(2);

        	if(bDbgEnabled) emit DebugLog(&amp;quot;This balance is&amp;quot;, this.balance);
        	if(req&amp;gt;=this.balance) return 0;
    	}
    	else if(saleStatus==1) {
    		require(getNow()-stage2StartTime&amp;gt;15768000);
    		req=0; 
    	}
        uint256 amount;
        amount=this.balance.sub(req);
        multisig.transfer(amount);
        return amount;
        
    }
    
	


	
	
	/**
		Refund functions. 
		If ico is success, anyone can get 0.000005 eth for 1 token,  else 00001 eth
		
	*/
	
    /**
     * @dev Refunds ether to sender if he trasnfered tokens to contract address. Calculates max possible amount of refund. If sent tokens&amp;gt;refund amound, tokens will be returned to sender.
     * @param _to Address of refund receiver
     * @param _value Tokens requested for refund
     */
	
    function processRefundEther(address _to, uint256 _value) private returns (uint256 left)
    {
        require(saleStatus!=0);
        require(_value&amp;gt;0);
        uint256 Ether=0; uint256 bounty=0;  uint256 total=0;

        uint256 rate2=saleStatus;

        
        if(_value&amp;gt;=boughtWithEther[_to]) {Ether=Ether.add(boughtWithEther[_to]); _value=_value.sub(boughtWithEther[_to]); }
        else {Ether=Ether.add(_value); _value=_value.sub(Ether);}
        boughtWithEther[_to]=boughtWithEther[_to].sub(Ether);
        
        if(rate2==2) {        
            if(_value&amp;gt;=bountyAndRefsWithEther[_to]) {bounty=bounty.add(bountyAndRefsWithEther[_to]); _value=_value.sub(bountyAndRefsWithEther[_to]); }
            else { bounty=bounty.add(_value); _value=_value.sub(bounty); }
            bountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].sub(bounty);
        }
        total=Ether.add(bounty);
     //   if(_value&amp;gt;total) _value=_value.sub(total);
        tokensFromEther=tokensFromEther.sub(total);
       uint256 eth=total.mul(1 ether).div(step0Rate).div(rate2);
         _to.transfer(eth);
        if(bDbgEnabled) emit DebugLog(&amp;quot;Will refund &amp;quot;, eth);

        emit RefundEther(_to, total, eth);
        decreaseGlobalInterestAmount(total);
        return _value;
    }
    
    
	

	     /**
     * @dev Returns info about refundable tokens- bought with ether, payment systems, and bonus tokens convertable to ether
     */
	
	function getRefundInfo(address _to) public returns (uint256, uint256, uint256)
	{
	    return  ( boughtWithEther[_to],  boughtWithOther[_to],  bountyAndRefsWithEther[_to]);
	    
	}
	
    
    /**
     * @dev Withdraw tokens  refunded to other payment systems.
     * @param _to Address of refund receiver
     */
    
    function refundToOtherProcess(address _to, uint256 _value) public onlyOwner returns (uint256 o) {
        require(saleStatus!=0);
        //uint256 maxValue=refundToOtherGet(_to);
        uint256 maxValue=0;
        require(_value&amp;lt;=maxValue);
        
        uint256 Other=0; uint256 bounty=0; 



        
        if(_value&amp;gt;=boughtWithOther[_to]) {Other=Other.add(boughtWithOther[_to]); _value=_value.sub(boughtWithOther[_to]); }
        else {Other=Other.add(_value); _value=_value.sub(Other);}
        boughtWithOther[_to]=boughtWithOther[_to].sub(Other);

       
        balances[_to]=balanceOf(_to).sub(Other).sub(bounty);
        updateDate(_to);
        decreaseGlobalInterestAmount(Other.add(bounty));
        return _value;
        
        
    }
    
 
    /**
     * @dev Converts ether to our tokens 
     */
		  
    
    function createTokensFromEther()  private   {
               
        assert(msg.value &amp;gt;= 1 ether / 1000);
       
         uint256 tokens = currentRate.mul(msg.value).div(1 ether);


        transferFromOwner(msg.sender, tokens,2);
      
       if(saleStatus==0) {
           boughtWithEther[msg.sender]=boughtWithEther[msg.sender].add(tokens);
            tokensFromEther=tokensFromEther.add(tokens);
       }
      
    }
	
	
    /**
     * @dev Converts other payments system payment to  tokens. Main logic is on site
     */
    
    function createTokensFromOther(address _to, uint256 howMuch, address referer) public  onlyOwner   { 
      
        require(_to!=address(this));
         transferFromOwner(_to, howMuch,2);
         if(referer!=0 &amp;amp;&amp;amp; referer!=address(this) &amp;amp;&amp;amp; referer!=0x0000000000000000000000000000000000000000 &amp;amp;&amp;amp; howMuch.div(10)&amp;gt;0) {
             transferFromOwner(referer, howMuch.div(10),1);
	         if(saleStatus==0) {
	             	tokensFromEther=tokensFromEther.add( howMuch.div(10));
	 				bountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].add( howMuch.div(10));
	         	}
         }
         if(saleStatus==0) boughtWithOther[_to]= boughtWithOther[_to].add(howMuch);
    }

	   /**
     * @dev Gives refs tokens through payment on site. Main logic is on site
     * @param _to Address of  receiver
     * @param _amount Amount of tokens		
	 * @param t type of transfer. 0 is transfer, 1 bonus tokens, 2 - sale
     */
	
	function transferFromOwner(address _to, uint256 _amount, uint t) private {
	   require(_to!=address(this) &amp;amp;&amp;amp; _to!=address(owner) );
        balances[owner]=balances[owner].sub(_amount); 
        balances[_to]=balanceOf(_to).add(_amount);
        updateDate(_to);

        increaseGlobalInterestAmount(_amount);
	    
	   
	     if(t==2) emit Sale(_to, _amount);
        emit Transfer(owner, _to, _amount);	     
	}
	

    function increaseGlobalInterestAmount(uint256 c) private 
    {
        globalInterestAmount=globalInterestAmount.add(c);
		
    }
    
    function decreaseGlobalInterestAmount(uint256 c) private
    {
        if(c&amp;lt;globalInterestAmount) {
            globalInterestAmount=globalInterestAmount.sub(c);
        }
            
        
    }
    
    function() external payable {
        createTokensFromEther();
    }

    
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x8857f56f97c7dc66c0a8e40818d630f27a40cf3a.sol" target="_blank" title="show github file">0x8857f56f97c7dc66c0a8e40818d630f27a40cf3a.sol</a>
        </div>
        <div class="path">solidity-files/0x8857f56f97c7dc66c0a8e40818d630f27a40cf3a.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

library SafeMath {
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c &amp;gt;= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b &amp;lt;= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {
        require(b &amp;gt; 0);
        c = a / b;
    }
}

contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}

contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}

contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}

contract FrameCoin is ERC20Interface, Owned {
    using SafeMath for uint;

    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;
    string public IPFSHash;
    

    mapping(address =&amp;gt; uint) balances;
    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;

    function FrameCoin () public {
        symbol = &amp;quot;FCT&amp;quot;;
        name = &amp;quot;Frame Coin Token&amp;quot;;
        decimals = 18;
        _totalSupply = 100 * 10**uint(decimals);
        balances[owner] = _totalSupply;
        Transfer(address(0), owner, _totalSupply);
        IPFSHash = &amp;quot;QmTT2Zh1JYXyk8qWrSyYjBBGTTNMZYZZV4TkGBJX2C1mzm&amp;quot;;
    }

    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }

    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    }

    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        Transfer(from, to, tokens);
        return true;
    }

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }

    function () public payable {
        revert();
    }

    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x97b1649cb34b6d28c121547fb59f73187e6b03e2.sol" target="_blank" title="show github file">0x97b1649cb34b6d28c121547fb59f73187e6b03e2.sol</a>
        </div>
        <div class="path">solidity-files/0x97b1649cb34b6d28c121547fb59f73187e6b03e2.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.21;

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }


contract token {
    /* 公共变量 */
    string public name; //代币名称
    string public symbol; //代币符号
    uint8 public decimals = 4;  //代币单位，展示的小数点后面多少个0
    uint256 public totalSupply; //代币总量

    /*记录所有余额的映射*/
    mapping (address =&amp;gt; uint256) public balanceOf;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) public allowance;


    event Transfer(address indexed from, address indexed to, uint256 value);  //转帐通知事件
    event Burn(address indexed from, uint256 value);  //减去用户余额事件

    /* 初始化合约，并且把初始的所有代币都给这合约的创建者
     * @param initialSupply 代币的总数
     * @param tokenName 代币名称
     * @param tokenSymbol 代币符号
     */
    function token(uint256 initialSupply, string tokenName, string tokenSymbol) public {

        //初始化总量
        totalSupply = initialSupply * 10 ** uint256(decimals);    

        //给指定帐户初始化代币总量，初始化用于奖励合约创建者
        balanceOf[msg.sender] = totalSupply;

        name = tokenName;
        symbol = tokenSymbol;

    }


    /**
     * 私有方法从一个帐户发送给另一个帐户代币
     * @param  _from address 发送代币的地址
     * @param  _to address 接受代币的地址
     * @param  _value uint256 接受代币的数量
     */
    function _transfer(address _from, address _to, uint256 _value) internal {

      //避免转帐的地址是0x0
      require(_to != 0x0);

      //检查发送者是否拥有足够余额
      require(balanceOf[_from] &amp;gt;= _value);

      //检查是否溢出
      require(balanceOf[_to] + _value &amp;gt; balanceOf[_to]);

      //保存数据用于后面的判断
      uint previousBalances = balanceOf[_from] + balanceOf[_to];

      //从发送者减掉发送额
      balanceOf[_from] -= _value;

      //给接收者加上相同的量
      balanceOf[_to] += _value;

      //通知任何监听该交易的客户端
      Transfer(_from, _to, _value);

      //判断买、卖双方的数据是否和转换前一致
      assert(balanceOf[_from] + balanceOf[_to] == previousBalances);

    }

    /**
     * 从主帐户合约调用者发送给别人代币
     * @param  _to address 接受代币的地址
     * @param  _value uint256 接受代币的数量
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * 从某个指定的帐户中，向另一个帐户发送代币
     *
     * 调用过程，会检查设置的允许最大交易额
     *
     * @param  _from address 发送者地址
     * @param  _to address 接受者地址
     * @param  _value uint256 要转移的代币数量
     * @return success        是否交易成功
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){
        //检查发送者是否拥有足够余额
        require(_value &amp;lt;= allowance[_from][msg.sender]);   // Check allowance

        allowance[_from][msg.sender] -= _value;

        _transfer(_from, _to, _value);

        return true;
    }

    /**
     * 设置帐户允许支付的最大金额
     *
     * 一般在智能合约的时候，避免支付过多，造成风险
     *
     * @param _spender 帐户地址
     * @param _value 金额
     */
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * 设置帐户允许支付的最大金额
     *
     * 一般在智能合约的时候，避免支付过多，造成风险，加入时间参数，可以在 tokenRecipient 中做其他操作
     *
     * @param _spender 帐户地址
     * @param _value 金额
     * @param _extraData 操作的时间
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * 减少代币调用者的余额
     *
     * 操作以后是不可逆的
     *
     * @param _value 要删除的数量
     */
    function burn(uint256 _value) public returns (bool success) {
        //检查帐户余额是否大于要减去的值
        require(balanceOf[msg.sender] &amp;gt;= _value);   // Check if the sender has enough

        //给指定帐户减去余额
        balanceOf[msg.sender] -= _value;

        //代币问题做相应扣除
        totalSupply -= _value;

        Burn(msg.sender, _value);
        return true;
    }

    /**
     * 删除帐户的余额（含其他帐户）
     *
     * 删除以后是不可逆的
     *
     * @param _from 要操作的帐户地址
     * @param _value 要减去的数量
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {

        //检查帐户余额是否大于要减去的值
        require(balanceOf[_from] &amp;gt;= _value);

        //检查 其他帐户 的余额是否够使用
        require(_value &amp;lt;= allowance[_from][msg.sender]);

        //减掉代币
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;

        //更新总量
        totalSupply -= _value;
        Burn(_from, _value);
        return true;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x507d37ea5fe6bd334d0c50db12f35ddfcb1b6a3f.sol" target="_blank" title="show github file">0x507d37ea5fe6bd334d0c50db12f35ddfcb1b6a3f.sol</a>
        </div>
        <div class="path">solidity-files/0x507d37ea5fe6bd334d0c50db12f35ddfcb1b6a3f.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.16;

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }

contract KaliToken {
    // Public variables of the token
    string public name = &amp;quot;KALI TOKEN&amp;quot;;
    string public symbol = &amp;quot;KAL&amp;quot;;
    uint8 public decimals = 0;
    // 18 decimals is the strongly suggested default
    uint256 public totalSupply;
    uint256 public kaliSupply = 20000000;
    uint256 public price ;
    address public creator;
    // This creates an array with all balances
    mapping (address =&amp;gt; uint256) public balanceOf;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);
    event FundTransfer(address backer, uint amount, bool isContribution);
    
    
    /**
     * Constrctor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function KaliToken() public {
        totalSupply = kaliSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;    // Give KaliToken Mint the total created tokens
        creator = msg.sender;
    }
    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] &amp;gt;= _value);
        // Check for overflows
        require(balanceOf[_to] + _value &amp;gt;= balanceOf[_to]);
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
      
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    
    /// @notice Buy tokens from contract by sending ether
    function () payable internal {
        
        if (price &amp;gt;= 0 ether &amp;amp;&amp;amp; price &amp;lt; 0.005 ether){
        uint ammount = 2000;                  // calculates the amount, made it so you can get many KaliToken but to get MANY KaliToken you have to spend ETH and not WEI
        uint ammountRaised;                                     
        amountRaised += msg.value;                            //many thanks kali, couldnt do it without r/me_irl
        require(balanceOf[creator] &amp;gt;= ammount);               // checks if it has enough to sell
        require(msg.value &amp;lt; 0.1 ether);                        // so any person who wants to put more then 0.1 ETH has time to think about what they are doing
        balanceOf[msg.sender] += ammount;                  // adds the amount to buyer&amp;#39;s balance
        balanceOf[creator] -= ammount;                        // sends ETH to KaliXMinth
        Transfer(creator, msg.sender, ammount);               // execute an event reflecting the change
        creator.transfer(ammountRaised);
        }
        if (price &amp;gt;= 0.005 ether &amp;amp;&amp;amp; price &amp;lt; 0.03 ether){
        uint amount = 2000;                  // calculates the amount, made it so you can get many KaliToken but to get MANY KaliToken you have to spend ETH and not WEI
        uint amountRaised;                                     
        amountRaised += msg.value;                            //many thanks kali, couldnt do it without r/me_irl
        require(balanceOf[creator] &amp;gt;= amount);               // checks if it has enough to sell
        require(msg.value &amp;lt; 0.1 ether);                        // so any person who wants to put more then 0.1 ETH has time to think about what they are doing
        balanceOf[msg.sender] += amount;                  // adds the amount to buyer&amp;#39;s balance
        balanceOf[creator] -= amount;                        // sends ETH to KaliXMinth
        Transfer(creator, msg.sender, amount);               // execute an event reflecting the change
        creator.transfer(ammountRaised);
        }
         if (price &amp;gt;= 0.03 ether){
        uint amnount = 10000;                  // calculates the amount, made it so you can get many KaliToken but to get MANY  you have to spend ETH and not WEI
        uint amnountRaised;                                     
        amountRaised += msg.value;                            //many thanks kalix, couldnt do it without r/me_irl
        require(balanceOf[creator] &amp;gt;= amnount);               // checks if it has enough to sell
        require(msg.value &amp;lt; 0.1 ether);                        // so any person who wants to put more then 0.1 ETH has time to think about what they are doing
        balanceOf[msg.sender] += amnount;                  // adds the amount to buyer&amp;#39;s balance
        balanceOf[creator] -= amnount;                        // sends ETH to KaliXMinth
        Transfer(creator, msg.sender, amnount);               // execute an event reflecting the change
        creator.transfer(amnountRaised);
        }
    }

 }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x68fd0ec88a200c926e0f8aef306af64b7cdb2c42.sol" target="_blank" title="show github file">0x68fd0ec88a200c926e0f8aef306af64b7cdb2c42.sol</a>
        </div>
        <div class="path">solidity-files/0x68fd0ec88a200c926e0f8aef306af64b7cdb2c42.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}
/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances. 
 */
contract BasicToken is ERC20Basic, Ownable {
  using SafeMath for uint256;

  mapping(address =&amp;gt; uint256) balances;

 uint256 totalSupply_;

  /**
  * @dev total number of tokens in existence
  */
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }


  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
 function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of. 
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}


/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

  mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transfered
   */
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[_from]);
    require(_value &amp;lt;= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
 function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
   function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }
  
 
  
  /**
   * @dev Function to revert eth transfers to this contract
    */
    function() public payable {
	    revert();
	}
	
	
   /**
   * @dev  Owner can transfer out any accidentally sent ERC20 tokens
   */
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return BasicToken(tokenAddress).transfer(owner, tokens);
    }
	
  /**
    * @dev Transfer the specified amounts of tokens to the specified addresses.
    * @dev Be aware that there is no check for duplicate recipients.
    *
    * @param _toAddresses Receiver addresses.
    * @param _amounts Amounts of tokens that will be transferred.
    */
    function multiSend(address[] _toAddresses, uint256[] _amounts) public {
        /* Ensures _toAddresses array is less than or equal to 255 */
        require(_toAddresses.length &amp;lt;= 255);
        /* Ensures _toAddress and _amounts have the same number of entries. */
        require(_toAddresses.length == _amounts.length);

        for (uint8 i = 0; i &amp;lt; _toAddresses.length; i++) {
            transfer(_toAddresses[i], _amounts[i]);
        }
    }

    /**
    * @dev Transfer the specified amounts of tokens to the specified addresses from authorized balance of sender.
    * @dev Be aware that there is no check for duplicate recipients.
    *
    * @param _from The address of the sender
    * @param _toAddresses The addresses of the recipients (MAX 255)
    * @param _amounts The amounts of tokens to be transferred
    */
    function multiSendFrom(address _from, address[] _toAddresses, uint256[] _amounts) public {
        /* Ensures _toAddresses array is less than or equal to 255 */
        require(_toAddresses.length &amp;lt;= 255);
        /* Ensures _toAddress and _amounts have the same number of entries. */
        require(_toAddresses.length == _amounts.length);

        for (uint8 i = 0; i &amp;lt; _toAddresses.length; i++) {
            transferFrom(_from, _toAddresses[i], _amounts[i]);
        }
    }
	
}

	
 /**
 * @title Burnable Token
 * @dev Token that can be irreversibly burned (destroyed).
 */
contract BurnableToken is BasicToken {

  event Burn(address indexed burner, uint256 value);

 
   /**
   * @dev Burns a specific amount of tokens.
   * @param _value The amount of token to be burned.
   */
  function burn(uint256 _value) public {
    require(_value &amp;lt;= balances[msg.sender]);
    // no need to require value &amp;lt;= totalSupply, since that would imply the
    // sender&amp;#39;s balance is greater than the totalSupply, which *should* be an assertion failure

    address burner = msg.sender;
    balances[burner] = balances[burner].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    Burn(burner, _value);
    Transfer(burner, address(0), _value);
  }
  }

 
contract GreenEnergy is StandardToken, BurnableToken {

  string public constant name = &amp;quot;Green Energy&amp;quot;;
  string public constant symbol = &amp;quot;GNRG&amp;quot;;
  uint8 public constant decimals = 18; 

  uint256 public constant INITIAL_SUPPLY = 10000000000 * (10 ** uint256(decimals));

  
  function GreenEnergy() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x93fcd82fe7370fb367b7cc48477e93048b14a1ca.sol" target="_blank" title="show github file">0x93fcd82fe7370fb367b7cc48477e93048b14a1ca.sol</a>
        </div>
        <div class="path">solidity-files/0x93fcd82fe7370fb367b7cc48477e93048b14a1ca.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

contract Ownable {
  address public owner;


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner {
    require(newOwner != address(0));      
    owner = newOwner;
  }

}

library SafeMath {
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) constant returns (uint256);
  function transfer(address to, uint256 value) returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address =&amp;gt; uint256) balances;

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) /* internal? */ returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of. 
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

}

contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) returns (bool);
  function approve(address spender, uint256 value) returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract StandardToken is ERC20, BasicToken {

  mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amout of tokens to be transfered
   */
  function transferFrom(address _from, address _to, uint256 _value) /* internal */ returns (bool) {
    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value &amp;lt;= _allowance);

    balances[_to] = balances[_to].add(_value);
    balances[_from] = balances[_from].sub(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) returns (bool) {

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifing the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

}

contract MintableToken is StandardToken, Ownable {
  bool public mintingFinished = false;
  
  /** List of agents that are allowed to create new tokens */
  mapping (address =&amp;gt; bool) public mintAgents;

  event MintingAgentChanged(address addr, bool state  );
  event Mint(address indexed to, uint256 amount);
  event MintFinished();

  modifier onlyMintAgent() {
    // Only crowdsale contracts are allowed to mint new tokens
    if(!mintAgents[msg.sender]) {
        revert();
    }
    _;
  }
  
  modifier canMint() {
    require(!mintingFinished);
    _;
  }
  
  /**
   * Owner can allow a crowdsale contract to mint new tokens.
   */
  function setMintAgent(address addr, bool state) onlyOwner canMint public {
    mintAgents[addr] = state;
    MintingAgentChanged(addr, state);
  }

  /**
   * @dev Function to mint tokens
   * @param _to The address that will recieve the minted tokens.
   * @param _amount The amount of tokens to mint.
   * @return A boolean that indicates if the operation was successful.
   */
  function mint(address _to, uint256 _amount) onlyMintAgent canMint returns (bool) {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    return true;
  }

  /**
   * @dev Function to stop minting new tokens.
   * @return True if the operation was successful.
   */
  function finishMinting() onlyMintAgent returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
}

contract ReleasableToken is ERC20, Ownable {

  /* The finalizer contract that allows unlift the transfer limits on this token */
  address public releaseAgent;

  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/
  bool public released = false;

  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */
  mapping (address =&amp;gt; bool) public transferAgents;
  
  //dtco : time lock with specific address
  mapping(address =&amp;gt; uint) public lock_addresses;
  
  event AddLockAddress(address addr, uint lock_time);  

  /**
   * Limit token transfer until the crowdsale is over.
   *
   */
  modifier canTransfer(address _sender) {

    if(!released) {
        if(!transferAgents[_sender]) {
            revert();
        }
    }
	else {
		//check time lock with team
		if(now &amp;lt; lock_addresses[_sender]) {
			revert();
		}
	}
    _;
  }
  
  function ReleasableToken() {
	releaseAgent = msg.sender;
  }
  
  //lock new team release time
  function addLockAddressInternal(address addr, uint lock_time) inReleaseState(false) internal {
	if(addr == 0x0) revert();
	lock_addresses[addr]= lock_time;
	AddLockAddress(addr, lock_time);
  }
  
  
  /**
   * Set the contract that can call release and make the token transferable.
   *
   * Design choice. Allow reset the release agent to fix fat finger mistakes.
   */
  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {

    // We don&amp;#39;t do interface check here as we might want to a normal wallet address to act as a release agent
    releaseAgent = addr;
  }

  /**
   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.
   */
  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {
    transferAgents[addr] = state;
  }
  
  /** The function can be called only by a whitelisted release agent. */
  modifier onlyReleaseAgent() {
    if(msg.sender != releaseAgent) {
        revert();
    }
    _;
  }

  /**
   * One way function to release the tokens to the wild.
   *
   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).
   */
  function releaseTokenTransfer() public onlyReleaseAgent {
    released = true;
  }

  /** The function can be called only before or after the tokens have been releasesd */
  modifier inReleaseState(bool releaseState) {
    if(releaseState != released) {
        revert();
    }
    _;
  }  

  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {
    // Call StandardToken.transfer()
   return super.transfer(_to, _value);
  }

  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {
    // Call StandardToken.transferForm()
    return super.transferFrom(_from, _to, _value);
  }

}

contract Haltable is Ownable {
  bool public halted;

  modifier stopInEmergency {
    if (halted) revert();
    _;
  }

  modifier onlyInEmergency {
    if (!halted) revert();
    _;
  }

  // called by the owner on emergency, triggers stopped state
  function halt() external onlyOwner {
    halted = true;
  }

  // called by the owner on end of emergency, returns to normal state
  function unhalt() external onlyOwner onlyInEmergency {
    halted = false;
  }

}

contract CrowdsaleLimit {
  using SafeMath for uint256;

  // the UNIX timestamp start date of the crowdsale
  uint public startsAt;
  // the UNIX timestamp end date of the crowdsale
  uint public endsAt;
  // setting the max token 
  uint public TOKEN_MAX;
  // seting the wei value for one token in presale stage
  uint public PRESALE_TOKEN_IN_WEI = 9 finney;
  // total eth fund in presale stage
  uint public presale_eth_fund= 0;
  
  // seting the wei value for one token in crowdsale stage
  uint public CROWDSALE_TOKEN_IN_WEI = 10 finney;  
  
  // seting the max fund of presale with eth
  uint public PRESALE_ETH_IN_WEI_FUND_MAX = 0 ether; 
  // seting the min fund of crowdsale with eth
  uint public CROWDSALE_ETH_IN_WEI_FUND_MIN = 100 ether;
  // seting the max fund of crowdsale with eth
  uint public CROWDSALE_ETH_IN_WEI_FUND_MAX = 1000 ether;
  // seting the min acceptable invest with eth
  uint public CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN = 100 finney;   //0.1 ether
  // seting the gasprice to limit big buyer, default to disable
  uint public CROWDSALE_GASPRICE_IN_WEI_MAX = 0;
 
  // total eth fund
  uint public crowdsale_eth_fund= 0;
  // total eth refund
  uint public crowdsale_eth_refund = 0;
   
  // setting team list and set percentage of tokens
  mapping(address =&amp;gt; uint) public team_addresses_token_percentage;
  mapping(uint =&amp;gt; address) public team_addresses_idx;
  uint public team_address_count= 0;
  uint public team_token_percentage_total= 0;
  uint public team_token_percentage_max= 0;
    
  event EndsAtChanged(uint newEndsAt);
  event AddTeamAddress(address addr, uint release_time, uint token_percentage);
  event Refund(address investor, uint weiAmount);
    
  // limitation of buying tokens
  modifier allowCrowdsaleAmountLimit(){	
	if (msg.value == 0) revert();
	if (msg.value &amp;lt; CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN) revert();
	if((crowdsale_eth_fund.add(msg.value)) &amp;gt; CROWDSALE_ETH_IN_WEI_FUND_MAX) revert();
	if((CROWDSALE_GASPRICE_IN_WEI_MAX &amp;gt; 0) &amp;amp;&amp;amp; (tx.gasprice &amp;gt; CROWDSALE_GASPRICE_IN_WEI_MAX)) revert();
	_;
  }  
   
  function CrowdsaleLimit(uint _start, uint _end, uint _token_max, uint _presale_token_in_wei, uint _crowdsale_token_in_wei, uint _presale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_fund_min, uint _crowdsale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_accepted_min, uint _crowdsale_gasprice_inwei_max, uint _team_token_percentage_max) {
	require(_start != 0);
	require(_end != 0);
	require(_start &amp;lt; _end);
	
	if( (_presale_token_in_wei == 0) ||
	    (_crowdsale_token_in_wei == 0) ||
		(_crowdsale_eth_inwei_fund_min == 0) ||
		(_crowdsale_eth_inwei_fund_max == 0) ||
		(_crowdsale_eth_inwei_accepted_min == 0) ||
		(_team_token_percentage_max &amp;gt;= 100))  //example 20%=20
		revert();
		
	startsAt = _start;
    endsAt = _end;
	
	TOKEN_MAX = _token_max;
		
	PRESALE_TOKEN_IN_WEI = _presale_token_in_wei;
	
	CROWDSALE_TOKEN_IN_WEI = _crowdsale_token_in_wei;	
	PRESALE_ETH_IN_WEI_FUND_MAX = _presale_eth_inwei_fund_max;
	CROWDSALE_ETH_IN_WEI_FUND_MIN = _crowdsale_eth_inwei_fund_min;
	CROWDSALE_ETH_IN_WEI_FUND_MAX = _crowdsale_eth_inwei_fund_max;
	CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN = _crowdsale_eth_inwei_accepted_min;
	CROWDSALE_GASPRICE_IN_WEI_MAX = _crowdsale_gasprice_inwei_max;
	
	team_token_percentage_max= _team_token_percentage_max;
  }
    
  // caculate amount of token in presale stage
  function calculateTokenPresale(uint value, uint decimals) /*internal*/ public constant returns (uint) {
    uint multiplier = 10 ** decimals;
    return value.mul(multiplier).div(PRESALE_TOKEN_IN_WEI);
  }
  
  // caculate amount of token in crowdsale stage
  function calculateTokenCrowsale(uint value, uint decimals) /*internal*/ public constant returns (uint) {
    uint multiplier = 10 ** decimals;
    return value.mul(multiplier).div(CROWDSALE_TOKEN_IN_WEI);
  }
  
  // check if the goal is reached
  function isMinimumGoalReached() public constant returns (bool) {
    return crowdsale_eth_fund &amp;gt;= CROWDSALE_ETH_IN_WEI_FUND_MIN;
  }
  
  // add new team percentage of tokens
  function addTeamAddressInternal(address addr, uint release_time, uint token_percentage) internal {
	if((team_token_percentage_total.add(token_percentage)) &amp;gt; team_token_percentage_max) revert();
	if((team_token_percentage_total.add(token_percentage)) &amp;gt; 100) revert();
	if(team_addresses_token_percentage[addr] != 0) revert();
	
	team_addresses_token_percentage[addr]= token_percentage;
	team_addresses_idx[team_address_count]= addr;
	team_address_count++;
	
	team_token_percentage_total = team_token_percentage_total.add(token_percentage);

	AddTeamAddress(addr, release_time, token_percentage);
  }
   
  // @return true if crowdsale event has ended
  function hasEnded() public constant returns (bool) {
    return now &amp;gt; endsAt;
  }
}

contract Crowdsale is CrowdsaleLimit, Haltable {
  using SafeMath for uint256;

  CrowdsaleToken public token;
  
  /* tokens will be transfered from this address */
  address public multisigWallet;
    
  /** How much ETH each address has invested to this crowdsale */
  mapping (address =&amp;gt; uint256) public investedAmountOf;

  /** How much tokens this crowdsale has credited for each investor address */
  mapping (address =&amp;gt; uint256) public tokenAmountOf;
  
  /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */
  mapping (address =&amp;gt; bool) public presaleWhitelist;
  
  bool public whitelist_enable= true;
  
  /* the number of tokens already sold through this contract*/
  uint public tokensSold = 0;
  
  /* How many distinct addresses have invested */
  uint public investorCount = 0;
  
  /* How much wei we have returned back to the contract after a failed crowdfund. */
  uint public loadedRefund = 0;
  
  /* Has this crowdsale been finalized */
  bool public finalized;
  
  enum State{Unknown, PreFunding, Funding, Success, Failure, Finalized, Refunding}
    
  // A new investment was made
  event Invested(address investor, uint weiAmount, uint tokenAmount);
  
  // Address early participation whitelist status changed
  event Whitelisted(address addr, bool status);
  
  event createTeamTokenEvent(address addr, uint tokens);
  
  event Finalized();
  
  /** Modified allowing execution only if the crowdsale is currently running.  */
  modifier inState(State state) {
    if(getState() != state) revert();
    _;
  }

  function Crowdsale(address _token, address _multisigWallet, uint _start, uint _end, uint _token_max, uint _presale_token_in_wei, uint _crowdsale_token_in_wei, uint _presale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_fund_min, uint _crowdsale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_accepted_min, uint _crowdsale_gasprice_inwei_max, uint _team_token_percentage_max, bool _whitelist_enable) 
           CrowdsaleLimit(_start, _end, _token_max, _presale_token_in_wei, _crowdsale_token_in_wei, _presale_eth_inwei_fund_max, _crowdsale_eth_inwei_fund_min, _crowdsale_eth_inwei_fund_max, _crowdsale_eth_inwei_accepted_min, _crowdsale_gasprice_inwei_max, _team_token_percentage_max)
  {
    require(_token != 0x0);
    require(_multisigWallet != 0x0);
	
	token = CrowdsaleToken(_token);	
	multisigWallet = _multisigWallet;
	
	whitelist_enable= _whitelist_enable;
  }
  
  /* Crowdfund state machine management. */
  function getState() public constant returns (State) {
    if(finalized) return State.Finalized;
    else if (now &amp;lt; startsAt) return State.PreFunding;
    else if (now &amp;lt;= endsAt &amp;amp;&amp;amp; !isMinimumGoalReached()) return State.Funding;
    else if (isMinimumGoalReached()) return State.Success;
    else if (!isMinimumGoalReached() &amp;amp;&amp;amp; crowdsale_eth_fund &amp;gt; 0 &amp;amp;&amp;amp; loadedRefund &amp;gt;= crowdsale_eth_fund) return State.Refunding;
    else return State.Failure;
  }
   
  /**
   * Allow addresses to do early participation.
   *
   * TODO: Fix spelling error in the name
   */
  function setPresaleWhitelist(address addr, bool status) onlyOwner inState(State.PreFunding) {
	require(whitelist_enable==true);

    presaleWhitelist[addr] = status;
    Whitelisted(addr, status);
  }
  
  //add new team percentage of tokens and lock their release time
  function addTeamAddress(address addr, uint release_time, uint token_percentage) onlyOwner inState(State.PreFunding) external {
	super.addTeamAddressInternal(addr, release_time, token_percentage);
	token.addLockAddress(addr, release_time);  //not use delegatecall
  }
  
  //generate team tokens in accordance with percentage of total issue tokens, not preallocate
  function createTeamTokenByPercentage() onlyOwner internal {
	uint total= token.totalSupply();
	//uint tokens= total.mul(100).div(100-team_token_percentage_total).sub(total);
	uint tokens= total.mul(team_token_percentage_total).div(100-team_token_percentage_total);
	
	for(uint i=0; i&amp;lt;team_address_count; i++) {
		address addr= team_addresses_idx[i];
		if(addr==0x0) continue;
		
		uint ntoken= tokens.mul(team_addresses_token_percentage[addr]).div(team_token_percentage_total);
		token.mint(addr, ntoken);		
		createTeamTokenEvent(addr, ntoken);
	}
  }
  
  // fallback function can be used to buy tokens
  function () stopInEmergency allowCrowdsaleAmountLimit payable {
	require(msg.sender != 0x0);
    buyTokensCrowdsale(msg.sender);
  }

  // low level token purchase function
  function buyTokensCrowdsale(address receiver) internal /*stopInEmergency allowCrowdsaleAmountLimit payable*/ {
	uint256 weiAmount = msg.value;
	uint256 tokenAmount= 0;
	
	if(getState() == State.PreFunding) {
		if(whitelist_enable==true) {
			if(!presaleWhitelist[receiver]) {
				revert();
			}
		}
		
		if((PRESALE_ETH_IN_WEI_FUND_MAX &amp;gt; 0) &amp;amp;&amp;amp; ((presale_eth_fund.add(weiAmount)) &amp;gt; PRESALE_ETH_IN_WEI_FUND_MAX)) revert();		
		
		tokenAmount = calculateTokenPresale(weiAmount, token.decimals());
		presale_eth_fund = presale_eth_fund.add(weiAmount);
	}
	else if((getState() == State.Funding) || (getState() == State.Success)) {
		tokenAmount = calculateTokenCrowsale(weiAmount, token.decimals());
		
    } else {
      // Unwanted state
      revert();
    }
	
	if(tokenAmount == 0) {
		revert();
	}	
	
	if(investedAmountOf[receiver] == 0) {
       investorCount++;
    }
    
	// Update investor
    investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);
    tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);
	
    // Update totals
	crowdsale_eth_fund = crowdsale_eth_fund.add(weiAmount);
	tokensSold = tokensSold.add(tokenAmount);
	
	if((TOKEN_MAX &amp;gt; 0) &amp;amp;&amp;amp; (tokensSold &amp;gt; TOKEN_MAX)) revert();

    token.mint(receiver, tokenAmount);

    if(!multisigWallet.send(weiAmount)) revert();
	
	// Tell us invest was success
    Invested(receiver, weiAmount, tokenAmount);
  }
 
  /**
   * Allow load refunds back on the contract for the refunding.
   *
   * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..
   */
  function loadRefund() public payable inState(State.Failure) {
    if(msg.value == 0) revert();
    loadedRefund = loadedRefund.add(msg.value);
  }
  
  /**
   * Investors can claim refund.
   *
   * Note that any refunds from proxy buyers should be handled separately,
   * and not through this contract.
   */
  function refund() public inState(State.Refunding) {
    uint256 weiValue = investedAmountOf[msg.sender];
    if (weiValue == 0) revert();
    investedAmountOf[msg.sender] = 0;
    crowdsale_eth_refund = crowdsale_eth_refund.add(weiValue);
    Refund(msg.sender, weiValue);
    if (!msg.sender.send(weiValue)) revert();
  }
  
  function setEndsAt(uint time) onlyOwner {
    if(now &amp;gt; time) {
      revert();
    }

    endsAt = time;
    EndsAtChanged(endsAt);
  }
  
  // should be called after crowdsale ends, to do
  // some extra finalization work
  function doFinalize() public inState(State.Success) onlyOwner stopInEmergency {
    
	if(finalized) {
      revert();
    }

	createTeamTokenByPercentage();
    token.finishMinting();	
        
    finalized = true;
	Finalized();
  }
  
}

contract CrowdsaleToken is ReleasableToken, MintableToken {

  string public name;

  string public symbol;

  uint public decimals;
    
  /**
   * Construct the token.
   *
   * @param _name Token name
   * @param _symbol Token symbol - should be all caps
   * @param _initialSupply How many tokens we start with
   * @param _decimals Number of decimal places
   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.
   */
  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable) {

    owner = msg.sender;

    name = _name;
    symbol = _symbol;

    totalSupply = _initialSupply;

    decimals = _decimals;

    balances[owner] = totalSupply;

    if(totalSupply &amp;gt; 0) {
      Mint(owner, totalSupply);
    }

    // No more new supply allowed after the token creation
    if(!_mintable) {
      mintingFinished = true;
      if(totalSupply == 0) {
        revert(); // Cannot create a token without supply and no minting
      }
    }
  }

  /**
   * When token is released to be transferable, enforce no new tokens can be created.
   */
   
  function releaseTokenTransfer() public onlyReleaseAgent {
    mintingFinished = true;
    super.releaseTokenTransfer();
  }
  
  //lock team address by crowdsale
  function addLockAddress(address addr, uint lock_time) onlyMintAgent inReleaseState(false) public {
	super.addLockAddressInternal(addr, lock_time);
  }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x4d9412b6c12b2e2bf0da15416b71f33c846e635b.sol" target="_blank" title="show github file">0x4d9412b6c12b2e2bf0da15416b71f33c846e635b.sol</a>
        </div>
        <div class="path">solidity-files/0x4d9412b6c12b2e2bf0da15416b71f33c846e635b.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;



/**
 * Math operations with safety checks
 * By OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/contracts/SafeMath.sol
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a &amp;gt;= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a &amp;lt; b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a &amp;gt;= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a &amp;lt; b ? a : b;
  }

}



 contract ContractReceiver{
    function tokenFallback(address _from, uint256 _value, bytes  _data) external;
}


//Basic ERC23 token, backward compatible with ERC20 transfer function.
//Based in part on code by open-zeppelin: https://github.com/OpenZeppelin/zeppelin-solidity.git
contract ERC23BasicToken {
    using SafeMath for uint256;
    uint256 public totalSupply;
    mapping(address =&amp;gt; uint256) balances;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

    function tokenFallback(address _from, uint256 _value, bytes  _data) external {
        throw;
    }

    function transfer(address _to, uint256 _value, bytes _data) returns (bool success) {

        //Standard ERC23 transfer function

        if(isContract(_to)) {
            transferToContract(_to, _value, _data);
        }
        else {
            transferToAddress(_to, _value, _data);
        }
        return true;
    }

    function transfer(address _to, uint256 _value) {

        //standard function transfer similar to ERC20 transfer with no _data
        //added due to backwards compatibility reasons

        bytes memory empty;
        if(isContract(_to)) {
            transferToContract(_to, _value, empty);
        }
        else {
            transferToAddress(_to, _value, empty);
        }
    }

    function transferToAddress(address _to, uint256 _value, bytes _data) internal {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        Transfer(msg.sender, _to, _value, _data);
    }

    function transferToContract(address _to, uint256 _value, bytes _data) internal {
        balances[msg.sender] = balances[msg.sender].sub( _value);
        balances[_to] = balances[_to].add( _value);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        Transfer(msg.sender, _to, _value);
        Transfer(msg.sender, _to, _value, _data);
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.
    function isContract(address _addr) returns (bool is_contract) {
          uint256 length;
          assembly {
              //retrieve the size of the code on target address, this needs assembly
              length := extcodesize(_addr)
          }
          if(length&amp;gt;0) {
              return true;
          }
          else {
              return false;
          }
    }
}


 // Standard ERC23 token, backward compatible with ERC20 standards.
 // Based on code by open-zeppelin: https://github.com/OpenZeppelin/zeppelin-solidity.git
contract ERC23StandardToken is ERC23BasicToken {
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;
    event Approval (address indexed owner, address indexed spender, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) {
        var _allowance = allowed[_from][msg.sender];

        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
        // if (_value &amp;gt; _allowance) throw;

        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = _allowance.sub(_value);
        Transfer(_from, _to, _value);
    }

    function approve(address _spender, uint256 _value) {

        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender, 0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        if ((_value != 0) &amp;amp;&amp;amp; (allowed[msg.sender][_spender] != 0)) throw;

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }
  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}

/**
 * @title Mintable token
 * @dev Simple ERC20 Token example, with mintable token creation
 * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
 */
contract MintableToken is ERC23StandardToken, Ownable {
  event Mint(address indexed to, uint256 amount);
  event MintFinished();
  bool public mintingFinished = false;
  modifier canMint() {
    require(!mintingFinished);
    _;
  }
  /**
   * @dev Function to mint tokens
   * @param _to The address that will receive the minted tokens.
   * @param _amount The amount of tokens to mint.
   * @return A boolean that indicates if the operation was successful.
   */
  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    Transfer(0x0, _to, _amount);
    return true;
  }
  /**
   * @dev Function to stop minting new tokens.
   * @return True if the operation was successful.
   */
  function finishMinting() onlyOwner public returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
}

contract BIGLUV is MintableToken { 
  string public name=&amp;quot;BIGLUV&amp;quot;;
  string public symbol=&amp;quot;BLV&amp;quot;;
  uint8 public decimals=18;

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x30fd8b33553beb5428b38c6e4fa3fb0b9a9a3273.sol" target="_blank" title="show github file">0x30fd8b33553beb5428b38c6e4fa3fb0b9a9a3273.sol</a>
        </div>
        <div class="path">solidity-files/0x30fd8b33553beb5428b38c6e4fa3fb0b9a9a3273.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

// Turn the usage of callcode
contract SafeMath {
    function safeMul(uint a, uint b) internal returns (uint) {
        uint c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function safeSub(uint a, uint b) internal returns (uint) {
        assert(b &amp;lt;= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) internal returns (uint) {
        uint c = a + b;
        assert(c&amp;gt;=a &amp;amp;&amp;amp; c&amp;gt;=b);
        return c;
    }
}

contract CreatorEnabled {
    address public creator = 0x0;

    modifier onlyCreator() { require(msg.sender==creator); _; }

    function changeCreator(address _to) public onlyCreator {
        creator = _to;
    }
}

// ERC20 standard
contract StdToken is SafeMath {

    mapping(address =&amp;gt; uint256) public balances;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;
    uint public totalSupply = 0;


    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);


    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns(bool) {
      require(0x0!=_to);

      balances[msg.sender] = safeSub(balances[msg.sender],_value);
      balances[_to] = safeAdd(balances[_to],_value);

      Transfer(msg.sender, _to, _value);
      return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns(bool) {
      require(0x0!=_to);

      balances[_to] = safeAdd(balances[_to],_value);
      balances[_from] = safeSub(balances[_from],_value);
      allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);

      Transfer(_from, _to, _value);
      return true;
    }

    function balanceOf(address _owner) constant returns (uint256) {
      return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool) {
      // To change the approve amount you first have to reduce the addresses`
      //  allowance to zero by calling `approve(_spender, 0)` if it is not
      //  already 0 to mitigate the race condition described here:
      //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
      require((_value == 0) || (allowed[msg.sender][_spender] == 0));

      allowed[msg.sender][_spender] = _value;
      Approval(msg.sender, _spender, _value);
      return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256) {
      return allowed[_owner][_spender];
    }

    modifier onlyPayloadSize(uint _size) {
      require(msg.data.length &amp;gt;= _size + 4);
      _;
    }
}

contract IGoldFee {
    function calculateFee(address _sender, bool _isMigrationStarted, bool _isMigrationFinished, uint _mntpBalance, uint _value) public constant returns(uint);
}

contract GoldFee is CreatorEnabled {

    mapping(address =&amp;gt; bool) exceptAddresses;

    function GoldFee() {
        creator = msg.sender;
    }

    function getMin(uint out)returns (uint) {
        // 0.002 GOLD is min fee
        uint minFee = (2 * 1 ether) / 1000;
        if (out &amp;lt; minFee) {
             return minFee;
        }
        return out;
    }

    function getMax(uint out)returns (uint) {
        // 0.02 GOLD is max fee
        uint maxFee = (2 * 1 ether) / 100;
        if (out &amp;gt;= maxFee) {
             return maxFee;
        }
        return out;
    }

    function calculateFee(address _sender, bool _isMigrationStarted, bool _isMigrationFinished, uint _mntpBalance, uint _value) public constant returns(uint)
    {
       //if this is an excaptional address
       if (exceptAddresses[_sender]) {
            return 0;
       }

        // When migration process is finished (1 year from Goldmint blockchain launch), then transaction fee is 1% GOLD.
        if (_isMigrationFinished) {
             return (_value / 100);
        }

        // If the sender holds 0 MNTP, then the transaction fee is 1% GOLD.

        // If the sender holds at least 10 MNTP, then the transaction fee is 0.333333% GOLD,
        // but not less than 0.002 MNTP

        // If the sender holds at least 1000 MNTP, then the transaction fee is 0.033333% GOLD,
        // but not less than 0.002 MNTP

        // If the sender holds at least 10000 MNTP, then the transaction fee is 0.0333333% GOLD,
        // but not more than 0.02 MNTP
        if (_mntpBalance &amp;gt;= (10000 * 1 ether)) {
             return getMax((_value / 100) / 30);
        }
        if (_mntpBalance &amp;gt;= (1000 * 1 ether)) {
             return getMin((_value / 100) / 30);
        }
        if (_mntpBalance &amp;gt;= (10 * 1 ether)) {
             return getMin((_value / 100) / 3);
        }

        // 1%
        return getMin(_value / 100);
    }

    function addExceptAddress(address _address) public onlyCreator {
        exceptAddresses[_address] = true;
    }

    function removeExceptAddress(address _address) public onlyCreator {
        exceptAddresses[_address] = false;
    }

    function isAddressExcept(address _address) public constant returns(bool) {
        return exceptAddresses[_address];
    }
}

contract Gold is StdToken, CreatorEnabled {

    string public constant name = &amp;quot;GoldMint GOLD cryptoasset&amp;quot;;
    string public constant symbol = &amp;quot;GOLD&amp;quot;;
    uint8 public constant decimals = 18;

    // this is used to send fees (that is then distributed as rewards)
    address public migrationAddress = 0x0;
    address public storageControllerAddress = 0x0;

    address public goldmintTeamAddress = 0x0;
    IMNTP public mntpToken;
    IGoldFee public goldFee;


    bool public transfersLocked = false;
    bool public contractLocked = false;
    bool public migrationStarted = false;
    bool public migrationFinished = false;

    uint public totalIssued = 0;
    uint public totalBurnt = 0;

    // Modifiers:
    modifier onlyMigration() { require(msg.sender == migrationAddress); _; }
    modifier onlyMigrationOrStorageController() { require(msg.sender == migrationAddress || msg.sender == storageControllerAddress); _; }
    modifier onlyCreatorOrStorageController() { require(msg.sender == creator || msg.sender == storageControllerAddress); _; }
    modifier onlyIfUnlocked() { require(!transfersLocked); _; }

    // Functions:
    function Gold(address _mntpContractAddress, address _goldmintTeamAddress, address _goldFeeAddress) public {
        creator = msg.sender;

        mntpToken = IMNTP(_mntpContractAddress);
        goldmintTeamAddress = _goldmintTeamAddress;
        goldFee = IGoldFee(_goldFeeAddress);
    }

    function setCreator(address _address) public onlyCreator {
       creator = _address;
    }

    function lockContract(bool _contractLocked) public onlyCreator {
       contractLocked = _contractLocked;
    }

    function setStorageControllerContractAddress(address _address) public onlyCreator {
        storageControllerAddress = _address;
    }

    function setMigrationContractAddress(address _migrationAddress) public onlyCreator {
        migrationAddress = _migrationAddress;
    }

    function setGoldmintTeamAddress(address _teamAddress) public onlyCreator {
        goldmintTeamAddress = _teamAddress;
    }

    function setGoldFeeAddress(address _goldFeeAddress) public onlyCreator {
        goldFee = IGoldFee(_goldFeeAddress);
    }

    function issueTokens(address _who, uint _tokens) public onlyCreatorOrStorageController {
        require(!contractLocked);

        balances[_who] = safeAdd(balances[_who],_tokens);
        totalSupply = safeAdd(totalSupply,_tokens);
        totalIssued = safeAdd(totalIssued,_tokens);

        Transfer(0x0, _who, _tokens);
    }

    function burnTokens(address _who, uint _tokens) public onlyMigrationOrStorageController {
        require(!contractLocked);
        balances[_who] = safeSub(balances[_who],_tokens);
        totalSupply = safeSub(totalSupply,_tokens);
        totalBurnt = safeAdd(totalBurnt,_tokens);
    }

    // there is no way to revert that
    function startMigration() public onlyMigration {
        require(false == migrationStarted);
        migrationStarted = true;
    }

    // there is no way to revert that
    function finishMigration() public onlyMigration {
        require(true == migrationStarted);

        migrationFinished = true;
    }

    function lockTransfer(bool _lock) public onlyMigration {
        transfersLocked = _lock;
    }

    function transfer(address _to, uint256 _value) public onlyIfUnlocked onlyPayloadSize(2 * 32) returns(bool) {

        uint yourCurrentMntpBalance = mntpToken.balanceOf(msg.sender);

        // you can transfer if fee is ZERO
        uint fee = goldFee.calculateFee(msg.sender, migrationStarted, migrationFinished, yourCurrentMntpBalance, _value);
        uint sendThis = _value;
        if (0 != fee) {
             sendThis = safeSub(_value,fee);

             // 1.Transfer fee
             // A -&amp;gt; rewards account
             //
             // Each GOLD token transfer should send transaction fee to
             // GoldmintMigration contract if Migration process is not started.
             // Goldmint team if Migration process is started.
             if (migrationStarted) {
                  super.transfer(goldmintTeamAddress, fee);
             } else {
                  super.transfer(migrationAddress, fee);
             }
        }

        // 2.Transfer
        // A -&amp;gt; B
        return super.transfer(_to, sendThis);
    }

    function transferFrom(address _from, address _to, uint256 _value) public onlyIfUnlocked returns(bool) {

        uint yourCurrentMntpBalance = mntpToken.balanceOf(_from);

        uint fee = goldFee.calculateFee(msg.sender, migrationStarted, migrationFinished, yourCurrentMntpBalance, _value);
        if (0 != fee) {
             // 1.Transfer fee
             // A -&amp;gt; rewards account
             //
             // Each GOLD token transfer should send transaction fee to
             // GoldmintMigration contract if Migration process is not started.
             // Goldmint team if Migration process is started.
             if (migrationStarted) {
                  super.transferFrom(_from, goldmintTeamAddress, fee);
             } else {
                  super.transferFrom(_from, migrationAddress, fee);
             }
        }

        // 2.Transfer
        // A -&amp;gt; B
        uint sendThis = safeSub(_value,fee);
        return super.transferFrom(_from, _to, sendThis);
    }

    // Used to send rewards)
    function transferRewardWithoutFee(address _to, uint _value) public onlyMigration onlyPayloadSize(2*32) {
        require(0x0!=_to);

        balances[migrationAddress] = safeSub(balances[migrationAddress],_value);
        balances[_to] = safeAdd(balances[_to],_value);

        Transfer(migrationAddress, _to, _value);
    }

    // This is an emergency function that can be called by Creator only
    function rescueAllRewards(address _to) public onlyCreator {
        require(0x0!=_to);

        uint totalReward = balances[migrationAddress];

        balances[_to] = safeAdd(balances[_to],totalReward);
        balances[migrationAddress] = 0;

        Transfer(migrationAddress, _to, totalReward);
    }


    function getTotalIssued() public constant returns (uint) {
        return totalIssued;
    }

    function getTotalBurnt() public constant returns (uint) {
        return totalBurnt;
    }
}

contract IMNTP is StdToken {
    // Additional methods that MNTP contract provides
    function lockTransfer(bool _lock);
    function issueTokens(address _who, uint _tokens);
    function burnTokens(address _who, uint _tokens);
}

contract GoldmintMigration is CreatorEnabled {
    // Fields:
    IMNTP public mntpToken;
    Gold public goldToken;

    enum State {
        Init,
        MigrationStarted,
        MigrationPaused,
        MigrationFinished
    }

    State public state = State.Init;

    // this is total collected GOLD rewards (launch to migration start)
    uint public mntpToMigrateTotal = 0;
    uint public migrationRewardTotal = 0;
    uint64 public migrationStartedTime = 0;
    uint64 public migrationFinishedTime = 0;

    struct Migration {
        address ethAddress;
        string gmAddress;
        uint tokensCount;
        bool migrated;
        uint64 date;
        string comment;
    }

    mapping (uint=&amp;gt;Migration) public mntpMigrations;
    mapping (address=&amp;gt;uint) public mntpMigrationIndexes;
    uint public mntpMigrationsCount = 0;

    mapping (uint=&amp;gt;Migration) public goldMigrations;
    mapping (address=&amp;gt;uint) public goldMigrationIndexes;
    uint public goldMigrationsCount = 0;

    event MntpMigrateWanted(address _ethAddress, string _gmAddress, uint256 _value);
    event MntpMigrated(address _ethAddress, string _gmAddress, uint256 _value);

    event GoldMigrateWanted(address _ethAddress, string _gmAddress, uint256 _value);
    event GoldMigrated(address _ethAddress, string _gmAddress, uint256 _value);

    // Access methods
    function getMntpMigration(uint index) public constant returns(address,string,uint,bool,uint64,string){
        Migration memory mig = mntpMigrations[index];
        return (mig.ethAddress, mig.gmAddress, mig.tokensCount, mig.migrated, mig.date, mig.comment);
    }

    function getGoldMigration(uint index) public constant returns(address,string,uint,bool,uint64,string){
        Migration memory mig = goldMigrations[index];
        return (mig.ethAddress, mig.gmAddress, mig.tokensCount, mig.migrated, mig.date, mig.comment);
    }

    // Functions:
    // Constructor
    function GoldmintMigration(address _mntpContractAddress, address _goldContractAddress) public {
        creator = msg.sender;

        require(_mntpContractAddress != 0);
        require(_goldContractAddress != 0);

        mntpMigrationIndexes[address(0x0)] = 0;
        goldMigrationIndexes[address(0x0)] = 0;

        mntpToken = IMNTP(_mntpContractAddress);
        goldToken = Gold(_goldContractAddress);
    }

    function lockMntpTransfers(bool _lock) public onlyCreator {
        mntpToken.lockTransfer(_lock);
    }

    function lockGoldTransfers(bool _lock) public onlyCreator {
        goldToken.lockTransfer(_lock);
    }

    // This method is called when migration to Goldmint&amp;#39;s blockchain
    // process is started...
    function startMigration() public onlyCreator {
        require((State.Init == state) || (State.MigrationPaused == state));

        if (State.Init == state) {
             // 1 - change fees
             goldToken.startMigration();

             // 2 - store the current values
             migrationRewardTotal = goldToken.balanceOf(this);
             migrationStartedTime = uint64(now);
             mntpToMigrateTotal = mntpToken.totalSupply();
        }

        state = State.MigrationStarted;
    }

    function pauseMigration() public onlyCreator {
        require((state == State.MigrationStarted) || (state == State.MigrationFinished));

        state = State.MigrationPaused;
    }

    // that doesn&amp;#39;t mean that you cant migrate from Ethereum -&amp;gt; Goldmint blockchain
    // that means that you will get no reward
    function finishMigration() public onlyCreator {
        require((State.MigrationStarted == state) || (State.MigrationPaused == state));

        if (State.MigrationStarted == state) {
             goldToken.finishMigration();
             migrationFinishedTime = uint64(now);
        }

        state = State.MigrationFinished;
    }

    function destroyMe() public onlyCreator {
        selfdestruct(msg.sender);
    }

    // MNTP
    // Call this to migrate your MNTP tokens to Goldmint MNT
    // (this is one-way only)
    // _gmAddress is something like that - &amp;quot;BTS7yRXCkBjKxho57RCbqYE3nEiprWXXESw3Hxs5CKRnft8x7mdGi&amp;quot;
    //
    // !!! WARNING: will not allow anyone to migrate tokens partly
    // !!! DISCLAIMER: check goldmint blockchain address format. You will not be able to change that!
    function migrateMntp(string _gmAddress) public {
        require((state==State.MigrationStarted) || (state==State.MigrationFinished));

        // 1 - calculate current reward
        uint myBalance = mntpToken.balanceOf(msg.sender);
        require(0!=myBalance);

        uint myRewardMax = calculateMyRewardMax(msg.sender);
        uint myReward = calculateMyReward(myRewardMax);

        // 2 - pay the reward to our user
        goldToken.transferRewardWithoutFee(msg.sender, myReward);

        // 3 - burn tokens
        // WARNING: burn will reduce totalSupply
        //
        // WARNING: creator must call
        // setIcoContractAddress(migrationContractAddress)
        // of the mntpToken
        mntpToken.burnTokens(msg.sender,myBalance);

        // save tuple
        Migration memory mig;
        mig.ethAddress = msg.sender;
        mig.gmAddress = _gmAddress;
        mig.tokensCount = myBalance;
        mig.migrated = false;
        mig.date = uint64(now);
        mig.comment = &amp;#39;&amp;#39;;

        mntpMigrations[mntpMigrationsCount + 1] = mig;
        mntpMigrationIndexes[msg.sender] = mntpMigrationsCount + 1;
        mntpMigrationsCount++;

        // send an event
        MntpMigrateWanted(msg.sender, _gmAddress, myBalance);
    }

    function isMntpMigrated(address _who) public constant returns(bool) {
        uint index = mntpMigrationIndexes[_who];

        Migration memory mig = mntpMigrations[index];
        return mig.migrated;
    }

    function setMntpMigrated(address _who, bool _isMigrated, string _comment) public onlyCreator {
        uint index = mntpMigrationIndexes[_who];
        require(index &amp;gt; 0);

        mntpMigrations[index].migrated = _isMigrated;
        mntpMigrations[index].comment = _comment;

        // send an event
        if (_isMigrated) {
             MntpMigrated(  mntpMigrations[index].ethAddress,
                            mntpMigrations[index].gmAddress,
                            mntpMigrations[index].tokensCount);
        }
    }

    // GOLD
    function migrateGold(string _gmAddress) public {
        require((state==State.MigrationStarted) || (state==State.MigrationFinished));

        // 1 - get balance
        uint myBalance = goldToken.balanceOf(msg.sender);
        require(0!=myBalance);

        // 2 - burn tokens
        // WARNING: burn will reduce totalSupply
        //
        goldToken.burnTokens(msg.sender,myBalance);

        // save tuple
        Migration memory mig;
        mig.ethAddress = msg.sender;
        mig.gmAddress = _gmAddress;
        mig.tokensCount = myBalance;
        mig.migrated = false;
        mig.date = uint64(now);
        mig.comment = &amp;#39;&amp;#39;;

        goldMigrations[goldMigrationsCount + 1] = mig;
        goldMigrationIndexes[msg.sender] = goldMigrationsCount + 1;
        goldMigrationsCount++;

        // send an event
        GoldMigrateWanted(msg.sender, _gmAddress, myBalance);
    }

    function isGoldMigrated(address _who) public constant returns(bool) {
        uint index = goldMigrationIndexes[_who];

        Migration memory mig = goldMigrations[index];
        return mig.migrated;
    }

    function setGoldMigrated(address _who, bool _isMigrated, string _comment) public onlyCreator {
        uint index = goldMigrationIndexes[_who];
        require(index &amp;gt; 0);

        goldMigrations[index].migrated = _isMigrated;
        goldMigrations[index].comment = _comment;

        // send an event
        if (_isMigrated) {
             GoldMigrated(  goldMigrations[index].ethAddress,
                            goldMigrations[index].gmAddress,
                            goldMigrations[index].tokensCount);
        }
    }

    // Each MNTP token holder gets a GOLD reward as a percent of all rewards
    // proportional to his MNTP token stake
    function calculateMyRewardMax(address _of) public constant returns(uint){
        if (0 == mntpToMigrateTotal) {
             return 0;
        }

        uint myCurrentMntpBalance = mntpToken.balanceOf(_of);
        if (0 == myCurrentMntpBalance) {
             return 0;
        }

        return (migrationRewardTotal * myCurrentMntpBalance) / mntpToMigrateTotal;
    }

    //emergency function. used in case of a mistake to transfer all the reward to a new migraiton smart contract.
    function transferReward(address _newContractAddress) public onlyCreator {
      goldToken.transferRewardWithoutFee(_newContractAddress, goldToken.balanceOf(this));
    }

    // Migration rewards decreased linearly.
    //
    // The formula is: rewardPercents = max(100 - 100 * day / 365, 0)
    //
    // On 1st day of migration, you will get: 100 - 100 * 0/365 = 100% of your rewards
    // On 2nd day of migration, you will get: 100 - 100 * 1/365 = 99.7261% of your rewards
    // On 365th day of migration, you will get: 100 - 100 * 364/365 = 0.274%
    function calculateMyRewardDecreased(uint _day, uint _myRewardMax) public constant returns(uint){
        if (_day &amp;gt;= 365) {
             return 0;
        }

        uint x = ((100 * 1000000000 * _day) / 365);
        return (_myRewardMax * ((100 * 1000000000) - x)) / (100 * 1000000000);
    }

    function calculateMyReward(uint _myRewardMax) public constant returns(uint){
        // day starts from 0
        uint day = (uint64(now) - migrationStartedTime) / uint64(1 days);
        return calculateMyRewardDecreased(day, _myRewardMax);
    }

    // do not allow to send money to this contract...
    function() external payable {
        revert();
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x9fdadd2a5573da564963a9ec2a7f889f6ada1f3b.sol" target="_blank" title="show github file">0x9fdadd2a5573da564963a9ec2a7f889f6ada1f3b.sol</a>
        </div>
        <div class="path">solidity-files/0x9fdadd2a5573da564963a9ec2a7f889f6ada1f3b.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.4;
contract Token {
    function totalSupply() constant returns (uint256 supply) {}
    function balanceOf(address _owner) constant returns (uint256 balance) {}
    function transfer(address _to, uint256 _value) returns (bool success) {}
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}
    function approve(address _spender, uint256 _value) returns (bool success) {}
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}
contract StandardToken is Token {
    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; _value &amp;gt; 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balances[_from] &amp;gt;= _value &amp;amp;&amp;amp; allowed[_from][msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; _value &amp;gt; 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address =&amp;gt; uint256) balances;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;
    uint256 public totalSupply;
}

contract Scc is StandardToken {
    string public name; 
    uint8 public decimals; 
    string public symbol;
    string public version = &amp;#39;H1.0&amp;#39;; 
    uint256 public unitsOneEthCanBuy;
    uint256 public totalEthInWei;
    address public fundsWallet; 
    function Scc() {
        balances[msg.sender] = 180000000000000000000000000;
        totalSupply = 180000000000000000000000000;
        name = &amp;quot;Smart Coin Cash&amp;quot;;
        decimals = 18;
        symbol = &amp;quot;Scc&amp;quot;;
        unitsOneEthCanBuy = 58400;
        fundsWallet = msg.sender;
    }
    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] &amp;gt;= amount);
        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;
        Transfer(fundsWallet, msg.sender, amount); // Broadcast a message to the blockchain
        fundsWallet.transfer(msg.value);                               
    }
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        if(!_spender.call(bytes4(bytes32(sha3(&amp;quot;receiveApproval(address,uint256,address,bytes)&amp;quot;))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x0353eaf3b1ee16e6d4fc8c37a97b28e50aac3f23.sol" target="_blank" title="show github file">0x0353eaf3b1ee16e6d4fc8c37a97b28e50aac3f23.sol</a>
        </div>
        <div class="path">solidity-files/0x0353eaf3b1ee16e6d4fc8c37a97b28e50aac3f23.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT105212&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT105212
    // Name        : ADZbuzz Infospace.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT105212&amp;quot;;
            name = &amp;quot;ADZbuzz Infospace.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xad2de0abcef0ae1c504b6fe6d7fa7c92842ce8c1.sol" target="_blank" title="show github file">0xad2de0abcef0ae1c504b6fe6d7fa7c92842ce8c1.sol</a>
        </div>
        <div class="path">solidity-files/0xad2de0abcef0ae1c504b6fe6d7fa7c92842ce8c1.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */

library SafeMath {
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address =&amp;gt; uint256) balances;

  uint256 totalSupply_;

  /**
  * @dev total number of tokens in existence
  */
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}

contract StandardToken is ERC20, BasicToken {
 using SafeMath for uint256;
 mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) internal allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[_from]);
    require(_value &amp;lt;= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   *
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender&amp;#39;s allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   *
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue &amp;gt; oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}

contract StopTheFakesPromo is StandardToken {
    
    string public constant Token_Description = &amp;quot;StopTheFakes.io: 5% BONUS. This token allows its holder to receive an additional bonus of 5% during the main token sale. More information in our telegram group.&amp;quot;;
    string public constant name = &amp;quot;StopTheFakes Promo&amp;quot;;
    string public constant symbol = &amp;quot;STFPR&amp;quot;;
    uint8 public constant decimals = 18;

    uint256 public constant INITIAL_SUPPLY = 3000000 ether;

    function StopTheFakesPromo() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x47cfba6dba7999949055f91b7e71ef12e34ae2a3.sol" target="_blank" title="show github file">0x47cfba6dba7999949055f91b7e71ef12e34ae2a3.sol</a>
        </div>
        <div class="path">solidity-files/0x47cfba6dba7999949055f91b7e71ef12e34ae2a3.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// File: contracts\Auction.sol

/**
 * @title 竞拍接口
 */
contract Auction {
    function bid() public payable returns (bool);
    function end() public returns (bool);

    event AuctionBid(address indexed from, uint256 value);
}

// File: contracts\Base.sol

library Base {
    struct NTVUConfig {
        uint bidStartValue;
        int bidStartTime;
        int bidEndTime;

        uint tvUseStartTime;
        uint tvUseEndTime;

        bool isPrivate;
        bool special;
    }
}

// File: contracts\ownership\Ownable.sol

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &amp;quot;user permissions&amp;quot;.
 */
contract Ownable {
  address public owner;

  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
}

// File: contracts\util\SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

// File: contracts\token\ERC20Basic.sol

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

// File: contracts\token\BasicToken.sol

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address =&amp;gt; uint256) balances;

  uint256 totalSupply_;

  /**
  * @dev total number of tokens in existence
  */
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &amp;lt;= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}

// File: contracts\util\StringUtils.sol

library StringUtils {
    function uintToString(uint v) internal pure returns (string str) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = byte(48 + remainder);
        }

        bytes memory s = new bytes(i);
        for (uint j = 0; j &amp;lt; i; j++) {
            s[j] = reversed[i - 1 - j];
        }

        str = string(s);
    }

    function concat(string _base, string _value) internal pure returns (string) {
        bytes memory _baseBytes = bytes(_base);
        bytes memory _valueBytes = bytes(_value);

        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);
        bytes memory _newValue = bytes(_tmpValue);

        uint i;
        uint j;

        for(i=0; i&amp;lt;_baseBytes.length; i++) {
            _newValue[j++] = _baseBytes[i];
        }

        for(i=0; i&amp;lt;_valueBytes.length; i++) {
            _newValue[j++] = _valueBytes[i];
        }

        return string(_newValue);
    }

    function bytesToBytes32(bytes memory source) internal pure returns (bytes32 result) {
        require(source.length &amp;lt;= 32);

        if (source.length == 0) {
            return 0x0;
        }

        assembly {
            result := mload(add(source, 32))
        }
    }

    function toBytes96(string memory text) internal pure returns (bytes32, bytes32, bytes32, uint8) {
        bytes memory temp = bytes(text);
        len = uint8(temp.length);
        require(len &amp;lt;= 96);

        uint8 i=0;
        uint8 j=0;
        uint8 k=0;

        string memory _b1 = new string(32);
        bytes memory b1 = bytes(_b1);

        string memory _b2 = new string(32);
        bytes memory b2 = bytes(_b2);

        string memory _b3 = new string(32);
        bytes memory b3 = bytes(_b3);

        uint8 len;

        for(i=0; i&amp;lt;len; i++) {
            k = i / 32;
            j = i % 32;

            if (k == 0) {
                b1[j] = temp[i];
            } else if(k == 1) {
                b2[j] = temp[i];
            } else if(k == 2) {
                b3[j] = temp[i];
            } 
        }

        return (bytesToBytes32(b1), bytesToBytes32(b2), bytesToBytes32(b3), len);
    }

    function fromBytes96(bytes32 b1, bytes32 b2, bytes32 b3, uint8 len) internal pure returns (string) {
        require(len &amp;lt;= 96);
        string memory _tmpValue = new string(len);
        bytes memory temp = bytes(_tmpValue);

        uint8 i;
        uint8 j = 0;

        for(i=0; i&amp;lt;32; i++) {
            if (j &amp;gt;= len) break;
            temp[j++] = b1[i];
        }

        for(i=0; i&amp;lt;32; i++) {
            if (j &amp;gt;= len) break;
            temp[j++] = b2[i];
        }

        for(i=0; i&amp;lt;32; i++) {
            if (j &amp;gt;= len) break;
            temp[j++] = b3[i];
        }

        return string(temp);
    }
}

// File: contracts\NTVUToken.sol

/**
 * 链上真心话时段币
 */
contract NTVUToken is BasicToken, Ownable, Auction {
    string public name;
    string public symbol = &amp;quot;FOT&amp;quot;;

    uint8 public number = 0;
    uint8 public decimals = 0;
    uint public INITIAL_SUPPLY = 1;

    uint public bidStartValue;
    uint public bidStartTime;
    uint public bidEndTime;

    uint public tvUseStartTime;
    uint public tvUseEndTime;

    bool public isPrivate = false;

    uint public maxBidValue;
    address public maxBidAccount;

    bool internal auctionEnded = false;

    string public text; // 用户配置文本
    string public auditedText; // 审核通过的文本
    string public defaultText; // 默认文本
    uint8 public auditStatus = 0; // 0:未审核；1:审核通过；2:审核不通过

    uint32 public bidCount;
    uint32 public auctorCount;

    mapping(address =&amp;gt; bool) acutors;

    address public ethSaver; // 竞拍所得ETH保管者

    /**
     * 时段币合约构造函数
     *
     * 拍卖期间如有更高出价，前一手出价者的以太坊自动退回其钱包
     *
     * @param _number 时段币的序号，从0开始
     * @param _bidStartValue 起拍价，单位 wei
     * @param _bidStartTime 起拍/私募开始时间，单位s
     * @param _bidEndTime 起拍/私募结束时间，单位s
     * @param _tvUseStartTime 时段币文本开始播放时间
     * @param _tvUseEndTime 时段币文本结束播放时间
     * @param _isPrivate 是否为私募
     * @param _defaultText 默认文本
     * @param _ethSaver 竞拍所得保管着
     */
    function NTVUToken(uint8 _number, uint _bidStartValue, uint _bidStartTime, uint _bidEndTime, uint _tvUseStartTime, uint _tvUseEndTime, bool _isPrivate, string _defaultText, address _ethSaver) public {
        number = _number;

        if (_number + 1 &amp;lt; 10) {
            symbol = StringUtils.concat(symbol, StringUtils.concat(&amp;quot;0&amp;quot;, StringUtils.uintToString(_number + 1)));
        } else {
            symbol = StringUtils.concat(symbol, StringUtils.uintToString(_number + 1));
        }

        name = symbol;
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;

        bidStartValue = _bidStartValue;
        bidStartTime = _bidStartTime;
        bidEndTime = _bidEndTime;

        tvUseStartTime = _tvUseStartTime;
        tvUseEndTime = _tvUseEndTime;

        isPrivate = _isPrivate;

        defaultText = _defaultText;

        ethSaver = _ethSaver;
    }

    /**
     * 竞拍出价
     *
     * 拍卖期间如有更高出价，前一手出价者的以太坊自动退回其钱包
     */
    function bid() public payable returns (bool) {
        require(now &amp;gt;= bidStartTime); // 竞拍开始时间到后才能竞拍
        require(now &amp;lt; bidEndTime); // 竞拍截止时间到后不能再竞拍
        require(msg.value &amp;gt;= bidStartValue); // 拍卖金额需要大于起拍价
        require(msg.value &amp;gt;= maxBidValue + 0.05 ether); // 最低0.05ETH加价
        require(!isPrivate || (isPrivate &amp;amp;&amp;amp; maxBidAccount == address(0))); // 竞拍或者私募第一次出价

        // 如果上次有人出价，将上次出价的ETH退还给他
        if (maxBidAccount != address(0)) {
            maxBidAccount.transfer(maxBidValue);
        } 
        
        maxBidAccount = msg.sender;
        maxBidValue = msg.value;
        AuctionBid(maxBidAccount, maxBidValue); // 发出有人出价事件

        // 统计出价次数
        bidCount++;

        // 统计出价人数
        bool bided = acutors[msg.sender];
        if (!bided) {
            auctorCount++;
            acutors[msg.sender] = true;
        }
    }

    /**
     * 竞拍结束
     *
     * 拍卖结束后，系统确认交易，出价最高者获得该时段Token。
     */
    function end() public returns (bool) {
        require(!auctionEnded); // 已经结束竞拍了不能再结束
        require((now &amp;gt;= bidEndTime) || (isPrivate &amp;amp;&amp;amp; maxBidAccount != address(0))); // 普通竞拍拍卖结束后才可以结束竞拍，私募只要出过价就可以结束竞拍
   
        // 如果有人出价，将时段代币转给出价最高的人
        if (maxBidAccount != address(0)) {
            address _from = owner;
            address _to = maxBidAccount;
            uint _value = INITIAL_SUPPLY;

            // 将时段币转给出价最高的人
            balances[_from] = balances[_from].sub(_value);
            balances[_to] = balances[_to].add(_value);
            Transfer(_from, _to, _value); // 通知出价最高的人收到时段币了

            //将时段币中ETH转给ethSaver
            ethSaver.transfer(this.balance);
        }

        auctionEnded = true;
    }

    /**
     * 配置上链文本
     *
     * 购得时段后（包含拍卖和私募），可以设置时段文本
     * 每时段文字接受中文30字以内（含标点和空格），多出字符不显示。
     * 审核截止时间是，每个时段播出前30分钟
     */
    function setText(string _text) public {
        require(INITIAL_SUPPLY == balances[msg.sender]); // 拥有时段币的人可以设置文本
        require(bytes(_text).length &amp;gt; 0 &amp;amp;&amp;amp; bytes(_text).length &amp;lt;= 90); // 汉字使用UTF8编码，1个汉字最多占用3个字节，所以最多写90个字节的字
        require(now &amp;lt; tvUseStartTime - 30 minutes); // 开播前30分钟不能再设置文本

        text = _text;
    }

    function getTextBytes96() public view returns(bytes32, bytes32, bytes32, uint8) {
        return StringUtils.toBytes96(text);
    }

    /**
     * 审核文本
     */
    function auditText(uint8 _status, string _text) external onlyOwner {
        require((now &amp;gt;= tvUseStartTime - 30 minutes) &amp;amp;&amp;amp; (now &amp;lt; tvUseEndTime)); // 时段播出前30分钟为审核时间，截止到时段播出结束时间
        auditStatus = _status;

        if (_status == 2) { // 审核失败，更新审核文本
            auditedText = _text;
        } else if (_status == 1) { // 审核通过使用用户设置的文本
            auditedText = text; 
        }
    }

    /**
     * 获取显示文本
     */
    function getShowText() public view returns(string) {
        if (auditStatus == 1 || auditStatus == 2) { // 审核过了
            return auditedText;
        } else { // 没有审核，显示默认文本
            return defaultText;
        }
    }

    function getShowTextBytes96() public view returns(bytes32, bytes32, bytes32, uint8) {
        return StringUtils.toBytes96(getShowText());
    }

    /**
     * 转账代币
     *
     * 获得时段后，时段播出前，不可以转卖。时段播出后，可以作为纪念币转卖
     */
    function transfer(address _to, uint256 _value) public returns (bool) {
        require(now &amp;gt;= tvUseEndTime); // 时段播出后，可以转卖。

        super.transfer(_to, _value);
    }

    /**
     * 获取时段币状态信息
     *
     */
    function getInfo() public view returns(
        string _symbol,
        string _name,
        uint _bidStartValue, 
        uint _bidStartTime, 
        uint _bidEndTime, 
        uint _tvUseStartTime,
        uint _tvUseEndTime,
        bool _isPrivate
        ) {
        _symbol = symbol;
        _name = name;

        _bidStartValue = bidStartValue;
        _bidStartTime = bidStartTime;
        _bidEndTime = bidEndTime;

        _tvUseStartTime = tvUseStartTime;
        _tvUseEndTime = tvUseEndTime;

        _isPrivate = isPrivate;
    }

    /**
     * 获取时段币可变状态信息
     *
     */
    function getMutalbeInfo() public view returns(
        uint _maxBidValue,
        address _maxBidAccount,
        bool _auctionEnded,
        string _text,
        uint8 _auditStatus,
        uint8 _number,
        string _auditedText,
        uint32 _bidCount,
        uint32 _auctorCount
        ) {
        _maxBidValue = maxBidValue;
        _maxBidAccount = maxBidAccount;

        _auctionEnded = auctionEnded;

        _text = text;
        _auditStatus = auditStatus;

        _number = number;
        _auditedText = auditedText;

        _bidCount = bidCount;
        _auctorCount = auctorCount;
    }

    /**
     * 提取以太坊到ethSaver
     */
    function reclaimEther() external onlyOwner {
        require((now &amp;gt; bidEndTime) || (isPrivate &amp;amp;&amp;amp; maxBidAccount != address(0))); // 普通竞拍拍卖结束后或者私募完成后，可以提币到ethSaver。
        ethSaver.transfer(this.balance);
    }

    /**
     * 默认给合约转以太坊就是出价
     */
    function() payable public {
        bid(); // 出价
    }
}

// File: contracts\NTVToken.sol

/**
 * 链上真心话合约
 */
contract NTVToken is Ownable {
    using SafeMath for uint256;

    uint8 public MAX_TIME_RANGE_COUNT = 66; // 最多发行66个时段代币

    bool public isRunning; // 是否启动运行

    uint public onlineTime; // 上线时间，第一时段上电视的时间
    uint8 public totalTimeRange; // 当前已经释放的总的时段数
    mapping(uint =&amp;gt; address) internal timeRanges; // 每个时段的合约地址，编号从0开始

    string public defaultText = &amp;quot;浪花有意千里雪，桃花无言一队春。&amp;quot;; // 忘记审核使用的默认文本

    mapping(uint8 =&amp;gt; Base.NTVUConfig) internal dayConfigs; // 每天时段配置
    mapping(uint8 =&amp;gt; Base.NTVUConfig) internal specialConfigs; // 特殊时段配置

    address public ethSaver; // 竞拍所得ETH保管者

    event OnTV(address indexed ntvu, address indexed winer, string text); // 文本上电视

    /**
     * 佛系电视合约构造函数
     */
    function NTVToken() public {}

    /**
     * 启动区块链电视
     *
     * @param _onlineTime 区块链电视上线时间，必须为整点，例如 2018-03-26 00:00:00
     * @param _ethSaver 竞拍所得ETH保管者
     */
    function startup(uint256 _onlineTime, address _ethSaver) public onlyOwner {
        require(!isRunning); // 只能上线一次，上线后不能停止
        require((_onlineTime - 57600) % 1 days == 0); // 上线时间只能是整天时间，57600为北京时间的&amp;#39;1970/1/2 0:0:0&amp;#39;
        require(_onlineTime &amp;gt;= now); // 上线时间需要大于当前时间
        require(_ethSaver != address(0));

        onlineTime = _onlineTime;
        ethSaver = _ethSaver;

        isRunning = true;

        // ---------------------------
        // 每天的时段配置，共6个时段
        //
        // 通用规则：
        // 1、首拍后，每天18:30-22:00为竞拍时间
        // ---------------------------
        uint8[6] memory tvUseStartTimes = [0, 10, 12, 18, 20, 22]; // 电视使用开始时段
        uint8[6] memory tvUseEndTimes = [2, 12, 14, 20, 22, 24]; // 电视使用结束时段

        for (uint8 i=0; i&amp;lt;6; i++) {
            dayConfigs[i].bidStartValue = 0.1 ether; // 正常起拍价0.1ETH
            dayConfigs[i].bidStartTime = 18 hours + 30 minutes - 1 days; // 一天前晚上 18:30起拍
            dayConfigs[i].bidEndTime = 22 hours - 1 days; // 一天前晚上 22:00 结束拍卖

            dayConfigs[i].tvUseStartTime = uint(tvUseStartTimes[i]) * 1 hours;
            dayConfigs[i].tvUseEndTime = uint(tvUseEndTimes[i]) * 1 hours;

            dayConfigs[i].isPrivate = false; // 正常都是竞拍，非私募
        }

        // ---------------------------
        // 特殊时段配置
        // ---------------------------

        // 首拍，第1天的6个时段都是首拍，拍卖时间从两天前的18:30到一天前的22:00
        for(uint8 p=0; p&amp;lt;6; p++) {
            specialConfigs[p].special = true;
            
            specialConfigs[p].bidStartValue = 0.1 ether; // 起拍价0.1ETH
            specialConfigs[p].bidStartTime = 18 hours + 30 minutes - 2 days; // 两天前的18:30
            specialConfigs[p].bidEndTime = 22 hours - 1 days; // 一天前的22:00
            specialConfigs[p].isPrivate = false; // 非私募
        }
    }

    /**
     * 获取区块的时间戳，单位s
     */
    function time() constant internal returns (uint) {
        return block.timestamp;
    }

    /**
     * 获取某个时间是上线第几天，第1天返回1，上线之前返回0
     * 
     * @param timestamp 时间戳
     */
    function dayFor(uint timestamp) constant public returns (uint) {
        return timestamp &amp;lt; onlineTime
            ? 0
            : (timestamp.sub(onlineTime) / 1 days) + 1;
    }

    /**
     * 获取当前时间是今天的第几个时段，第一个时段返回1，没有匹配的返回0
     *
     * @param timestamp 时间戳
     */
    function numberFor(uint timestamp) constant public returns (uint8) {
        if (timestamp &amp;gt;= onlineTime) {
            uint current = timestamp.sub(onlineTime) % 1 days;

            for(uint8 i=0; i&amp;lt;6; i++) {
                if (dayConfigs[i].tvUseStartTime&amp;lt;=current &amp;amp;&amp;amp; current&amp;lt;dayConfigs[i].tvUseEndTime) {
                    return (i + 1);
                }
            }
        }

        return 0;
    }

    /**
     * 创建时段币
     */
    function createNTVU() public onlyOwner {
        require(isRunning);
        require(totalTimeRange &amp;lt; MAX_TIME_RANGE_COUNT);

        uint8 number = totalTimeRange++;
        uint8 day = number / 6;
        uint8 num = number % 6;

        Base.NTVUConfig memory cfg = dayConfigs[num]; // 读取每天时段的默认配置

        // 如果有特殊配置则覆盖
        Base.NTVUConfig memory expCfg = specialConfigs[number];
        if (expCfg.special) {
            cfg.bidStartValue = expCfg.bidStartValue;
            cfg.bidStartTime = expCfg.bidStartTime;
            cfg.bidEndTime = expCfg.bidEndTime;
            cfg.isPrivate = expCfg.isPrivate;
        }

        // 根据上线时间计算具体的时段时间
        uint bidStartTime = uint(int(onlineTime) + day * 24 hours + cfg.bidStartTime);
        uint bidEndTime = uint(int(onlineTime) + day * 24 hours + cfg.bidEndTime);
        uint tvUseStartTime = onlineTime + day * 24 hours + cfg.tvUseStartTime;
        uint tvUseEndTime = onlineTime + day * 24 hours + cfg.tvUseEndTime;

        timeRanges[number] = new NTVUToken(number, cfg.bidStartValue, bidStartTime, bidEndTime, tvUseStartTime, tvUseEndTime, cfg.isPrivate, defaultText, ethSaver);
    }

    /**
     * 查询所有时段
     */
    function queryNTVUs(uint startIndex, uint count) public view returns(address[]){
        startIndex = (startIndex &amp;lt; totalTimeRange)? startIndex : totalTimeRange;
        count = (startIndex + count &amp;lt; totalTimeRange) ? count : (totalTimeRange - startIndex);

        address[] memory result = new address[](count);
        for(uint i=0; i&amp;lt;count; i++) {
            result[i] = timeRanges[startIndex + i];
        }

        return result;
    }

    /**
     * 查询当前正在播放的时段
     */
    function playingNTVU() public view returns(address){
        uint day = dayFor(time());
        uint8 num = numberFor(time());

        if (day&amp;gt;0 &amp;amp;&amp;amp; (num&amp;gt;0 &amp;amp;&amp;amp; num&amp;lt;=6)) {
            day = day - 1;
            num = num - 1;

            return timeRanges[day * 6 + uint(num)];
        } else {
            return address(0);
        }
    }

    /**
     * 审核文本
     */
    function auditNTVUText(uint8 index, uint8 status, string _text) public onlyOwner {
        require(isRunning); // 合约启动后才能审核
        require(index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; totalTimeRange); //只能审核已经上线的时段
        require(status==1 || (status==2 &amp;amp;&amp;amp; bytes(_text).length&amp;gt;0 &amp;amp;&amp;amp; bytes(_text).length &amp;lt;= 90)); // 审核不通，需要配置文本

        address ntvu = timeRanges[index];
        assert(ntvu != address(0));

        NTVUToken ntvuToken = NTVUToken(ntvu);
        ntvuToken.auditText(status, _text);

        var (b1, b2, b3, len) = ntvuToken.getShowTextBytes96();
        var auditedText = StringUtils.fromBytes96(b1, b2, b3, len);
        OnTV(ntvuToken, ntvuToken.maxBidAccount(), auditedText); // 审核后的文本记录到日志中
    }

    /**
     * 获取电视播放文本
     */
    function getText() public view returns(string){
        address playing = playingNTVU();

        if (playing != address(0)) {
            NTVUToken ntvuToken = NTVUToken(playing);

            var (b1, b2, b3, len) = ntvuToken.getShowTextBytes96();
            return StringUtils.fromBytes96(b1, b2, b3, len);
        } else {
            return &amp;quot;&amp;quot;; // 当前不是播放时段，返回空文本
        }
    }

    /**
     * 获取竞拍状态
     */
    function status() public view returns(uint8) {
        if (!isRunning) {
            return 0; // 未启动拍卖
        } else if (time() &amp;lt; onlineTime) {
            return 1; // 未到首播时间
        } else {
            if (totalTimeRange == 0) {
                return 2; // 没有创建播放时段
            } else {
                if (time() &amp;lt; NTVUToken(timeRanges[totalTimeRange - 1]).tvUseEndTime()) {
                    return 3; // 整个竞拍活动进行中
                } else {
                    return 4; // 整个竞拍活动已结束
                }
            }
        }
    }
    
    /**
     * 获取总的竞拍人数
     */
    function totalAuctorCount() public view returns(uint32) {
        uint32 total = 0;

        for(uint8 i=0; i&amp;lt;totalTimeRange; i++) {
            total += NTVUToken(timeRanges[i]).auctorCount();
        }

        return total;
    }

    /**
     * 获取总的竞拍次数
     */
    function totalBidCount() public view returns(uint32) {
        uint32 total = 0;

        for(uint8 i=0; i&amp;lt;totalTimeRange; i++) {
            total += NTVUToken(timeRanges[i]).bidCount();
        }

        return total;
    }

    /**
     * 获取总的出价ETH
     */
    function totalBidEth() public view returns(uint) {
        uint total = 0;

        for(uint8 i=0; i&amp;lt;totalTimeRange; i++) {
            total += NTVUToken(timeRanges[i]).balance;
        }

        total += this.balance;
        total += ethSaver.balance;

        return total;
    }

    /**
     * 获取历史出价最高的ETH
     */
    function maxBidEth() public view returns(uint) {
        uint maxETH = 0;

        for(uint8 i=0; i&amp;lt;totalTimeRange; i++) {
            uint val = NTVUToken(timeRanges[i]).maxBidValue();
            maxETH =  (val &amp;gt; maxETH) ? val : maxETH;
        }

        return maxETH;
    }

    /**
     * 提取当前合约的ETH到ethSaver
     */
    function reclaimEther() public onlyOwner {
        require(isRunning);

        ethSaver.transfer(this.balance);
    }

    /**
     * 提取时段币的ETH到ethSaver
     */
    function reclaimNtvuEther(uint8 index) public onlyOwner {
        require(isRunning);
        require(index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; totalTimeRange); //只能审核已经上线的时段

        NTVUToken(timeRanges[index]).reclaimEther();
    }

    /**
     * 接收ETH
     */
    function() payable external {}
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xb6b2aadddbef17d3a2e67d2e1e321a394176784a.sol" target="_blank" title="show github file">0xb6b2aadddbef17d3a2e67d2e1e321a394176784a.sol</a>
        </div>
        <div class="path">solidity-files/0xb6b2aadddbef17d3a2e67d2e1e321a394176784a.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.21;

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract TokenSender {

    event TransferFail(uint256 index, address receiver, uint256 amount);

    function bulkTransfer(address[] receivers, uint256[] amounts, address token) external {
        address sender = msg.sender;
        uint256 length = receivers.length;
        for (uint256 i = 0; i &amp;lt; length; i++) {
            if (!ERC20(token).transferFrom(sender, receivers[i], amounts[i])) {
                emit TransferFail(i, receivers[i], amounts[i]);
                return;
            }
        }
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x4f203c744e345344bbd70711d289ecb22fe29ab7.sol" target="_blank" title="show github file">0x4f203c744e345344bbd70711d289ecb22fe29ab7.sol</a>
        </div>
        <div class="path">solidity-files/0x4f203c744e345344bbd70711d289ecb22fe29ab7.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.16;

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }

contract SocialChain {
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address =&amp;gt; uint256) public balanceOf;
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);

    /**
     * Constructor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = 2000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = &amp;quot;SocialChain&amp;quot;;                                   // Set the name for display purposes
        symbol =&amp;quot; SCA&amp;quot;;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] &amp;gt;= _value);
        // Check for overflows
        require(balanceOf[_to] + _value &amp;gt; balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` on behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value &amp;lt;= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] &amp;gt;= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] &amp;gt;= _value);                // Check if the targeted balance is enough
        require(_value &amp;lt;= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender&amp;#39;s allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x408db62ff3bcac251c0d11368326579d01762cc5.sol" target="_blank" title="show github file">0x408db62ff3bcac251c0d11368326579d01762cc5.sol</a>
        </div>
        <div class="path">solidity-files/0x408db62ff3bcac251c0d11368326579d01762cc5.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.19;

// File: contracts/BdpBaseData.sol

contract BdpBaseData {

	address public ownerAddress;

	address public managerAddress;

	address[16] public contracts;

	bool public paused = false;

	bool public setupCompleted = false;

	bytes8 public version;

}

// File: contracts/libraries/BdpContracts.sol

library BdpContracts {

	function getBdpEntryPoint(address[16] _contracts) pure internal returns (address) {
		return _contracts[0];
	}

	function getBdpController(address[16] _contracts) pure internal returns (address) {
		return _contracts[1];
	}

	function getBdpControllerHelper(address[16] _contracts) pure internal returns (address) {
		return _contracts[3];
	}

	function getBdpDataStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[4];
	}

	function getBdpImageStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[5];
	}

	function getBdpOwnershipStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[6];
	}

	function getBdpPriceStorage(address[16] _contracts) pure internal returns (address) {
		return _contracts[7];
	}

}

// File: contracts/BdpBase.sol

contract BdpBase is BdpBaseData {

	modifier onlyOwner() {
		require(msg.sender == ownerAddress);
		_;
	}

	modifier onlyAuthorized() {
		require(msg.sender == ownerAddress || msg.sender == managerAddress);
		_;
	}

	modifier whileContractIsActive() {
		require(!paused &amp;amp;&amp;amp; setupCompleted);
		_;
	}

	modifier storageAccessControl() {
		require(
			(! setupCompleted &amp;amp;&amp;amp; (msg.sender == ownerAddress || msg.sender == managerAddress))
			|| (setupCompleted &amp;amp;&amp;amp; !paused &amp;amp;&amp;amp; (msg.sender == BdpContracts.getBdpEntryPoint(contracts)))
		);
		_;
	}

	function setOwner(address _newOwner) external onlyOwner {
		require(_newOwner != address(0));
		ownerAddress = _newOwner;
	}

	function setManager(address _newManager) external onlyOwner {
		require(_newManager != address(0));
		managerAddress = _newManager;
	}

	function setContracts(address[16] _contracts) external onlyOwner {
		contracts = _contracts;
	}

	function pause() external onlyAuthorized {
		paused = true;
	}

	function unpause() external onlyOwner {
		paused = false;
	}

	function setSetupCompleted() external onlyOwner {
		setupCompleted = true;
	}

	function kill() public onlyOwner {
		selfdestruct(ownerAddress);
	}

}

// File: contracts/libraries/SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

	/**
	* @dev Multiplies two numbers, throws on overflow.
	*/
	function mul(uint256 a, uint256 b) internal pure returns (uint256) {
		if (a == 0) {
			return 0;
		}
		uint256 c = a * b;
		assert(c / a == b);
		return c;
	}

	/**
	* @dev Integer division of two numbers, truncating the quotient.
	*/
	function div(uint256 a, uint256 b) internal pure returns (uint256) {
		// assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0
		uint256 c = a / b;
		// assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
		return c;
	}

	/**
	* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
	*/
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
		assert(b &amp;lt;= a);
		return a - b;
	}

	/**
	* @dev Adds two numbers, throws on overflow.
	*/
	function add(uint256 a, uint256 b) internal pure returns (uint256) {
		uint256 c = a + b;
		assert(c &amp;gt;= a);
		return c;
	}
}

// File: contracts/storage/BdpDataStorage.sol

contract BdpDataStorage is BdpBase {

	using SafeMath for uint256;

	struct Region {
		uint256 x1;
		uint256 y1;
		uint256 x2;
		uint256 y2;
		uint256 currentImageId;
		uint256 nextImageId;
		uint8[128] url;
		uint256 currentPixelPrice;
		uint256 blockUpdatedAt;
		uint256 updatedAt;
		uint256 purchasedAt;
		uint256 purchasedPixelPrice;
	}

	uint256 public lastRegionId = 0;

	mapping (uint256 =&amp;gt; Region) public data;


	function getLastRegionId() view public returns (uint256) {
		return lastRegionId;
	}

	function getNextRegionId() public storageAccessControl returns (uint256) {
		lastRegionId = lastRegionId.add(1);
		return lastRegionId;
	}

	function deleteRegionData(uint256 _id) public storageAccessControl {
		delete data[_id];
	}

	function getRegionCoordinates(uint256 _id) view public returns (uint256, uint256, uint256, uint256) {
		return (data[_id].x1, data[_id].y1, data[_id].x2, data[_id].y2);
	}

	function setRegionCoordinates(uint256 _id, uint256 _x1, uint256 _y1, uint256 _x2, uint256 _y2) public storageAccessControl {
		data[_id].x1 = _x1;
		data[_id].y1 = _y1;
		data[_id].x2 = _x2;
		data[_id].y2 = _y2;
	}

	function getRegionCurrentImageId(uint256 _id) view public returns (uint256) {
		return data[_id].currentImageId;
	}

	function setRegionCurrentImageId(uint256 _id, uint256 _currentImageId) public storageAccessControl {
		data[_id].currentImageId = _currentImageId;
	}

	function getRegionNextImageId(uint256 _id) view public returns (uint256) {
		return data[_id].nextImageId;
	}

	function setRegionNextImageId(uint256 _id, uint256 _nextImageId) public storageAccessControl {
		data[_id].nextImageId = _nextImageId;
	}

	function getRegionUrl(uint256 _id) view public returns (uint8[128]) {
		return data[_id].url;
	}

	function setRegionUrl(uint256 _id, uint8[128] _url) public storageAccessControl {
		data[_id].url = _url;
	}

	function getRegionCurrentPixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].currentPixelPrice;
	}

	function setRegionCurrentPixelPrice(uint256 _id, uint256 _currentPixelPrice) public storageAccessControl {
		data[_id].currentPixelPrice = _currentPixelPrice;
	}

	function getRegionBlockUpdatedAt(uint256 _id) view public returns (uint256) {
		return data[_id].blockUpdatedAt;
	}

	function setRegionBlockUpdatedAt(uint256 _id, uint256 _blockUpdatedAt) public storageAccessControl {
		data[_id].blockUpdatedAt = _blockUpdatedAt;
	}

	function getRegionUpdatedAt(uint256 _id) view public returns (uint256) {
		return data[_id].updatedAt;
	}

	function setRegionUpdatedAt(uint256 _id, uint256 _updatedAt) public storageAccessControl {
		data[_id].updatedAt = _updatedAt;
	}

	function getRegionPurchasedAt(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedAt;
	}

	function setRegionPurchasedAt(uint256 _id, uint256 _purchasedAt) public storageAccessControl {
		data[_id].purchasedAt = _purchasedAt;
	}

	function getRegionUpdatedAtPurchasedAt(uint256 _id) view public returns (uint256 _updatedAt, uint256 _purchasedAt) {
		return (data[_id].updatedAt, data[_id].purchasedAt);
	}

	function getRegionPurchasePixelPrice(uint256 _id) view public returns (uint256) {
		return data[_id].purchasedPixelPrice;
	}

	function setRegionPurchasedPixelPrice(uint256 _id, uint256 _purchasedPixelPrice) public storageAccessControl {
		data[_id].purchasedPixelPrice = _purchasedPixelPrice;
	}

	function BdpDataStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/storage/BdpImageStorage.sol

contract BdpImageStorage is BdpBase {

	using SafeMath for uint256;

	struct Image {
		address owner;
		uint256 regionId;
		uint256 currentRegionId;
		mapping(uint16 =&amp;gt; uint256[1000]) data;
		mapping(uint16 =&amp;gt; uint16) dataLength;
		uint16 partsCount;
		uint16 width;
		uint16 height;
		uint16 imageDescriptor;
		uint256 blurredAt;
	}

	uint256 public lastImageId = 0;

	mapping(uint256 =&amp;gt; Image) public images;


	function getLastImageId() view public returns (uint256) {
		return lastImageId;
	}

	function getNextImageId() public storageAccessControl returns (uint256) {
		lastImageId = lastImageId.add(1);
		return lastImageId;
	}

	function createImage(address _owner, uint256 _regionId, uint16 _width, uint16 _height, uint16 _partsCount, uint16 _imageDescriptor) public storageAccessControl returns (uint256) {
		require(_owner != address(0) &amp;amp;&amp;amp; _width &amp;gt; 0 &amp;amp;&amp;amp; _height &amp;gt; 0 &amp;amp;&amp;amp; _partsCount &amp;gt; 0 &amp;amp;&amp;amp; _imageDescriptor &amp;gt; 0);
		uint256 id = getNextImageId();
		images[id].owner = _owner;
		images[id].regionId = _regionId;
		images[id].width = _width;
		images[id].height = _height;
		images[id].partsCount = _partsCount;
		images[id].imageDescriptor = _imageDescriptor;
		return id;
	}

	function imageExists(uint256 _imageId) view public returns (bool) {
		return _imageId &amp;gt; 0 &amp;amp;&amp;amp; images[_imageId].owner != address(0);
	}

	function deleteImage(uint256 _imageId) public storageAccessControl {
		require(imageExists(_imageId));
		delete images[_imageId];
	}

	function getImageOwner(uint256 _imageId) public view returns (address) {
		require(imageExists(_imageId));
		return images[_imageId].owner;
	}

	function setImageOwner(uint256 _imageId, address _owner) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].owner = _owner;
	}

	function getImageRegionId(uint256 _imageId) public view returns (uint256) {
		require(imageExists(_imageId));
		return images[_imageId].regionId;
	}

	function setImageRegionId(uint256 _imageId, uint256 _regionId) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].regionId = _regionId;
	}

	function getImageCurrentRegionId(uint256 _imageId) public view returns (uint256) {
		require(imageExists(_imageId));
		return images[_imageId].currentRegionId;
	}

	function setImageCurrentRegionId(uint256 _imageId, uint256 _currentRegionId) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].currentRegionId = _currentRegionId;
	}

	function getImageData(uint256 _imageId, uint16 _part) view public returns (uint256[1000]) {
		require(imageExists(_imageId));
		return images[_imageId].data[_part];
	}

	function setImageData(uint256 _imageId, uint16 _part, uint256[] _data) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].dataLength[_part] = uint16(_data.length);
		for (uint256 i = 0; i &amp;lt; _data.length; i++) {
			images[_imageId].data[_part][i] = _data[i];
		}
	}

	function getImageDataLength(uint256 _imageId, uint16 _part) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].dataLength[_part];
	}

	function setImageDataLength(uint256 _imageId, uint16 _part, uint16 _dataLength) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].dataLength[_part] = _dataLength;
	}

	function getImagePartsCount(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].partsCount;
	}

	function setImagePartsCount(uint256 _imageId, uint16 _partsCount) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].partsCount = _partsCount;
	}

	function getImageWidth(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].width;
	}

	function setImageWidth(uint256 _imageId, uint16 _width) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].width = _width;
	}

	function getImageHeight(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].height;
	}

	function setImageHeight(uint256 _imageId, uint16 _height) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].height = _height;
	}

	function getImageDescriptor(uint256 _imageId) view public returns (uint16) {
		require(imageExists(_imageId));
		return images[_imageId].imageDescriptor;
	}

	function setImageDescriptor(uint256 _imageId, uint16 _imageDescriptor) public storageAccessControl {
		require(imageExists(_imageId));
		images[_imageId].imageDescriptor = _imageDescriptor;
	}

	function getImageBlurredAt(uint256 _imageId) view public returns (uint256) {
		return images[_imageId].blurredAt;
	}

	function setImageBlurredAt(uint256 _imageId, uint256 _blurredAt) public storageAccessControl {
		images[_imageId].blurredAt = _blurredAt;
	}

	function imageUploadComplete(uint256 _imageId) view public returns (bool) {
		require(imageExists(_imageId));
		for (uint16 i = 1; i &amp;lt;= images[_imageId].partsCount; i++) {
			if(images[_imageId].data[i].length == 0) {
				return false;
			}
		}
		return true;
	}

	function BdpImageStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/storage/BdpPriceStorage.sol

contract BdpPriceStorage is BdpBase {

	uint64[1001] public pricePoints;

	uint256 public pricePointsLength = 0;

	address public forwardPurchaseFeesTo = address(0);

	address public forwardUpdateFeesTo = address(0);


	function getPricePointsLength() view public returns (uint256) {
		return pricePointsLength;
	}

	function getPricePoint(uint256 _i) view public returns (uint256) {
		return pricePoints[_i];
	}

	function setPricePoints(uint64[] _pricePoints) public storageAccessControl {
		pricePointsLength = 0;
		appendPricePoints(_pricePoints);
	}

	function appendPricePoints(uint64[] _pricePoints) public storageAccessControl {
		for (uint i = 0; i &amp;lt; _pricePoints.length; i++) {
			pricePoints[pricePointsLength++] = _pricePoints[i];
		}
	}

	function getForwardPurchaseFeesTo() view public returns (address) {
		return forwardPurchaseFeesTo;
	}

	function setForwardPurchaseFeesTo(address _forwardPurchaseFeesTo) public storageAccessControl {
		forwardPurchaseFeesTo = _forwardPurchaseFeesTo;
	}

	function getForwardUpdateFeesTo() view public returns (address) {
		return forwardUpdateFeesTo;
	}

	function setForwardUpdateFeesTo(address _forwardUpdateFeesTo) public storageAccessControl {
		forwardUpdateFeesTo = _forwardUpdateFeesTo;
	}

	function BdpPriceStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/libraries/BdpCalculator.sol

library BdpCalculator {

	using SafeMath for uint256;

	function calculateArea(address[16] _contracts, uint256 _regionId) view public returns (uint256 _area, uint256 _width, uint256 _height) {
		var (x1, y1, x2, y2) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCoordinates(_regionId);
		_width = x2 - x1 + 1;
		_height = y2 - y1 + 1;
		_area = _width * _height;
	}

	function countPurchasedPixels(address[16] _contracts) view public returns (uint256 _count) {
		var lastRegionId = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getLastRegionId();
		for (uint256 i = 0; i &amp;lt;= lastRegionId; i++) {
			if(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionPurchasedAt(i) &amp;gt; 0) { // region is purchased
				var (area,,) = calculateArea(_contracts, i);
				_count += area;
			}
		}
	}

	function calculateCurrentMarketPixelPrice(address[16] _contracts) view public returns(uint) {
		return calculateMarketPixelPrice(_contracts, countPurchasedPixels(_contracts));
	}

	function calculateMarketPixelPrice(address[16] _contracts, uint _pixelsSold) view public returns(uint) {
		var pricePointsLength = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePointsLength();
		uint mod = _pixelsSold % (1000000 / (pricePointsLength - 1));
		uint div = _pixelsSold * (pricePointsLength - 1) / 1000000;
		var divPoint = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div);
		if(mod == 0) return divPoint;
		return divPoint + mod * (BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div+1) - divPoint) * (pricePointsLength - 1) / 1000000;
	}

	function calculateAveragePixelPrice(address[16] _contracts, uint _a, uint _b) view public returns (uint _price) {
		_price = (calculateMarketPixelPrice(_contracts, _a) + calculateMarketPixelPrice(_contracts, _b)) / 2;
	}

	/** Current market price per pixel for this region if it is the first sale of this region
	  */
	function calculateRegionInitialSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		require(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAt(_regionId) &amp;gt; 0); // region exists
		var purchasedPixels = countPurchasedPixels(_contracts);
		var (area,,) = calculateArea(_contracts, _regionId);
		return calculateAveragePixelPrice(_contracts, purchasedPixels, purchasedPixels + area);
	}

	/** Current market price or (Current market price)*3 if the region was sold
	  */
	function calculateRegionSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		var pixelPrice = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCurrentPixelPrice(_regionId);
		if(pixelPrice &amp;gt; 0) {
			return pixelPrice * 3;
		} else {
			return calculateRegionInitialSalePixelPrice(_contracts, _regionId);
		}
	}

	/** Setup is allowed one whithin one day after purchase
	  */
	function calculateSetupAllowedUntil(address[16] _contracts, uint256 _regionId) view public returns (uint256) {
		var (updatedAt, purchasedAt) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAtPurchasedAt(_regionId);
		if(updatedAt != purchasedAt) {
			return 0;
		} else {
			return purchasedAt + 1 days;
		}
	}

}

// File: contracts/storage/BdpOwnershipStorage.sol

contract BdpOwnershipStorage is BdpBase {

	using SafeMath for uint256;

	// Mapping from token ID to owner
	mapping (uint256 =&amp;gt; address) public tokenOwner;

	// Mapping from token ID to approved address
	mapping (uint256 =&amp;gt; address) public tokenApprovals;

	// Mapping from owner to the sum of owned area
	mapping (address =&amp;gt; uint256) public ownedArea;

	// Mapping from owner to list of owned token IDs
	mapping (address =&amp;gt; uint256[]) public ownedTokens;

	// Mapping from token ID to index of the owner tokens list
	mapping(uint256 =&amp;gt; uint256) public ownedTokensIndex;

	// All tokens list tokens ids
	uint256[] public tokenIds;

	// Mapping from tokenId to index of the tokens list
	mapping (uint256 =&amp;gt; uint256) public tokenIdsIndex;


	function getTokenOwner(uint256 _tokenId) view public returns (address) {
		return tokenOwner[_tokenId];
	}

	function setTokenOwner(uint256 _tokenId, address _owner) public storageAccessControl {
		tokenOwner[_tokenId] = _owner;
	}

	function getTokenApproval(uint256 _tokenId) view public returns (address) {
		return tokenApprovals[_tokenId];
	}

	function setTokenApproval(uint256 _tokenId, address _to) public storageAccessControl {
		tokenApprovals[_tokenId] = _to;
	}

	function getOwnedArea(address _owner) view public returns (uint256) {
		return ownedArea[_owner];
	}

	function setOwnedArea(address _owner, uint256 _area) public storageAccessControl {
		ownedArea[_owner] = _area;
	}

	function incrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].add(_area);
		return ownedArea[_owner];
	}

	function decrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {
		ownedArea[_owner] = ownedArea[_owner].sub(_area);
		return ownedArea[_owner];
	}

	function getOwnedTokensLength(address _owner) view public returns (uint256) {
		return ownedTokens[_owner].length;
	}

	function getOwnedToken(address _owner, uint256 _index) view public returns (uint256) {
		return ownedTokens[_owner][_index];
	}

	function setOwnedToken(address _owner, uint256 _index, uint256 _tokenId) public storageAccessControl {
		ownedTokens[_owner][_index] = _tokenId;
	}

	function pushOwnedToken(address _owner, uint256 _tokenId) public storageAccessControl returns (uint256) {
		ownedTokens[_owner].push(_tokenId);
		return ownedTokens[_owner].length;
	}

	function decrementOwnedTokensLength(address _owner) public storageAccessControl {
		ownedTokens[_owner].length--;
	}

	function getOwnedTokensIndex(uint256 _tokenId) view public returns (uint256) {
		return ownedTokensIndex[_tokenId];
	}

	function setOwnedTokensIndex(uint256 _tokenId, uint256 _tokenIndex) public storageAccessControl {
		ownedTokensIndex[_tokenId] = _tokenIndex;
	}

	function getTokenIdsLength() view public returns (uint256) {
		return tokenIds.length;
	}

	function getTokenIdByIndex(uint256 _index) view public returns (uint256) {
		return tokenIds[_index];
	}

	function setTokenIdByIndex(uint256 _index, uint256 _tokenId) public storageAccessControl {
		tokenIds[_index] = _tokenId;
	}

	function pushTokenId(uint256 _tokenId) public storageAccessControl returns (uint256) {
		tokenIds.push(_tokenId);
		return tokenIds.length;
	}

	function decrementTokenIdsLength() public storageAccessControl {
		tokenIds.length--;
	}

	function getTokenIdsIndex(uint256 _tokenId) view public returns (uint256) {
		return tokenIdsIndex[_tokenId];
	}

	function setTokenIdsIndex(uint256 _tokenId, uint256 _tokenIdIndex) public storageAccessControl {
		tokenIdsIndex[_tokenId] = _tokenIdIndex;
	}

	function BdpOwnershipStorage(bytes8 _version) public {
		ownerAddress = msg.sender;
		managerAddress = msg.sender;
		version = _version;
	}

}

// File: contracts/libraries/BdpOwnership.sol

/**
 * Ownership manager
 * Does not check if the caller is allowed to call functions
 * State changing methods are not intended to be called from controller
 */
library BdpOwnership {

	using SafeMath for uint256;

	event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

	event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

	function ownerOf(address[16] _contracts, uint256 _tokenId) public view returns (address) {
		var owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);
		require(owner != address(0));
		return owner;
	}

	function balanceOf(address[16] _contracts, address _owner) public view returns (uint256) {
		return BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getOwnedTokensLength(_owner);
	}

	function approve(address[16] _contracts, address _to, uint256 _tokenId) public {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		address owner = ownerOf(_contracts, _tokenId);
		require(_to != owner);
		if (ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0) {
			ownStorage.setTokenApproval(_tokenId, _to);
			Approval(owner, _to, _tokenId);
		}
	}

	/**
	 * @dev Clear current approval of a given token ID
	 * @param _tokenId uint256 ID of the token to be transferred
	 */
	function clearApproval(address[16] _contracts, address _owner, uint256 _tokenId) public {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownerOf(_contracts, _tokenId) == _owner);
		if (ownStorage.getTokenApproval(_tokenId) != 0) {
			BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).setTokenApproval(_tokenId, 0);
			Approval(_owner, 0, _tokenId);
		}
	}

	/**
	 * @dev Clear current approval and transfer the ownership of a given token ID
	 * @param _from address which you want to send tokens from
	 * @param _to address which you want to transfer the token to
	 * @param _tokenId uint256 ID of the token to be transferred
	 */
	function clearApprovalAndTransfer(address[16] _contracts, address _from, address _to, uint256 _tokenId) public {
		require(_to != address(0));
		require(_to != ownerOf(_contracts, _tokenId));
		require(ownerOf(_contracts, _tokenId) == _from);

		clearApproval(_contracts, _from, _tokenId);
		removeToken(_contracts, _from, _tokenId);
		addToken(_contracts, _to, _tokenId);
		Transfer(_from, _to, _tokenId);
	}

	/**
	 * @dev Internal function to add a token ID to the list of a given address
	 * @param _to address representing the new owner of the given token ID
	 * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address
	 */
	function addToken(address[16] _contracts, address _to, uint256 _tokenId) private {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownStorage.getTokenOwner(_tokenId) == address(0));

		// Set token owner
		ownStorage.setTokenOwner(_tokenId, _to);

		// Add token to tokenIds list
		var tokenIdsLength = ownStorage.pushTokenId(_tokenId);
		ownStorage.setTokenIdsIndex(_tokenId, tokenIdsLength.sub(1));

		uint256 ownedTokensLength = ownStorage.getOwnedTokensLength(_to);

		// Add token to ownedTokens list
		ownStorage.pushOwnedToken(_to, _tokenId);
		ownStorage.setOwnedTokensIndex(_tokenId, ownedTokensLength);

		// Increment total owned area
		var (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);
		ownStorage.incrementOwnedArea(_to, area);
	}

	/**
	 * @dev Internal function to remove a token ID from the list of a given address
	 * @param _from address representing the previous owner of the given token ID
	 * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address
	 */
	function removeToken(address[16] _contracts, address _from, uint256 _tokenId) private {
		var ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));

		require(ownerOf(_contracts, _tokenId) == _from);

		// Clear token owner
		ownStorage.setTokenOwner(_tokenId, 0);

		removeFromTokenIds(ownStorage, _tokenId);
		removeFromOwnedToken(ownStorage, _from, _tokenId);

		// Decrement total owned area
		var (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);
		ownStorage.decrementOwnedArea(_from, area);
	}

	/**
	 * @dev Remove token from ownedTokens list
	 * Note that this will handle single-element arrays. In that case, both ownedTokenIndex and lastOwnedTokenIndex are going to
	 * be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping
	 * the lastOwnedToken to the first position, and then dropping the element placed in the last position of the list
	 */
	function removeFromOwnedToken(BdpOwnershipStorage _ownStorage, address _from, uint256 _tokenId) private {
		var ownedTokenIndex = _ownStorage.getOwnedTokensIndex(_tokenId);
		var lastOwnedTokenIndex = _ownStorage.getOwnedTokensLength(_from).sub(1);
		var lastOwnedToken = _ownStorage.getOwnedToken(_from, lastOwnedTokenIndex);
		_ownStorage.setOwnedToken(_from, ownedTokenIndex, lastOwnedToken);
		_ownStorage.setOwnedToken(_from, lastOwnedTokenIndex, 0);
		_ownStorage.decrementOwnedTokensLength(_from);
		_ownStorage.setOwnedTokensIndex(_tokenId, 0);
		_ownStorage.setOwnedTokensIndex(lastOwnedToken, ownedTokenIndex);
	}

	/**
	 * @dev Remove token from tokenIds list
	 */
	function removeFromTokenIds(BdpOwnershipStorage _ownStorage, uint256 _tokenId) private {
		var tokenIndex = _ownStorage.getTokenIdsIndex(_tokenId);
		var lastTokenIdIndex = _ownStorage.getTokenIdsLength().sub(1);
		var lastTokenId = _ownStorage.getTokenIdByIndex(lastTokenIdIndex);
		_ownStorage.setTokenIdByIndex(tokenIndex, lastTokenId);
		_ownStorage.setTokenIdByIndex(lastTokenIdIndex, 0);
		_ownStorage.decrementTokenIdsLength();
		_ownStorage.setTokenIdsIndex(_tokenId, 0);
		_ownStorage.setTokenIdsIndex(lastTokenId, tokenIndex);
	}

	/**
	 * @dev Mint token function
	 * @param _to The address that will own the minted token
	 * @param _tokenId uint256 ID of the token to be minted by the msg.sender
	 */
	function mint(address[16] _contracts, address _to, uint256 _tokenId) public {
		require(_to != address(0));
		addToken(_contracts, _to, _tokenId);
		Transfer(address(0), _to, _tokenId);
	}

	/**
	 * @dev Burns a specific token
	 * @param _tokenId uint256 ID of the token being burned
	 */
	function burn(address[16] _contracts, uint256 _tokenId) public {
		address owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);
		clearApproval(_contracts, owner, _tokenId);
		removeToken(_contracts, owner, _tokenId);
		Transfer(owner, address(0), _tokenId);
	}

}

// File: contracts/libraries/BdpImage.sol

library BdpImage {

	function checkImageInput(address[16] _contracts, uint256 _regionId, uint256 _imageId, uint256[] _imageData, bool _swapImages, bool _clearImage) view public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));

		require( (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage) // Only one way to change image can be specified
			|| (_imageId != 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage) // If image has to be changed
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length != 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; !_clearImage)
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; _swapImages &amp;amp;&amp;amp; !_clearImage)
			|| (_imageId == 0 &amp;amp;&amp;amp; _imageData.length == 0 &amp;amp;&amp;amp; !_swapImages &amp;amp;&amp;amp; _clearImage) );

		require(_imageId == 0 || // Can use only own images not used by other regions
			( (msg.sender == imageStorage.getImageOwner(_imageId)) &amp;amp;&amp;amp; (imageStorage.getImageCurrentRegionId(_imageId) == 0) ) );

		var nextImageId = dataStorage.getRegionNextImageId(_regionId);
		require(!_swapImages || imageUploadComplete(_contracts, nextImageId)); // Can swap images if next image upload is complete
	}

	function setNextImagePart(address[16] _contracts, uint256 _regionId, uint16 _part, uint16 _partsCount, uint16 _imageDescriptor, uint256[] _imageData) public {
		var dataStorage = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts));
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));

		require(BdpOwnership.ownerOf(_contracts, _regionId) == msg.sender);
		require(_imageData.length != 0);
		require(_part &amp;gt; 0);
		require(_part &amp;lt;= _partsCount);

		var nextImageId = dataStorage.getRegionNextImageId(_regionId);
		if(nextImageId == 0 || _imageDescriptor != imageStorage.getImageDescriptor(nextImageId)) {
			var (, width, height) = BdpCalculator.calculateArea(_contracts, _regionId);
			nextImageId = imageStorage.createImage(msg.sender, _regionId, uint16(width), uint16(height), _partsCount, _imageDescriptor);
			dataStorage.setRegionNextImageId(_regionId, nextImageId);
		}

		imageStorage.setImageData(nextImageId, _part, _imageData);
	}

	function setImageOwner(address[16] _contracts, uint256 _imageId, address _owner) public {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		require(imageStorage.getImageOwner(_imageId) == msg.sender);
		require(_owner != address(0));

		imageStorage.setImageOwner(_imageId, _owner);
	}

	function setImageData(address[16] _contracts, uint256 _imageId, uint16 _part, uint256[] _imageData) public returns (address) {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		require(imageStorage.getImageOwner(_imageId) == msg.sender);
		require(imageStorage.getImageCurrentRegionId(_imageId) == 0);
		require(_imageData.length != 0);
		require(_part &amp;gt; 0);
		require(_part &amp;lt;= imageStorage.getImagePartsCount(_imageId));

		imageStorage.setImageData(_imageId, _part, _imageData);
	}

	function imageUploadComplete(address[16] _contracts, uint256 _imageId) view public returns (bool) {
		var imageStorage = BdpImageStorage(BdpContracts.getBdpImageStorage(_contracts));
		var partsCount = imageStorage.getImagePartsCount(_imageId);
		for (uint16 i = 1; i &amp;lt;= partsCount; i++) {
			if(imageStorage.getImageDataLength(_imageId, i) == 0) {
				return false;
			}
		}
		return true;
	}

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xaa42f23cb88318f5a9b67ea302a81c7d5ae1c347.sol" target="_blank" title="show github file">0xaa42f23cb88318f5a9b67ea302a81c7d5ae1c347.sol</a>
        </div>
        <div class="path">solidity-files/0xaa42f23cb88318f5a9b67ea302a81c7d5ae1c347.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.11;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b &amp;gt; 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b;
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn&amp;#39;t hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c &amp;gt;= a);
    return c;
  }
}

/**
 * @title Crowdsale
 * @dev Crowdsale is a base contract for managing a token crowdsale.
 * Crowdsales have a start and end timestamps, where investors can make
 * token purchases and the crowdsale will assign them tokens based
 * on a token per ETH rate. Funds collected are forwarded 
 to a wallet
 * as they arrive.
 */
contract token { function transfer(address receiver, uint amount){  } }
contract Crowdsale {
  using SafeMath for uint256;

  // uint256 durationInMinutes;
  // address where funds are collected
  address public wallet;
  // token address
  address public addressOfTokenUsedAsReward;

  uint256 public price = 38000;

  token tokenReward;

  // mapping (address =&amp;gt; uint) public contributions;
  


  // start and end timestamps where investments are allowed (both inclusive)
  // uint256 public startTime;
  // uint256 public endTime;
  // amount of raised money in wei
  uint256 public weiRaised;

  /**
   * event for token purchase logging
   * @param purchaser who paid for the tokens
   * @param beneficiary who got the tokens
   * @param value weis paid for purchase
   * @param amount amount of tokens purchased
   */
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale() {
    //You will change this to your wallet where you need the ETH 
    wallet = 0xec3eBe2D69B01B14441E4dA66143B73F6706ed6d;
    // durationInMinutes = _durationInMinutes;
    //Here will come the checksum address we got
    addressOfTokenUsedAsReward = 0x967081D634F01003B2c5b3d8Ea5Aa2c55000722e;


    tokenReward = token(addressOfTokenUsedAsReward);
  }

  bool public started = true;

  function startSale(){
    if (msg.sender != wallet) throw;
    started = true;
  }

  function stopSale(){
    if(msg.sender != wallet) throw;
    started = false;
  }

  function setPrice(uint256 _price){
    if(msg.sender != wallet) throw;
    price = _price;
  }
  function changeWallet(address _wallet){
  	if(msg.sender != wallet) throw;
  	wallet = _wallet;
  }

  function changeTokenReward(address _token){
    if(msg.sender!=wallet) throw;
    tokenReward = token(_token);
    addressOfTokenUsedAsReward = _token;
  }

  // fallback function can be used to buy tokens
  function () payable {
    buyTokens(msg.sender);
  }

  // low level token purchase function
  function buyTokens(address beneficiary) payable {
    require(beneficiary != 0x0);
    require(validPurchase());

    uint256 weiAmount = msg.value;

    // if(weiAmount &amp;lt; 10**16) throw;
    // if(weiAmount &amp;gt; 50*10**18) throw;

    // calculate token amount to be sent
    uint256 tokens = (weiAmount) * price;//weiamount * price 
    // uint256 tokens = (weiAmount/10**(18-decimals)) * price;//weiamount * price 

    // update state
    weiRaised = weiRaised.add(weiAmount);
    
    // if(contributions[msg.sender].add(weiAmount)&amp;gt;10*10**18) throw;
    // contributions[msg.sender] = contributions[msg.sender].add(weiAmount);

    tokenReward.transfer(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
    forwardFunds();
  }

  // send ether to the fund collection wallet
  // override to create custom fund forwarding mechanisms
  function forwardFunds() internal {
    // wallet.transfer(msg.value);
    if (!wallet.send(msg.value)) {
      throw;
    }
  }

  // @return true if the transaction can buy tokens
  function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod &amp;amp;&amp;amp; nonZeroPurchase;
  }

  function withdrawTokens(uint256 _amount) {
    if(msg.sender!=wallet) throw;
    tokenReward.transfer(wallet,_amount);
  }
}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0xa926860248364b0e42603ed1c38baa4daf8ff569.sol" target="_blank" title="show github file">0xa926860248364b0e42603ed1c38baa4daf8ff569.sol</a>
        </div>
        <div class="path">solidity-files/0xa926860248364b0e42603ed1c38baa4daf8ff569.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;
    
    // ----------------------------------------------------------------------------
    // &amp;#39;ACT125845&amp;#39; token contract
    //
    // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187
    // Symbol      : ACT125845
    // Name        : ADZbuzz Medicalnewstoday.com Community Token
    // Total supply: 2000000
    // Decimals    : 8
    //
    // Enjoy.
    //
    // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.
    // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. 
    // ----------------------------------------------------------------------------
    
    
    // ----------------------------------------------------------------------------
    // Safe maths
    // ----------------------------------------------------------------------------
    contract SafeMath {
        function safeAdd(uint a, uint b) public pure returns (uint c) {
            c = a + b;
            require(c &amp;gt;= a);
        }
        function safeSub(uint a, uint b) public pure returns (uint c) {
            require(b &amp;lt;= a);
            c = a - b;
        }
        function safeMul(uint a, uint b) public pure returns (uint c) {
            c = a * b;
            require(a == 0 || c / a == b);
        }
        function safeDiv(uint a, uint b) public pure returns (uint c) {
            require(b &amp;gt; 0);
            c = a / b;
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC Token Standard #20 Interface
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // ----------------------------------------------------------------------------
    contract ERC20Interface {
        function totalSupply() public constant returns (uint);
        function balanceOf(address tokenOwner) public constant returns (uint balance);
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
        function transfer(address to, uint tokens) public returns (bool success);
        function approve(address spender, uint tokens) public returns (bool success);
        function transferFrom(address from, address to, uint tokens) public returns (bool success);
    
        event Transfer(address indexed from, address indexed to, uint tokens);
        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    }
    
    
    // ----------------------------------------------------------------------------
    // Contract function to receive approval and execute function in one call
    //
    // Borrowed from MiniMeToken
    // ----------------------------------------------------------------------------
    contract ApproveAndCallFallBack {
        function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
    }
    
    
    // ----------------------------------------------------------------------------
    // Owned contract
    // ----------------------------------------------------------------------------
    contract Owned {
        address public owner;
        address public newOwner;
    
        event OwnershipTransferred(address indexed _from, address indexed _to);
    
        function Owned() public {
            owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187;
        }
    
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    
        function transferOwnership(address _newOwner) public onlyOwner {
            newOwner = _newOwner;
        }
        function acceptOwnership() public {
            require(msg.sender == newOwner);
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            newOwner = address(0);
        }
    }
    
    
    // ----------------------------------------------------------------------------
    // ERC20 Token, with the addition of symbol, name and decimals and assisted
    // token transfers
    // ----------------------------------------------------------------------------
    contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath {
        string public symbol;
        string public  name;
        uint8 public decimals;
        uint public _totalSupply;
    
        mapping(address =&amp;gt; uint) balances;
        mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;
    
    
        // ------------------------------------------------------------------------
        // Constructor
        // ------------------------------------------------------------------------
        function ADZbuzzCommunityToken() public {
            symbol = &amp;quot;ACT125845&amp;quot;;
            name = &amp;quot;ADZbuzz Medicalnewstoday.com Community Token&amp;quot;;
            decimals = 8;
            _totalSupply = 200000000000000;
            balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply;
            emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply);
        }
    
    
        // ------------------------------------------------------------------------
        // Total supply
        // ------------------------------------------------------------------------
        function totalSupply() public constant returns (uint) {
            return _totalSupply  - balances[address(0)];
        }
    
    
        // ------------------------------------------------------------------------
        // Get the token balance for account tokenOwner
        // ------------------------------------------------------------------------
        function balanceOf(address tokenOwner) public constant returns (uint balance) {
            return balances[tokenOwner];
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer the balance from token owner&amp;#39;s account to to account
        // - Owner&amp;#39;s account must have sufficient balance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transfer(address to, uint tokens) public returns (bool success) {
            balances[msg.sender] = safeSub(balances[msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account
        //
        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
        // recommends that there are no checks for the approval double-spend attack
        // as this should be implemented in user interfaces 
        // ------------------------------------------------------------------------
        function approve(address spender, uint tokens) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Transfer tokens from the from account to the to account
        // 
        // The calling account must already have sufficient tokens approve(...)-d
        // for spending from the from account and
        // - From account must have sufficient balance to transfer
        // - Spender must have sufficient allowance to transfer
        // - 0 value transfers are allowed
        // ------------------------------------------------------------------------
        function transferFrom(address from, address to, uint tokens) public returns (bool success) {
            balances[from] = safeSub(balances[from], tokens);
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
            balances[to] = safeAdd(balances[to], tokens);
            emit Transfer(from, to, tokens);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Returns the amount of tokens approved by the owner that can be
        // transferred to the spender&amp;#39;s account
        // ------------------------------------------------------------------------
        function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
            return allowed[tokenOwner][spender];
        }
    
    
        // ------------------------------------------------------------------------
        // Token owner can approve for spender to transferFrom(...) tokens
        // from the token owner&amp;#39;s account. The spender contract function
        // receiveApproval(...) is then executed
        // ------------------------------------------------------------------------
        function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
            allowed[msg.sender][spender] = tokens;
            emit Approval(msg.sender, spender, tokens);
            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
            return true;
        }
    
    
        // ------------------------------------------------------------------------
        // Don&amp;#39;t accept ETH
        // ------------------------------------------------------------------------
        function () public payable {
            revert();
        }
    
    
        // ------------------------------------------------------------------------
        // Owner can transfer out any accidentally sent ERC20 tokens
        // ------------------------------------------------------------------------
        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
            return ERC20Interface(tokenAddress).transfer(owner, tokens);
        }
    }</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x3a78b1e1fc38e61ed38f0e0e8d417cdf09f52016.sol" target="_blank" title="show github file">0x3a78b1e1fc38e61ed38f0e0e8d417cdf09f52016.sol</a>
        </div>
        <div class="path">solidity-files/0x3a78b1e1fc38e61ed38f0e0e8d417cdf09f52016.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------

// Safe maths

// ----------------------------------------------------------------------------

library SafeMath {

    function add(uint a, uint b) internal pure returns (uint c) {

        c = a + b;

        require(c &amp;gt;= a);

    }

    function sub(uint a, uint b) internal pure returns (uint c) {

        require(b &amp;lt;= a);

        c = a - b;

    }

    function mul(uint a, uint b) internal pure returns (uint c) {

        c = a * b;

        require(a == 0 || c / a == b);

    }

    function div(uint a, uint b) internal pure returns (uint c) {

        require(b &amp;gt; 0);

        c = a / b;

    }

}



// ----------------------------------------------------------------------------

// ERC Token Standard #20 Interface

// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md

// ----------------------------------------------------------------------------

contract ERC20Interface {

    function totalSupply() public constant returns (uint);

    function balanceOf(address tokenOwner) public constant returns (uint balance);

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);

    function transfer(address to, uint tokens) public returns (bool success);

    function approve(address spender, uint tokens) public returns (bool success);

    function transferFrom(address from, address to, uint tokens) public returns (bool success);


    event Transfer(address indexed from, address indexed to, uint tokens);

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}



// ----------------------------------------------------------------------------

// Contract function to receive approval and execute function in one call

//

// Borrowed from MiniMeToken

// ----------------------------------------------------------------------------

contract ApproveAndCallFallBack {

    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;

}



// ----------------------------------------------------------------------------

// Owned contract

// ----------------------------------------------------------------------------

contract Owned {

    address public owner;

    address public newOwner;


    event OwnershipTransferred(address indexed _from, address indexed _to);


    function Owned() public {

        owner = msg.sender;

    }


    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }


    function transferOwnership(address _newOwner) public onlyOwner {

        newOwner = _newOwner;

    }

    function acceptOwnership() public {

        require(msg.sender == newOwner);

        OwnershipTransferred(owner, newOwner);

        owner = newOwner;

        newOwner = address(0);

    }

}



// ----------------------------------------------------------------------------

// ERC20 Token, with the addition of symbol, name and decimals and an

// initial fixed supply

// ----------------------------------------------------------------------------

contract ERC20Token is ERC20Interface, Owned {

    using SafeMath for uint;


    string public symbol;

    string public  name;

    uint8 public decimals;

    uint public _totalSupply;


    mapping(address =&amp;gt; uint) balances;

    mapping(address =&amp;gt; mapping(address =&amp;gt; uint)) allowed;



    // ------------------------------------------------------------------------

    // Constructor 

    // ------------------------------------------------------------------------
	//20000000000000000     发行总量2亿
    //200000000.00000000 

    function ERC20Token() public {

        symbol = &amp;quot;GBCS&amp;quot;;

        name = &amp;quot;Global Brand Coins&amp;quot;;

        decimals = 8;

        _totalSupply = 20000000000000000;

        balances[owner] = _totalSupply;

        Transfer(address(0), owner, _totalSupply);

    }



    // ------------------------------------------------------------------------

    // Total supply

    // ------------------------------------------------------------------------

    function totalSupply() public constant returns (uint) {

        return _totalSupply  - balances[address(0)];

    }



    // ------------------------------------------------------------------------

    // Get the token balance for account `tokenOwner`

    // ------------------------------------------------------------------------

    function balanceOf(address tokenOwner) public constant returns (uint balance) {

        return balances[tokenOwner];

    }



    // ------------------------------------------------------------------------

    // Transfer the balance from token owner&amp;#39;s account to `to` account

    // - Owner&amp;#39;s account must have sufficient balance to transfer

    // - 0 value transfers are allowed

    // ------------------------------------------------------------------------

    function transfer(address to, uint tokens) public returns (bool success) {

        balances[msg.sender] = balances[msg.sender].sub(tokens);

        balances[to] = balances[to].add(tokens);

        Transfer(msg.sender, to, tokens);

        return true;

    }



    // ------------------------------------------------------------------------

    // Token owner can approve for `spender` to transferFrom(...) `tokens`

    // from the token owner&amp;#39;s account

    //

    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md

    // recommends that there are no checks for the approval double-spend attack

    // as this should be implemented in user interfaces 

    // ------------------------------------------------------------------------

    function approve(address spender, uint tokens) public returns (bool success) {

        allowed[msg.sender][spender] = tokens;

        Approval(msg.sender, spender, tokens);

        return true;

    }



    // ------------------------------------------------------------------------

    // Transfer `tokens` from the `from` account to the `to` account

    // 

    // The calling account must already have sufficient tokens approve(...)-d

    // for spending from the `from` account and

    // - From account must have sufficient balance to transfer

    // - Spender must have sufficient allowance to transfer

    // - 0 value transfers are allowed

    // ------------------------------------------------------------------------

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {

        balances[from] = balances[from].sub(tokens);

        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);

        balances[to] = balances[to].add(tokens);

        Transfer(from, to, tokens);

        return true;

    }



    // ------------------------------------------------------------------------

    // Returns the amount of tokens approved by the owner that can be

    // transferred to the spender&amp;#39;s account

    // ------------------------------------------------------------------------

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {

        return allowed[tokenOwner][spender];

    }



    // ------------------------------------------------------------------------

    // Token owner can approve for `spender` to transferFrom(...) `tokens`

    // from the token owner&amp;#39;s account. The `spender` contract function

    // `receiveApproval(...)` is then executed

    // ------------------------------------------------------------------------

    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {

        allowed[msg.sender][spender] = tokens;

        Approval(msg.sender, spender, tokens);

        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);

        return true;

    }



    // ------------------------------------------------------------------------

    // Don&amp;#39;t accept ETH

    // ------------------------------------------------------------------------

    function () public payable {

        revert();

    }



    // ------------------------------------------------------------------------

    // Owner can transfer out any accidentally sent ERC20 tokens

    // ------------------------------------------------------------------------

    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {

        return ERC20Interface(tokenAddress).transfer(owner, tokens);

    }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/solidity-files/0x05C540B8e414A85C106CCe3EFBF6337F321BC9f0.sol" target="_blank" title="show github file">0x05C540B8e414A85C106CCe3EFBF6337F321BC9f0.sol</a>
        </div>
        <div class="path">solidity-files/0x05C540B8e414A85C106CCe3EFBF6337F321BC9f0.sol</div>
    </div>
    <div class="body">
        <pre class="content"><code class="sol">// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network 
/**
 * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net
 *
 * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt
 */

pragma solidity ^0.4.6;

/**
 * Safe unsigned safe math.
 *
 * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli
 *
 * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol
 *
 * Maintained here until merged to mainline zeppelin-solidity.
 *
 */
library SafeMathLibExt {

  function times(uint a, uint b) returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function divides(uint a, uint b) returns (uint) {
    assert(b &amp;gt; 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function minus(uint a, uint b) returns (uint) {
    assert(b &amp;lt;= a);
    return a - b;
  }

  function plus(uint a, uint b) returns (uint) {
    uint c = a + b;
    assert(c&amp;gt;=a);
    return c;
  }

}</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/Makefile" target="_blank" title="show github file">Makefile</a>
        </div>
        <div class="path">Makefile</div>
    </div>
    <div class="body">
        <pre class="content"><code class="Makefile">init:
	pip3 install -r requirements.txt

test:
	python3 setup.py test</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/requirements.txt" target="_blank" title="show github file">requirements.txt</a>
        </div>
        <div class="path">requirements.txt</div>
    </div>
    <div class="body">
        <pre class="content"><code class="txt">requests</code></pre>
    </div>
</div>
<div class="code-file center-in-page panel markdown-body">
    <div class="header">
        <div class="name">
            <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/blob/master/capture.py" target="_blank" title="show github file">capture.py</a>
        </div>
        <div class="path">capture.py</div>
    </div>
    <div class="body">
        <pre class="content"><code class="py">import requests
import re
from pathlib import Path

ROOT = Path(__file__).parent

for i in range(1, 20):
    url = &quot;https://etherscan.io/contractsVerified/{}&quot;.format(i)
    content = requests.get(url).text
    urls = re.compile(r&quot;(?&lt;=href=&#39;)/address/.*?(?=&#39;)&quot;).findall(content)
    print(urls)
    for url in urls:
        code_url = &quot;https://etherscan.io{}&quot;.format(url)
        code_page = requests.get(code_url).text
        # print(code_page)
        code = re.compile(&quot;(?&lt;=&lt;pre class=&#39;js-sourcecopyarea&#39; id=&#39;editor&#39; style=&#39;height: 330px; max-height: 450px; margin-top: 5px;&#39;&gt;).*?(?=&lt;/pre)&quot;, re.DOTALL).findall(code_page)
        print(code)
        file_name = re.compile(&quot;(?&lt;=address/).*?(?=#)&quot;).findall(url)[0]
        (ROOT / &quot;solidity-files&quot; / &quot;{}.sol&quot;.format(file_name)).write_text(code[0])
</code></pre>
    </div>
</div>

<div class="github center-in-page markdown-body">
    <span class="github-icon"><img src="../../images/github.jpg"></span>
    <span class="repo-url">
        <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo">打开Github项目地址</a>
    </span>
    <span class="repo-issues">
        <a href="https://github.com/freewind-demos/etherscan-get-contracts-demo/issues?q=">有疑问上Github Issues上讨论</a>
    </span>
</div>

<script src="../../js/site.js"></script>
<script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1274292847'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s13.cnzz.com/z_stat.php%3Fid%3D1274292847' type='text/javascript'%3E%3C/script%3E"));
</script>
</body>
</html>